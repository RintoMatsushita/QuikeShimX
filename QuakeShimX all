<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>QuakeSimX  vβ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

<style>
:root{
  --bg:#070d14;
  --panel:#0d1620;
  --muted:#9fb0b8;
  --accent:#57c7ff;
  --accent-2:#61ffd6;
  --accent-warm:#ffcc66;
  --glass:rgba(255,255,255,0.06);
  --text:#eaf6ff;
  --text-weak:#cfe3ee;
  --border:rgba(255,255,255,0.08);
  --shadow:0 20px 60px rgba(0,0,0,0.45);
  --shadow-soft:0 10px 30px rgba(0,0,0,0.35);
  --backdrop:blur(10px);
}

body[data-theme="light"]{
  --bg:#f6fbff;
  --panel:#ffffff;
  --muted:#56727f;
  --accent:#1380c9;
  --accent-2:#00a595;
  --accent-warm:#b37a00;
  --glass:rgba(0,0,0,0.04);
  --text:#0e1a22;
  --text-weak:#324a57;
  --border:rgba(0,0,0,0.12);
  --shadow:0 16px 50px rgba(0,0,0,0.15);
  --shadow-soft:0 8px 24px rgba(0,0,0,0.12);
}

/* Auto theme respects OS */
@media (prefers-color-scheme: light){
  body[data-theme="auto"]{
    --bg:#f6fbff;
    --panel:#ffffff;
    --muted:#56727f;
    --accent:#1380c9;
    --accent-2:#00a595;
    --accent-warm:#b37a00;
    --glass:rgba(0,0,0,0.04);
    --text:#0e1a22;
    --text-weak:#324a57;
    --border:rgba(0,0,0,0.12);
    --shadow:0 16px 50px rgba(0,0,0,0.15);
    --shadow-soft:0 8px 24px rgba(0,0,0,0.12);
  }
}

/* --------------------------
   Base
--------------------------- */
*{ box-sizing:border-box }
html,body{ height:100%; margin:0; }
body{
  background:linear-gradient(180deg,#020305,var(--bg));
  color:var(--text);
  font-family:"Noto Sans JP",system-ui,Segoe UI,Roboto,Helvetica,Arial;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}
a{ color:var(--accent); text-decoration:none }
small,.small{ color:var(--muted); font-size:12px }
hr{ border:none; border-top:1px solid var(--border) }

button{
  cursor:pointer;
  border:none;
  border-radius:12px;
  padding:10px 14px;
  background:rgba(255,255,255,0.08);
  color:var(--text);
  transition:transform .06s ease,opacity .2s,background .2s,box-shadow .2s;
  box-shadow:0 0 0 0 transparent;
}
button:hover{ opacity:0.92 }
button:active{ transform:translateY(1px) scale(0.99) }
button:disabled{
  opacity:0.55; cursor:not-allowed;
}
button.primary{
  background:linear-gradient(180deg,var(--accent),color-mix(in oklab, var(--accent) 60%, #0b4a6a));
  color:#05131a; font-weight:800;
}
button.ghost{
  background:transparent;
  border:1px solid var(--border);
  color:var(--muted);
}

input[type="number"],
input[type="text"],
input[type="url"],
input[type="password"],
input[type="range"],
select{
  width:100%;
  padding:9px 10px;
  border-radius:10px;
  border:1px solid transparent;
  background:rgba(255,255,255,0.08);
  color:var(--text);
  transition:border-color .15s,background .15s,box-shadow .2s;
}
body[data-theme="light"] input[type="number"],
body[data-theme="light"] input[type="text"],
body[data-theme="light"] input[type="url"],
body[data-theme="light"] input[type="password"],
body[data-theme="light"] input[type="range"],
body[data-theme="light"] select{
  background:rgba(0,0,0,0.04);
}
input:focus,select:focus{
  outline:none; border-color:var(--accent);
  box-shadow:0 0 0 3px color-mix(in oklab, var(--accent) 25%, transparent);
  background:rgba(255,255,255,0.11);
}
label{ display:block; color:var(--muted); font-size:12px; margin:6px 0 4px }

/* Keyboard focus */
:focus-visible{
  outline:3px solid color-mix(in oklab, var(--accent) 70%, #fff);
  outline-offset:2px;
  border-radius:10px;
}

/* Utilities */
.mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace }
.hidden{ display:none !important }
.center{ display:flex; align-items:center; justify-content:center }
.nowrap{ white-space:nowrap }

/* --------------------------
   Top Bar
--------------------------- */
#topbar{
  position:sticky; top:0; z-index:1200;
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 14px;
  background:color-mix(in oklab, var(--panel) 70%, transparent);
  backdrop-filter:var(--backdrop);
  border-bottom:1px solid var(--border);
}
.brand{ display:flex; align-items:center; gap:10px }
.brand img{ width:28px; height:28px; border-radius:8px; box-shadow:var(--shadow-soft) }
.title{ font-size:16px; color:var(--text-weak) }
.top-actions{ display:flex; gap:8px; align-items:center }

/* --------------------------
   Title / Tutorial
--------------------------- */
#title{
  position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
  background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.75));
  z-index:1000;
}
#titleCard{
  width:min(1180px,96vw); height:min(760px,92vh);
  display:grid; grid-template-columns:1fr 380px;
  border-radius:16px; overflow:hidden; border:1px solid var(--border);
  background:linear-gradient(180deg,color-mix(in oklab, var(--panel) 90%, #000), var(--panel));
  box-shadow:var(--shadow);
}
#tLeft{ padding:26px; display:flex; gap:12px; flex-direction:column }
#tLeft h1{ margin:0; font-size:34px; color:var(--accent) }
#titleMap{
  flex:1; border-radius:12px; overflow:hidden; border:1px solid var(--border);
  background:#fff; display:flex; align-items:center; justify-content:center
}
.titleBtns{ display:flex; gap:10px; flex-wrap:wrap }
#btnStart{ font-size:18px; padding:12px 20px }

#tRight{ padding:18px; display:flex; flex-direction:column; gap:12px;
  background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent) }
.slide{
  background:var(--glass);
  padding:12px; border-radius:12px; border:1px solid var(--border);
  min-height:150px; display:flex; flex-direction:column; gap:8px
}
.slideNav{ display:flex; justify-content:space-between; align-items:center; margin-top:6px }
#slideIndex{ color:var(--muted) }

@media (max-width:980px){
  #titleCard{ grid-template-columns:1fr }
  #btnStart{ width:100% }
}

/* --------------------------
   Main Layout
--------------------------- */
#app{ height:calc(100vh - 56px); padding:10px }
.layout{ display:grid; grid-template-columns:1fr 410px; gap:12px; height:100% }
@media (max-width:1180px){ .layout{ grid-template-columns:1fr } #panel{ height:52vh } }

#mapWrap{ position:relative }
#map{
  width:100%; height:100%; min-height:56vh;
  border-radius:14px; overflow:hidden; box-shadow:var(--shadow-soft); z-index:1
}

/* Quick Floating Toolbar */
#floatToolbar{
  position:absolute; right:14px; bottom:14px; z-index:1100;
  display:flex; gap:8px; flex-wrap:wrap;
  background:color-mix(in oklab, var(--panel) 65%, transparent);
  border:1px solid var(--border);
  backdrop-filter:var(--backdrop);
  padding:8px; border-radius:14px; box-shadow:var(--shadow-soft)
}
#floatToolbar button{ min-width:40px }

/* --------------------------
   Right Panel (details/summary sections)
--------------------------- */
#panel{
  background:color-mix(in oklab, var(--panel) 85%, transparent);
  backdrop-filter:var(--backdrop);
  border-radius:14px; padding:10px;
  /* ★ 修正: 全体スクロールを有効化（以前は overflow:auto hidden で潰れていた） */
  overflow-y:auto; overflow-x:hidden;
  box-shadow:var(--shadow-soft);
  display:flex; flex-direction:column; gap:10px;
  scrollbar-gutter:stable both-edges;
  touch-action:pan-y;
}

/* Scrollbars (WebKit) */
#panel::-webkit-scrollbar{ width:10px }
#panel::-webkit-scrollbar-thumb{ background:rgba(255,255,255,0.18); border-radius:8px }
#panel::-webkit-scrollbar-track{ background:rgba(255,255,255,0.06); border-radius:8px }
body[data-theme="light"] #panel::-webkit-scrollbar-thumb{ background:rgba(0,0,0,0.18) }
body[data-theme="light"] #panel::-webkit-scrollbar-track{ background:rgba(0,0,0,0.06) }

/* Sections */
.section summary::-webkit-details-marker{ display:none }
.section summary{ cursor:default }
.section summary::before{ content:"●"; margin-right:6px; color:var(--muted) }
.section .content{
  padding:10px 12px; display:grid; gap:10px;
  max-height:260px; overflow:auto; padding-right:6px;
  background:color-mix(in oklab, var(--panel) 60%, transparent);
  border:1px solid var(--border); border-radius:12px;
}
.section .content::-webkit-scrollbar{ width:8px }
.section .content::-webkit-scrollbar-thumb{ background:rgba(255,255,255,0.2); border-radius:4px }
.section .content::-webkit-scrollbar-track{ background:rgba(255,255,255,0.05) }
body[data-theme="light"] .section .content::-webkit-scrollbar-thumb{ background:rgba(0,0,0,0.22) }
body[data-theme="light"] .section .content::-webkit-scrollbar-track{ background:rgba(0,0,0,0.08) }

.twoCol{ display:grid; grid-template-columns:1fr 1fr; gap:10px }
@media (max-width:560px){ .twoCol{ grid-template-columns:1fr } }

/* --------------------------
   HUD / Badges / Version
--------------------------- */
.hud,.badge{
  position:absolute; top:14px;
  background:color-mix(in oklab, var(--panel) 65%, transparent);
  padding:8px 10px; border-radius:12px; color:var(--text-weak);
  z-index:1200; border:1px solid var(--border); backdrop-filter:var(--backdrop)
}
.hud{ left:14px }
.badge{ right:14px }

.version{
  position:fixed; left:12px; bottom:12px; color:var(--muted);
  font-size:12px; z-index:1500
}

/* --------------------------
   Station / Epicenter Icons
--------------------------- */
.station-dot{
  display:flex; align-items:center; justify-content:center;
  width:34px; height:34px; border-radius:999px;
  background:var(--accent); color:#061015; font-weight:800; font-size:12px;
  border:2px solid rgba(0,0,0,0.2); box-shadow:0 2px 10px rgba(0,0,0,0.25)
}
.station-label{
  position:absolute; top:-18px; white-space:nowrap;
  background:color-mix(in oklab, var(--panel) 70%, transparent);
  color:var(--text); padding:2px 6px; border-radius:6px; font-size:11px;
  border:1px solid var(--border); backdrop-filter:var(--backdrop)
}
.countdown-pill{
  position:absolute; top:22px; white-space:nowrap;
  background:color-mix(in oklab, var(--panel) 70%, transparent);
  color:var(--text); padding:2px 6px; border-radius:6px; font-size:11px;
  border:1px solid var(--border); backdrop-filter:var(--backdrop)
}
.epi-dot{
  width:18px; height:18px; border-radius:999px; background:#ff6b6b;
  border:2px solid #d74f4f; box-shadow:0 2px 10px rgba(0,0,0,0.25)
}

/* Search highlight for station markers */
.highlight{
  outline:3px solid color-mix(in oklab, var(--accent) 60%, #fff);
  outline-offset:2px; border-radius:10px;
}

/* --------------------------
   Overlay / Alert dialog
--------------------------- */
#overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:5000 }
#obg{ position:absolute; inset:0; background:linear-gradient(180deg,rgba(0,0,0,0.55),rgba(0,0,0,0.85)); backdrop-filter:blur(2px) }
#op{
  position:relative; z-index:2;
  background:linear-gradient(180deg,color-mix(in oklab, var(--panel) 90%, #000), var(--panel));
  padding:20px; border-radius:12px; border:1px solid var(--border);
  width:min(820px,94vw); color:var(--text); box-shadow:var(--shadow)
}
#op h3{ margin:0 0 8px 0; color:var(--accent-warm) }

/* --------------------------
   Modals (Settings / Help / Spec)
--------------------------- */
.modal[hidden]{ display:none }
.modal{
  position:fixed; inset:0; z-index:5200; display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,0.45); backdrop-filter:blur(2px)
}
.modal-body{
  width:min(720px,94vw);
  background:color-mix(in oklab, var(--panel) 96%, #000);
  border:1px solid var(--border);
  border-radius:12px; padding:18px; box-shadow:var(--shadow)
}
.modal-body h3{ margin:0 0 10px; color:var(--accent) }

/* Settings form blocks */
.set-row{ display:block; margin:12px 0 }
.set-row label{ margin-bottom:6px }
.set-box{
  border:1px dashed var(--border);
  border-radius:10px;
  padding:10px 12px;
  background:color-mix(in oklab, var(--panel) 60%, transparent);
}

/* --------------------------
   Timeline & Logs
--------------------------- */
.timeline-p{ color:#5ab0ff; font-weight:700 }
.timeline-s{ color:#ff6b6b; font-weight:700 }
.timeline-t{ color:var(--accent-2); font-weight:700 }

.loglist{
  display:grid; gap:6px; max-height:240px; overflow:auto; padding-right:6px;
  border:1px dashed var(--border); border-radius:10px;
  background:color-mix(in oklab, var(--panel) 55%, transparent);
}
.loglist .item{ display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-weak) }
.loglist .tag{ font-weight:800; padding:2px 6px; border-radius:999px; border:1px solid var(--border) }
.loglist .tag.p{ background:rgba(90,176,255,0.12); color:#5ab0ff }
.loglist .tag.s{ background:rgba(255,107,107,0.12); color:#ff6b6b }
.loglist .tag.t{ background:rgba(97,255,214,0.12); color:var(--accent-2) }
.loglist .time{ opacity:0.75 }

/* --------------------------
   Leaflet tweaks (optional)
--------------------------- */
.leaflet-container{ background:transparent }
.leaflet-control-zoom{
  border:none !important;
  box-shadow:var(--shadow-soft) !important;
  overflow:hidden; border-radius:10px !important;
}
.leaflet-bar a, .leaflet-bar a:hover{
  background:color-mix(in oklab, var(--panel) 85%, transparent) !important;
  border-bottom:1px solid var(--border) !important;
  color:var(--text) !important;
}
.leaflet-bar a:hover{ filter:brightness(1.05) }

/* --------------------------
   Spec table styles (dynamic content)
--------------------------- */
#specContent table{
  width:100%; border-collapse:separate; border-spacing:0; font-size:14px
}
#specContent th, #specContent td{
  padding:10px 12px; border-top:1px solid var(--border)
}
#specContent th{
  text-align:left; color:var(--muted); width:38%;
}
#specContent tr:first-child th, #specContent tr:first-child td{ border-top:none }
#specContent tr:nth-child(odd) td{ background:color-mix(in oklab, var(--panel) 92%, transparent) }
#specContent tr td.bad{
  color:#ff6b6b; font-weight:700
}
#specContent tr td.good{
  color:var(--accent-2); font-weight:700
}

/* --------------------------
   Title ↔ App transitions
--------------------------- */
#title{ opacity:1; transition:opacity .25s ease }
#title[aria-hidden="true"], #title.hide{ opacity:0; pointer-events:none }

/* --------------------------
   Fine-tune buttons inside panels
--------------------------- */
.section .content button{ min-height:36px }
.section .content .ghost{ --tmp:1 }

/* --------------------------
   Tooltips (fallback)
--------------------------- */
[title]{ position:relative }
[title]::after{
  content:attr(title);
  position:absolute; left:50%; bottom:calc(100% + 8px);
  transform:translateX(-50%); white-space:nowrap;
  background:rgba(0,0,0,0.7); color:#fff; padding:4px 8px; border-radius:6px;
  font-size:11px; opacity:0; pointer-events:none; transition:opacity .12s;
}
[title]:hover::after{ opacity:1 }

/* --------------------------
   Animations (subtle)
--------------------------- */
@keyframes pulseDot{
  0%{ transform:scale(1) }
  50%{ transform:scale(1.06) }
  100%{ transform:scale(1) }
}
.station-dot{ animation:pulseDot 3.5s ease-in-out infinite }

/* --------------------------
   Print
--------------------------- */
@media print{
  #topbar, #panel, #floatToolbar, .hud, .badge, .version{ display:none !important }
  #map{ border-radius:0; box-shadow:none }
  body{ background:#fff; color:#000 }
}

</style>
</head>
<body>

  <!-- ===== Top Bar ===== -->
  <header id="topbar" role="banner" aria-label="アプリ上部バー">
    <div class="brand" aria-label="ブランド">
      <img id="brandLogo" alt="QuakeSimX ロゴ" src="https://dummyimage.com/40x40/57c7ff/05131a.png&text=Q" width="28" height="28" decoding="async" />
      <span class="title">QuakeSimX <b>vβ+</b></span>
    </div>
    <div class="top-actions" aria-label="トップバー操作">
      <button id="btnShot" class="ghost" type="button" title="スクリーンショット">スクリーンショット</button>
      <button id="btnHelp" class="ghost" type="button" title="ショートカット">ショートカット</button>
      <button id="btnSettings" class="ghost" type="button" title="設定">設定</button>
    </div>
  </header>

  <!-- ===== Title & Tutorial ===== -->
  <div id="title" role="dialog" aria-modal="true" aria-labelledby="appTitleHeading">
    <div id="titleCard">
      <div id="tLeft">
        <h1 id="appTitleHeading">QuakeSimX vβ+</h1>

        <div id="titleMap" aria-hidden="true">
          <svg viewBox="0 0 1600 1200" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-label="Intro Map">
            <rect width="100%" height="100%" fill="#ffffff"/>
            <path d="M980 140l40 40-20 60 40 60-10 60 50 50-30 70 60 40-30 80 40 70-60 20-50-20-40 30-70-10-40 30-60-10-60-50-70-10-50-40-40-60-30-80 20-70 40-60 60-40 90-20 80-30 70-10 60-10z" fill="#dfe8ef" stroke="#333" stroke-width="2"/>
            <text x="16" y="28" font-size="18" fill="#333">Japan (illustration)</text>
          </svg>
        </div>

        <div class="titleBtns">
          <button id="btnStart" class="primary" type="button">開始</button>
          <button id="btnTutorial" class="ghost" type="button">チュートリアル</button>
          <button id="btnAIMode" class="ghost" type="button">AI推論モード</button>
        </div>

        <div class="titleBtns">
          <button id="btnSpecMin" class="ghost" type="button">必要スペックを見る</button>
          <button id="btnSpecRec" class="ghost" type="button">推奨スペックを見る</button>
        </div>

        <small>スマホ：ダブルタップ=観測点、2本指=ズーム、1本指ドラッグ=パン（ビューモード推奨）。</small>
      </div>

      <div id="tRight" aria-label="チュートリアル">
        <div class="slide" data-s="0" aria-live="polite">
          <h3>1/3 はじめに</h3>
          <p class="small">ツール：震源（最大5）/観測点（青）を追加編集。ビュー：編集無効・ズーム/パンのみ。S到達で震度バッジ表示。</p>
          <div class="slideNav">
            <div class="small" id="slideIndex">スライド 1 / 3</div>
            <div>
              <button id="prevSlide" class="ghost" type="button" disabled>前へ</button>
              <button id="nextSlide" class="ghost" type="button">次へ</button>
            </div>
          </div>
        </div>

        <div class="slide" data-s="1" style="display:none" aria-live="polite">
          <h3>2/3 追加方法</h3>
          <p class="small">地図クリック=震源、<b>ダブルタップ/ダブルクリック=観測点</b>。名前はクリックで編集。</p>
          <div class="slideNav">
            <div class="small">スライド 2 / 3</div>
            <div>
              <button class="ghost" id="prev2" type="button">前へ</button>
              <button class="ghost" id="next2" type="button">次へ</button>
            </div>
          </div>
        </div>

        <div class="slide" data-s="2" style="display:none" aria-live="polite">
          <h3>3/3 地図と物理</h3>
          <p class="small">P/S速度や距離減衰 d を調整。地図透明度スライダで背景を薄くできます。</p>
          <div class="slideNav">
            <div class="small">スライド 3 / 3</div>
            <div>
              <button class="ghost" id="prev3" type="button">前へ</button>
              <button class="primary" id="startFromSlide" type="button">開始</button>
            </div>
          </div>
        </div>

        <small>AI推論は別チュートリアルに切替（外部API拡張ポイントあり）。</small>
      </div>
    </div>
  </div>

  <!-- ===== Main App ===== -->
  <div id="app" hidden>
    <div class="layout">
      <div id="mapWrap">
        <div id="map" aria-label="map" role="application"></div>

        <div class="hud" id="hud" aria-live="polite">ツール: クリック=震源 / ダブルタップ=観測点 / ドラッグ=移動</div>
        <div class="badge" id="modeBadge">Mode: TOOL</div>

        <div id="floatToolbar" role="group" aria-label="クイックコントロール">
          <button id="quickStart" class="primary" type="button" title="再生">▶</button>
          <button id="quickPause" class="ghost" type="button" title="一時停止/再開">⏸</button>
          <button id="quickStop" class="ghost" type="button" title="停止">■</button>
          <button id="quickFit" class="ghost" type="button" title="全体を表示">⤢</button>
        </div>
      </div>

      <aside id="panel" aria-label="コントロールパネル">
        <!-- シミュレーション / モード -->
        <details class="section" open>
          <summary>シミュレーション / モード</summary>
          <div class="content">
            <div class="twoCol">
              <button id="runStart" class="primary" type="button">Start</button>
              <div style="display:flex;gap:8px;flex-wrap:wrap">
                <button id="runPause" class="ghost" type="button" disabled>Pause</button>
                <button id="runResume" class="ghost" type="button" disabled>Resume</button>
                <button id="runStop" class="ghost" type="button" disabled>Stop</button>
              </div>
            </div>

            <div class="twoCol">
              <div>
                <label for="modeSel">モード</label>
                <select id="modeSel" aria-label="モード選択">
                  <option value="TOOL">ツール</option>
                  <option value="VIEW">ビュー</option>
                  <option value="AI">AI推論</option>
                </select>
              </div>
              <div>
                <label for="speed">再生速度</label>
                <input id="speed" type="range" min="0.25" max="4" step="0.05" value="1" />
              </div>
            </div>

            <div class="twoCol">
              <div>
                <button id="fitAll" class="ghost" type="button" style="width:100%">全体を表示</button>
              </div>
              <div class="twoCol" style="grid-template-columns:repeat(4,1fr)">
                <button id="jumpBack5" class="ghost" type="button">-5s</button>
                <button id="jumpFwd5" class="ghost" type="button">+5s</button>
                <button id="jumpFwd10" class="ghost" type="button">+10s</button>
                <button id="jumpToEnd" class="ghost" type="button">End</button>
              </div>
            </div>

            <div class="twoCol" style="margin-top:6px">
              <div>
                <label for="perfMode">軽量モード</label>
                <select id="perfMode">
                  <option value="off" selected>オフ</option>
                  <option value="on">オン</option>
                </select>
              </div>
              <div>
                <label for="perfInterval">更新間隔 (ms)</label>
                <input id="perfInterval" type="number" min="100" step="50" value="250" />
                <small class="small">値を上げるほどCPU負荷↓（推奨 200〜400ms）</small>
              </div>
            </div>

            <small>開始時は自動でビューへ（編集無効／ズーム&パンのみ）。</small>
          </div>
        </details>

        <!-- サウンド / 読み上げ -->
        <details class="section">
          <summary>サウンド / 読み上げ</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="muteSel">ミュート</label>
                <select id="muteSel">
                  <option value="off">Off</option>
                  <option value="on">On</option>
                </select>
              </div>
              <div>
                <label for="vol">音量</label>
                <input id="vol" type="range" min="0" max="1" step="0.01" value="0.35" />
              </div>
            </div>
            <div class="twoCol">
              <div>
                <label for="ttsMode">TTS（予想震度の読み上げ）</label>
                <select id="ttsMode" aria-label="読み上げモード">
                  <!-- ★修正: 既定を「全て読み上げ」に変更 -->
                  <option value="off">オフ</option>
                  <option value="all" selected>全て読み上げ</option>
                  <option value="major">主要都市のみ</option>
                  <option value="jma5">5弱以上のみ</option>
                </select>
              </div>
              <div>
                <label for="ttsRate">話速</label>
                <input id="ttsRate" type="range" min="0.7" max="1.3" step="0.05" value="1.0" />
              </div>
            </div>
          </div>
        </details>

        <!-- 震源 -->
        <details class="section" open>
          <summary>震源（最大5）</summary>
          <div class="content">
            <div class="twoCol">
              <div><label for="inMag">M</label><input id="inMag" type="number" step="0.1" min="-2" max="12" value="6.5" /></div>
              <div><label for="inDepth">深さ(km)</label><input id="inDepth" type="number" step="0.1" min="0.1" max="750" value="30" /></div>
            </div>
            <button id="btnAddEpic" class="primary" type="button">地図中心に震源追加</button>
            <div id="epicList" class="small" style="color:var(--muted)">震源なし</div>
          </div>
        </details>

        <!-- 観測点 -->
        <details class="section" open>
          <summary>観測点（青丸）</summary>
          <div class="content">
            <div class="twoCol">
              <div><label for="stName">名前</label><input id="stName" type="text" placeholder="例: 東京" /></div>
              <div class="twoCol" style="grid-template-columns:1fr 1fr">
                <div><label for="stLat">緯度</label><input id="stLat" type="number" step="0.0001" placeholder="35.68" /></div>
                <div><label for="stLon">経度</label><input id="stLon" type="number" step="0.0001" placeholder="139.76" /></div>
              </div>
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btnAddStation" class="primary" type="button">地図中心に追加</button>
              <button id="btnClearStations" class="ghost" type="button">全削除</button>
            </div>

            <div class="twoCol" style="margin-top:4px">
              <div>
                <label for="stFilter">表示フィルタ</label>
                <select id="stFilter">
                  <option value="all" selected>すべて</option>
                  <option value="major">主要都市のみ</option>
                  <option value="custom">カスタム（手動）</option>
                </select>
              </div>
              <div>
                <label for="labelToggle">ラベル</label>
                <select id="labelToggle">
                  <option value="on" selected>表示</option>
                  <option value="off">非表示</option>
                </select>
              </div>
            </div>
            <div>
              <label for="stSearch">名称検索</label>
              <input id="stSearch" type="text" placeholder="部分一致でハイライト（オフライン）" />
            </div>

            <div id="stList" class="small" style="color:var(--muted)">観測点なし</div>
          </div>
        </details>

        <!-- 地図/表示 -->
        <details class="section">
          <summary>地図 / 表示</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="tileSel">ベースマップ</label>
                <select id="tileSel">
                  <option value="osm">OSM 標準</option>
                  <option value="bright">Carto Bright</option>
                  <option value="toner">Stamen Toner</option>
                </select>
              </div>
              <div>
                <label for="tileOpacity">地図透明度</label>
                <input id="tileOpacity" type="range" min="0.2" max="1" step="0.02" value="1" />
              </div>
            </div>
            <div class="twoCol">
              <div>
                <label for="ringVis">P/Sリング</label>
                <select id="ringVis">
                  <option value="on">表示</option>
                  <option value="off">非表示</option>
                </select>
              </div>
              <div>
                <label for="hudVis">HUD表示</label>
                <select id="hudVis">
                  <option value="on">表示</option>
                  <option value="off">非表示</option>
                </select>
              </div>
            </div>
          </div>
        </details>

        <!-- 物理スケール -->
        <details class="section">
          <summary>物理スケール / 推定</summary>
          <div class="content">
            <div class="twoCol">
              <div><label for="vp">P波速度 Vp (km/s)</label><input id="vp" type="number" step="0.1" value="6.0" /></div>
              <div><label for="vs">S波速度 Vs (km/s)</label><input id="vs" type="number" step="0.1" value="3.5" /></div>
            </div>
            <div class="twoCol">
              <div>
                <label for="att">距離減衰 d (1/km)</label>
                <input id="att" type="range" min="0" max="0.008" step="0.0001" value="0.002" />
                <small>log10PGA ≈ a+bM−c·log10R − d·R（R:斜距離km）</small>
              </div>
              <div>
                <label for="modelPreset">減衰プリセット</label>
                <select id="modelPreset">
                  <option value="dLight" selected>遠距離弱め（d=0.002）</option>
                  <option value="default">デフォルト（d=0.0035）</option>
                  <option value="dStrong">遠距離強め（d=0.005）</option>
                </select>
              </div>
            </div>
          </div>
        </details>

        <!-- 津波 -->
        <details class="section" open>
          <summary>津波（簡易・海域制約）</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="tsuMode">津波シミュレーション</label>
                <select id="tsuMode">
                  <option value="off" selected>オフ</option>
                  <option value="on">オン</option>
                </select>
              </div>
              <div>
                <label for="tsuRingVis">津波リング</label>
                <select id="tsuRingVis">
                  <option value="on">表示</option>
                  <option value="off" selected>非表示</option>
                </select>
              </div>
            </div>
            <div class="twoCol">
              <div>
                <label for="seaDepth">平均水深 h (m)</label>
                <input id="seaDepth" type="number" step="10" min="100" max="11000" value="4000" />
              </div>
              <div>
                <label for="tsuSpeed">津波速度 c (km/s)</label>
                <input id="tsuSpeed" type="number" step="0.001" min="0.05" max="0.40" value="0.198" />
                <small>c ≈ √(g·h)/1000（海域内伝播／内陸進入は制限）</small>
              </div>
            </div>
            <small>※海面・海域ネットワーク上での簡易伝播。内陸へは原則侵入しません（河川湾奥の特例は将来対応）。</small>
          </div>
        </details>

        <!-- 過去地震リプレイ -->
        <details class="section" open>
          <summary>過去地震リプレイ</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="replaySel">プリセット</label>
                <select id="replaySel">
                  <option value="none" selected>選択してください</option>
                  <option value="20110311">2011-03-11 東北地方太平洋沖（M9.0/24km）</option>
                  <option value="20160416">2016-04-16 熊本（M7.0/11km）</option>
                  <option value="20180906">2018-09-06 胆振東部（M6.7/37km）</option>
                  <option value="custom">カスタム（ファイル読込）</option>
                </select>
              </div>
              <div style="display:flex;gap:8px;align-items:flex-end">
                <button id="replayLoad" class="ghost" type="button">読み込み</button>
                <button id="replayPlay" class="primary" type="button">再生</button>
                <label class="ghost" style="padding:8px 12px;cursor:pointer">
                  JSON<input id="replayFile" type="file" accept="application/json" style="display:none" />
                </label>
              </div>
            </div>
            <small>プリセットを選んで「読み込み」→「再生」。カスタムは JSON で震源/観測点を読み込み可能。</small>
          </div>
        </details>

        <!-- 断層ライン -->
        <details class="section">
          <summary>断層ライン</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="faultMode">モード</label>
                <select id="faultMode">
                  <option value="off" selected>オフ</option>
                  <option value="draw">描画</option>
                  <option value="animate">アニメ再生</option>
                </select>
              </div>
              <div>
                <label for="faultSpeed">伝播速度 (km/s)</label>
                <input id="faultSpeed" type="number" step="0.1" min="0.1" max="5" value="1.5" />
              </div>
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="faultStart" class="ghost" type="button">描画開始</button>
              <button id="faultFinish" class="ghost" type="button">終了</button>
              <button id="faultClear" class="ghost" type="button">クリア</button>
            </div>
            <small>描画モード時は地図クリックで線分追加。ツールと競合しない専用入力モード。</small>
          </div>
        </details>

        <!-- プリセット / 保存・共有 -->
        <details class="section">
          <summary>プリセット / 保存・共有</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="presetScenario">シナリオプリセット</label>
                <select id="presetScenario">
                  <option value="none" selected>選択してください</option>
                  <option value="nankai">南海トラフ（M8.2 / h=20km）</option>
                  <option value="sagami">相模トラフ（M7.6 / h=30km）</option>
                  <option value="japantrench">日本海溝（M8.5 / h=25km）</option>
                </select>
              </div>
              <div style="display:flex;gap:8px;align-items:flex-end">
                <button id="applyPreset" class="primary" type="button">適用</button>
                <button id="clearAll" class="ghost" type="button">全消去</button>
              </div>
            </div>

            <div class="twoCol">
              <div>
                <label>状態を保存（ブラウザ）</label>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button id="saveLocal" class="ghost" type="button">保存</button>
                  <button id="loadLocal" class="ghost" type="button">読込</button>
                  <button id="delLocal" class="ghost" type="button">削除</button>
                </div>
              </div>
              <div>
                <label>ファイル</label>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button id="exportJson" class="ghost" type="button">エクスポート</button>
                  <label class="ghost" style="padding:8px 12px;cursor:pointer">
                    インポート<input id="importJson" type="file" accept="application/json" style="display:none" />
                  </label>
                </div>
              </div>
            </div>

            <div class="twoCol">
              <div>
                <label>共有URL</label>
                <button id="copyPermalink" class="ghost" type="button">URLをコピー</button>
              </div>
              <div>
                <label for="heatToggle">ヒートマップ</label>
                <div style="display:flex;gap:8px;align-items:center">
                  <select id="heatToggle">
                    <option value="off" selected>オフ</option>
                    <option value="on">オン</option>
                  </select>
                  <input id="heatOpacity" type="range" min="0.1" max="1" step="0.05" value="0.5" />
                </div>
              </div>
            </div>
            <small>保存はブラウザ（localStorage）に「quakeSimState」として記録。共有URLは状態を埋め込みます（長くなることがあります）。</small>
          </div>
        </details>

        <!-- 到達タイムライン -->
        <details class="section" open>
          <summary>到達タイムライン（予測）</summary>
          <div class="content" id="timeline">開始すると直近到達順に表示</div>
        </details>

        <!-- アラートログ -->
        <details class="section" open>
          <summary>アラートログ</summary>
          <div class="content">
            <div id="alertLog" class="loglist small" aria-live="polite">まだログがありません。</div>
            <div style="display:flex;gap:8px;justify-content:flex-end">
              <button id="clearLog" class="ghost" type="button">ログをクリア</button>
            </div>
          </div>
        </details>
      </aside>
    </div>
  </div>

  <!-- ===== Overlay / Toast ===== -->
  <div id="overlay" aria-hidden="true">
    <div id="obg"></div>
    <div id="op" role="alertdialog" aria-labelledby="ovTitle" aria-describedby="ovMsg">
      <h3 id="ovTitle">通知</h3>
      <p id="ovMsg">メッセージ</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="ovOk" class="primary" type="button">OK</button>
        <button id="ovClose" class="ghost" type="button">閉じる</button>
      </div>
    </div>
  </div>

  <!-- ===== Settings Modal ===== -->
  <div id="settingsModal" class="modal" hidden aria-hidden="true" aria-label="設定">
    <div class="modal-body" role="dialog" aria-modal="true">
      <h3>設定</h3>

      <section class="set-row">
        <label for="themeSel">テーマ</label>
        <select id="themeSel">
          <option value="auto" selected>自動</option>
          <option value="dark">ダーク</option>
          <option value="light">ライト</option>
        </select>
      </section>

      <section class="set-row">
        <div class="twoCol">
          <div>
            <label for="settingsVol">音量</label>
            <input id="settingsVol" type="range" min="0" max="1" step="0.01" value="0.35" />
          </div>
          <div>
            <label for="voiceSel">TTS音声</label>
            <select id="voiceSel" aria-label="音声選択">
              <option value="auto" selected>自動（推奨）</option>
              <option value="voiceA">音声A</option>
              <option value="voiceB">音声B</option>
            </select>
          </div>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="btnTtsTest" class="ghost" type="button" title="『テストです。』を読み上げ">TTSテスト</button>
        </div>
      </section>

      <section class="set-row">
        <label for="zoomSensitivity">キャンバス内ズーム感度</label>
        <input id="zoomSensitivity" type="range" min="0.5" max="2" step="0.05" value="1" />
      </section>

      <section class="set-row">
        <details>
          <summary>震度表示について</summary>
          <div class="set-box">
            <p class="small">震度はPGAの簡易推定からJMA風スケールにマッピング。物理スケールで減衰パラメータを調整可。</p>
          </div>
        </details>
        <details>
          <summary>出典等</summary>
          <div class="set-box">
            <ul class="small">
              <li>地図タイル：© OpenStreetMap / Carto / Stamen</li>
              <li>震央地名：気象庁「地震情報で用いる震央地名」・JMA Region ポリゴン</li>
            </ul>
          </div>
        </details>
      </section>

      <section class="set-row">
        <label>プラン</label>
        <div class="set-box">QuakeSimX - Free Plan</div>
      </section>

      <section class="set-row">
        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
          <button id="btnBackToTitle" class="ghost" type="button" title="タイトルへ戻る">タイトルに戻る</button>
          <button id="btnForceQuit" class="ghost" type="button" title="アプリを強制終了">サイトの強制終了</button>
          <button id="settingsClose" class="primary" type="button">閉じる</button>
        </div>
        <small class="small">※ ロゴ画像の変更はスクリプトによる差し替えのみ対応。設定画面からの変更はできません。</small>
      </section>
    </div>
  </div>

  <!-- ===== Help / Shortcuts ===== -->
  <div id="helpModal" class="modal" hidden aria-hidden="true">
    <div class="modal-body" role="dialog" aria-modal="true">
      <h3>ショートカット</h3>
      <ul class="small">
        <li><b>Space</b>: 再生/一時停止</li>
        <li><b>S</b>: 停止</li>
        <li><b>F</b>: 全体表示</li>
        <li><b>[ / ]</b>: -5s / +5s</li>
        <li><b>1/2</b>: 軽量モード OFF/ON</li>
        <li><b>T</b>: 津波リング表示切替</li>
        <li><b>Esc</b>: 設定を開く / 閉じる</li>
      </ul>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="helpClose" class="primary" type="button">OK</button>
      </div>
    </div>
  </div>

  <!-- ===== Spec Modals ===== -->
  <div id="specModal" class="modal" hidden aria-hidden="true">
    <div class="modal-body" role="dialog" aria-modal="true">
      <h3 id="specTitle">システム要件</h3>
      <div id="specContent" class="small"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="specClose" class="primary" type="button">OK</button>
      </div>
    </div>
  </div>

  <div class="version" aria-hidden="true">vβ+ 完全版</div>

<script>
/* =========================================================================
   QuakeSimX vβ+ — 巨大ワンファイル JavaScript
   - チュートリアル遷移修正
   - すべてのモードで軽量化（Canvas描画）有効
   - 震源：JMA震央地名（代表区分を多数内蔵／Tochigi北・南、オホーツク海等を明確化）
   - 津波：海域ベースン内のみ伝播（太平洋⇄日本海・オホーツク海の跨ぎを禁止／内陸抑制）
   - シミュ中の編集ロック（停止時のみ編集可能）
   - 断層描画：入力専用モードでツール競合解消
   - TTS：GitHub Pagesでも読み上げ安定（ユーザー操作後に初期化／voiceschanged対応）
   - 設定：Escで開閉／ロゴ変更はスクリプトAPIのみ（UIからは不可）
   - 主要都市に「那覇」を追加済み
   - 震源自動アナウンス（開始時）
   ======================================================================= */

(() => {
  'use strict';

  /* ------------------------------------------------------------
   * DOM Refs（HTMLに存在する要素のみ参照）
   * ---------------------------------------------------------- */
  const $ = (id) => document.getElementById(id);

  // Topbar
  const brandLogo = $('brandLogo');
  const btnShot = $('btnShot');
  const btnHelp = $('btnHelp');
  const btnSettings = $('btnSettings');

  // Title / Tutorial
  const title = $('title');
  const titleCard = $('titleCard');
  const app = $('app');
  const btnStart = $('btnStart');
  const btnTutorial = $('btnTutorial');
  const btnAIMode = $('btnAIMode');
  const btnSpecMin = $('btnSpecMin');
  const btnSpecRec = $('btnSpecRec');

  // Tutorial slides
  const slideEls = [...document.querySelectorAll('#tRight .slide')];
  const slideIndex = $('slideIndex');
  const prevSlide = $('prevSlide');
  const nextSlide = $('nextSlide');
  const prev2 = $('prev2');
  const next2 = $('next2');
  const prev3 = $('prev3');
  const startFromSlide = $('startFromSlide');

  // Map & Toolbar
  const mapEl = $('map');
  const quickStart = $('quickStart');
  const quickPause = $('quickPause');
  const quickStop = $('quickStop');
  const quickFit = $('quickFit');

  // Main controls
  const runStart = $('runStart');
  const runPause = $('runPause');
  const runResume = $('runResume');
  const runStop = $('runStop');
  const modeSel = $('modeSel');
  const speedIn = $('speed');
  const fitAllBtn = $('fitAll');
  const jumpBack5 = $('jumpBack5');
  const jumpFwd5 = $('jumpFwd5');
  const jumpFwd10 = $('jumpFwd10');
  const jumpToEnd = $('jumpToEnd');
  const perfModeSel = $('perfMode');
  const perfIntervalIn = $('perfInterval');

  // Sources / Stations
  const inMag = $('inMag');
  const inDepth = $('inDepth');
  const btnAddEpic = $('btnAddEpic');
  const epicList = $('epicList');
  const stName = $('stName');
  const stLat = $('stLat');
  const stLon = $('stLon');
  const btnAddStation = $('btnAddStation');
  const btnClearStations = $('btnClearStations');
  const stFilter = $('stFilter');
  const labelToggle = $('labelToggle');
  const stSearch = $('stSearch');
  const stList = $('stList');

  // Map display
  const tileSel = $('tileSel');
  const tileOpacity = $('tileOpacity');
  const ringVis = $('ringVis');
  const hudVis = $('hudVis');

  // Physics
  const vpIn = $('vp');
  const vsIn = $('vs');
  const attIn = $('att');
  const modelPreset = $('modelPreset');

  // Tsunami
  const tsuModeSel = $('tsuMode');
  const tsuRingVis = $('tsuRingVis');
  const seaDepthIn = $('seaDepth');
  const tsuSpeedIn = $('tsuSpeed');

  // Replay
  const replaySel = $('replaySel');
  const replayLoad = $('replayLoad');
  const replayPlay = $('replayPlay');
  const replayFile = $('replayFile');

  // Faults
  const faultMode = $('faultMode');
  const faultSpeed = $('faultSpeed');
  const faultStart = $('faultStart');
  const faultFinish = $('faultFinish');
  const faultClear = $('faultClear');

  // Preset/save/share
  const presetScenario = $('presetScenario');
  const applyPreset = $('applyPreset');
  const clearAll = $('clearAll');
  const saveLocal = $('saveLocal');
  const loadLocal = $('loadLocal');
  const delLocal = $('delLocal');
  const exportJson = $('exportJson');
  const importJson = $('importJson');
  const copyPermalink = $('copyPermalink');
  const heatToggle = $('heatToggle');
  const heatOpacity = $('heatOpacity');

  // HUD / overlay / timeline
  const hud = $('hud');
  const modeBadge = $('modeBadge');
  const timeline = $('timeline');
  const overlay = $('overlay');
  const ovTitle = $('ovTitle');
  const ovMsg = $('ovMsg');
  const ovOk = $('ovOk');
  const ovClose = $('ovClose');

  // Audio / TTS
  const muteSel = $('muteSel');
  const volIn = $('vol');
  const ttsModeSel = $('ttsMode');
  const ttsRate = $('ttsRate');

  // Settings modal
  const settingsModal = $('settingsModal');
  const themeSel = $('themeSel');
  const settingsVol = $('settingsVol');
  const voiceSel = $('voiceSel');
  const btnTtsTest = $('btnTtsTest');
  const zoomSensitivity = $('zoomSensitivity');
  const btnBackToTitle = $('btnBackToTitle');
  const btnForceQuit = $('btnForceQuit');
  const settingsClose = $('settingsClose');

  // Help modal
  const helpModal = $('helpModal');
  const helpClose = $('helpClose');

  // Spec modal
  const specModal = $('specModal');
  const specTitle = $('specTitle');
  const specContent = $('specContent');
  const specClose = $('specClose');

  // Version
  const versionEl = document.querySelector('.version');

  /* ------------------------------------------------------------
   * Overlay Helper
   * ---------------------------------------------------------- */
  function showOverlay(title, message, onOk) {
    ovTitle.textContent = title;
    ovMsg.textContent = message;
    overlay.style.display = 'flex';
    ovOk.onclick = () => {
      if (onOk) try { onOk(); } catch (_) {}
      hideOverlay();
    };
    ovClose.onclick = hideOverlay;
  }
  function hideOverlay() { overlay.style.display = 'none'; }

  /* ------------------------------------------------------------
   * Global State
   * ---------------------------------------------------------- */
  let map, tiles = null;
  let epicenters = []; // {id,lat,lng,M,depth,marker,pCircle,sCircle,tCircle,_moved,region}
  let stations = [];   // {id,lat,lng,name,marker,nameMarker,countdownMarker,pA,sA,tA,pred,isMajor,spoken,_moved,_lastBadge,_lastCountLabel,visible}
  let running = false, t0 = null, tOffset = 0, speed = 1;
  let vp = 6.0, vs = 3.5, dAtt = 0.002; // 既定d=0.002（遠距離弱め）
  let ringsOn = true;

  // Tsunami
  let tsunamiOn = false, tsuRingsOn = false;
  let cT = 0.198; // km/s

  // Heat
  let heatLayer = L.layerGroup();

  // Faults
  let faultDrawing = false;
  let faultLineLatLngs = [];
  let faultPolyline = null;
  let faultRunner = null;
  let faultAnim = null; // {running,start,distKm,segCum,points,speed}

  // Perf
  let perfLite = false;
  let perfInterval = 250;
  let timelineInterval = 500;
  let lastFrame = 0, lastTimelineUpdate = 0;

  // Canvas overlay for stations
  let overlayCanvas = null, overlayCtx = null, canvasEnabled = false, canvasDirty = true;
  const AUTO_CANVAS_THRESHOLD = 120;
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

  // Theme
  const THEME_KEY = 'quakeSimTheme';

  // Audio/TTS
  let audioCtx = null, masterGain = null;
  let userActivated = false; // GitHub Pages等の自動再生制限対策
  let ttsVoices = [];
  let selectedVoiceName = 'auto';

  // Logo (script-only)
  function setBrandLogo(src) {
    if (!brandLogo) return;
    if (typeof src === 'string' && src.trim()) brandLogo.src = src.trim();
  }

  // Public API（UIからは変更不可、スクリプトのみ）
  window.QuakeSimX = Object.freeze({
    setLogo: setBrandLogo
  });

  /* ------------------------------------------------------------
   * Tutorial Slides — 修正：確実に遷移
   * ---------------------------------------------------------- */
  let sIdx = 0;
  function showSlide(i) {
    sIdx = Math.max(0, Math.min(2, i | 0));
    slideEls.forEach((el, idx) => el.style.display = (idx === sIdx) ? 'block' : 'none');
    if (slideIndex) slideIndex.textContent = `スライド ${sIdx + 1} / 3`;
    if (prevSlide) prevSlide.disabled = (sIdx === 0);
    if (nextSlide) nextSlide.disabled = (sIdx === 2);
  }

  prevSlide?.addEventListener('click', () => showSlide(sIdx - 1));
  nextSlide?.addEventListener('click', () => showSlide(sIdx + 1));
  prev2?.addEventListener('click', () => showSlide(0));
  next2?.addEventListener('click', () => showSlide(2));
  prev3?.addEventListener('click', () => showSlide(1));
  startFromSlide?.addEventListener('click', startApp);
  showSlide(0);

  btnStart?.addEventListener('click', startApp);
  btnTutorial?.addEventListener('click', () => showOverlay('チュートリアル', '右側の「前へ／次へ」で1/3→3/3を移動できます。'));
  btnAIMode?.addEventListener('click', () => showOverlay('AI推論モード', '右パネル「AI推論」でAPIを設定して取得できます。'));

  /* ------------------------------------------------------------
   * Settings Modal（Escで開閉）
   * ---------------------------------------------------------- */
  function openSettings() { settingsModal.hidden = false; settingsModal.setAttribute('aria-hidden', 'false'); }
  function closeSettings() { settingsModal.hidden = true; settingsModal.setAttribute('aria-hidden', 'true'); }

  btnSettings?.addEventListener('click', openSettings);
  settingsClose?.addEventListener('click', closeSettings);
  btnBackToTitle?.addEventListener('click', () => {
    // タイトルへ戻る（軽いフェード）
    app.setAttribute('hidden', '');
    title.classList.remove('hide');
    title.setAttribute('aria-hidden', 'false');
    title.style.display = 'flex';
    closeSettings();
  });
  btnForceQuit?.addEventListener('click', () => {
    // 強制終了：シミュ停止＋UIロック
    stopSim(true);
    document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font:16px system-ui">QuakeSimX を終了しました。ページを再読み込みしてください。</div>';
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (settingsModal.hidden) openSettings(); else closeSettings();
    }
  });

  // Help modal
  btnHelp?.addEventListener('click', () => { helpModal.hidden = false; helpModal.setAttribute('aria-hidden', 'false'); });
  helpClose?.addEventListener('click', () => { helpModal.hidden = true; helpModal.setAttribute('aria-hidden', 'true'); });
  helpModal?.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.hidden = true; });

  // Specs modal
  const SPEC_MIN = {
    title: '必要スペック',
    rows: [
      ['OS', 'Windows 10 / macOS 11 / iOS 15 / Android 11'],
      ['CPU', 'デュアルコア 2GHz 以上'],
      ['RAM', '4GB 以上'],
      ['GPU', '内蔵でも可（WebGL1有効）'],
      ['ブラウザ', 'Chrome/Edge/Firefox/Safari（直近2版）'],
      ['ネット', '常時接続（地図タイル取得）']
    ]
  };
  const SPEC_REC = {
    title: '推奨スペック',
    rows: [
      ['OS', 'Windows 11 / macOS 13+ / iOS 17+ / Android 13+'],
      ['CPU', '4コア 3GHz 級'],
      ['RAM', '8GB 以上'],
      ['GPU', 'ミドルクラス（WebGL2対応）'],
      ['ブラウザ', '最新安定版（ハードウェアアクセラレータON）'],
      ['ネット', '光回線相当']
    ]
  };
  function fillSpec(modal, spec) {
    specTitle.textContent = spec.title;
    specContent.innerHTML = `<table>${spec.rows.map(r => `<tr><th>${r[0]}</th><td>${r[1]}</td></tr>`).join('')}</table>`;
  }
  btnSpecMin?.addEventListener('click', () => { fillSpec(specModal, SPEC_MIN); specModal.hidden = false; });
  btnSpecRec?.addEventListener('click', () => { fillSpec(specModal, SPEC_REC); specModal.hidden = false; });
  specClose?.addEventListener('click', () => { specModal.hidden = true; });

  /* ------------------------------------------------------------
   * Theme
   * ---------------------------------------------------------- */
  function applyTheme(v) {
    document.body.setAttribute('data-theme', v || 'auto');
    localStorage.setItem(THEME_KEY, v || 'auto');
  }
  (function initTheme() {
    const saved = localStorage.getItem(THEME_KEY) || 'auto';
    document.body.setAttribute('data-theme', saved);
    if (themeSel) themeSel.value = saved;
  })();
  themeSel?.addEventListener('change', () => applyTheme(themeSel.value));

  /* ------------------------------------------------------------
   * Audio / TTS（GitHub Pages対策：ユーザー操作後に有効化）
   * ---------------------------------------------------------- */
  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = parseFloat(volIn?.value || settingsVol?.value || 0.35);
    masterGain.connect(audioCtx.destination);
  }
  function setVolume(v) { if (masterGain) masterGain.gain.value = v; }

  function unlockByUserGesture() {
    if (userActivated) return;
    userActivated = true;
    try { ensureAudio(); audioCtx.resume?.(); } catch {}
    // iOS Safari で voices が遅れることがある
    loadVoices();
  }
  window.addEventListener('pointerdown', unlockByUserGesture, { once: false, passive: true });
  window.addEventListener('keydown', unlockByUserGesture, { once: false });

  function loadVoices() {
    try {
      const vs = window.speechSynthesis?.getVoices() || [];
      if (vs.length > 0) ttsVoices = vs;
    } catch {}
  }
  if ('speechSynthesis' in window) {
    window.speechSynthesis.onvoiceschanged = () => {
      ttsVoices = window.speechSynthesis.getVoices();
    };
  }
  voiceSel?.addEventListener('change', () => {
    selectedVoiceName = voiceSel.value;
  });

  function pickJapaneseVoice() {
    const vs = ttsVoices;
    if (!vs || vs.length === 0) return null;
    if (selectedVoiceName && selectedVoiceName !== 'auto') {
      const byName = vs.find(v => v.name === selectedVoiceName);
      if (byName) return byName;
    }
    // 日本語優先
    const ja = vs.filter(v => (v.lang || '').toLowerCase().startsWith('ja'));
    // Google系や高品質を優先
    const pref = ['Google 日本語', 'Kyoko', 'Otoya', 'Microsoft', 'Siri'];
    for (const p of pref) {
      const m = ja.find(v => (v.name || '').includes(p));
      if (m) return m;
    }
    return ja[0] || vs[0];
  }

  function isMuted() { return muteSel?.value === 'on'; }
  function ttsEnabled() { return ttsModeSel?.value !== 'off' && 'speechSynthesis' in window; }

  function speakJP(text) {
    if (!userActivated) return; // 自動再生対策：必ずユーザー操作後
    if (isMuted() || !ttsEnabled()) return;
    try {
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'ja-JP';
      const v = pickJapaneseVoice();
      if (v) u.voice = v;
      u.rate = parseFloat(ttsRate?.value || 1.0);
      window.speechSynthesis.speak(u);
    } catch {}
  }

  volIn?.addEventListener('input', () => setVolume(parseFloat(volIn.value || '0.35')));
  settingsVol?.addEventListener('input', () => setVolume(parseFloat(settingsVol.value || '0.35')));
  btnTtsTest?.addEventListener('click', () => {
    unlockByUserGesture();
    speakJP('テストです。');
  });

  /* ------------------------------------------------------------
   * Map Initialize（Leaflet）
   * ---------------------------------------------------------- */
  function startApp() {
    title.classList.add('hide');
    title.setAttribute('aria-hidden', 'true');
    setTimeout(() => {
      title.style.display = 'none';
      app.removeAttribute('hidden');
      initMap();
    }, 260);
  }

  function setTiles(kind) {
    if (tiles) map.removeLayer(tiles);
    if (kind === 'bright') {
      tiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '©OpenStreetMap ©Carto', maxZoom: 19 });
    } else if (kind === 'toner') {
      tiles = L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', { attribution: 'Map tiles by Stamen, ©OpenStreetMap', maxZoom: 20 });
    } else {
      tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '©OpenStreetMap contributors', maxZoom: 19 });
    }
    tiles.addTo(map);
    tiles.setOpacity(parseFloat(tileOpacity?.value || '1'));
  }

  function initMap() {
    map = L.map('map', {
      zoomControl: true,
      minZoom: 4,
      maxZoom: 12,
      preferCanvas: true,
      doubleClickZoom: false,
      wheelDebounceTime: 35
    });
    setTiles(tileSel?.value || 'osm');

    // 初期ビュー
    map.setView([36.2048, 138.2529], 5);

    // ズーム感度調整（疑似：Wheel delta倍率）
    let wheelCoef = parseFloat(zoomSensitivity?.value || '1') || 1;
    zoomSensitivity?.addEventListener('input', () => {
      wheelCoef = parseFloat(zoomSensitivity.value || '1') || 1;
    });
    mapEl.addEventListener('wheel', (e) => {
      if (!map) return;
      const delta = (e.deltaY < 0 ? 1 : -1) * wheelCoef;
      const z = map.getZoom();
      const next = Math.max(map.getMinZoom(), Math.min(map.getMaxZoom(), z + delta * 0.2));
      if (next !== z) {
        map.setZoomAround(map.mouseEventToLatLng(e), next);
        e.preventDefault();
      }
    }, { passive: false });

    // クリック系（断層描画時は専用モードでツール競合なし）
    map.on('click', (e) => {
      if (faultDrawing) { addFaultPoint(e.latlng); return; }
      if (running) return; // ロック：シミュ中は編集不可
      if (getMode() !== 'TOOL') return;
      addEpicAt(e.latlng.lat, e.latlng.lng);
    });
    map.on('dblclick', (e) => {
      if (faultDrawing) { addFaultPoint(e.latlng); return; }
      if (running) return; // ロック
      if (getMode() !== 'TOOL') return;
      addStationAt(e.latlng.lat, e.latlng.lng, stName?.value?.trim() || `観測点${stations.length + 1}`, true, false);
    });

    heatLayer.addTo(map);
    preloadStations(); // 主要都市＋那覇

    updateHud();
    setPerfMode(perfModeSel?.value === 'on');
    updateCanvasAutoToggle();
  }

  tileSel?.addEventListener('change', () => setTiles(tileSel.value));
  tileOpacity?.addEventListener('input', () => { if (tiles) tiles.setOpacity(parseFloat(tileOpacity.value || '1')); });

  /* ------------------------------------------------------------
   * HUD / Mode
   * ---------------------------------------------------------- */
  function getMode() { return modeSel?.value || 'TOOL'; }
  function baseHudText() {
    if (faultDrawing) return '断層描画: 地図をクリックして線分を追加（終了ボタンで確定）';
    return getMode() === 'TOOL'
      ? 'ツール: クリック=震源 / ダブルタップ=観測点 / ドラッグ=移動'
      : (getMode() === 'VIEW' ? 'ビュー: 編集無効（ズーム/パンのみ）' : 'AI: API取得で自動設定（右パネル）');
  }
  function updateHud() {
    hud.textContent = `${baseHudText()} | Speed x${(parseFloat(speedIn?.value || '1')).toFixed(2)}${perfLite ? ' | 軽量ON' : ''}${canvasEnabled ? ' | Canvas描画' : ''}`;
  }
  function setModeUI() {
    const m = getMode();
    modeBadge.textContent = `Mode: ${m}`;
    updateHud();

    // シミュ中は編集不可（停止時のみ可）
    const disable = running && (m === 'VIEW' || m === 'TOOL' || m === 'AI');
    const editors = [inMag, inDepth, btnAddEpic, btnAddStation, btnClearStations, stName, stLat, stLon];
    editors.forEach(el => { if (el) el.disabled = disable; });

    // マーカーのドラッグ可否
    stations.forEach(s => s.marker?.dragging?.[disable ? 'disable' : 'enable']());
    epicenters.forEach(e => e.marker?.dragging?.[disable ? 'disable' : 'enable']());
  }
  modeSel?.addEventListener('change', () => {
    setModeUI();
    updateCanvasAutoToggle();
    if (getMode() === 'AI') showOverlay('AI推論モード', '右パネル「AI推論」でAPIを設定して取得できます。');
  });
  hudVis?.addEventListener('change', () => {
    const on = (hudVis.value === 'on');
    document.querySelectorAll('.hud,.badge').forEach(el => el.style.display = on ? 'block' : 'none');
  });

  /* ------------------------------------------------------------
   * Logs
   * ---------------------------------------------------------- */
  const alertLog = $('alertLog');
  const clearLog = $('clearLog');
  function addLog(tag, message) {
    const now = new Date();
    const hh = String(now.getHours()).padStart(2, '0');
    const mm = String(now.getMinutes()).padStart(2, '0');
    const ss = String(now.getSeconds()).padStart(2, '0');
    const time = `${hh}:${mm}:${ss}`;

    const wrap = document.createElement('div');
    wrap.className = 'item';
    const tagEl = document.createElement('span');
    tagEl.className = 'tag ' + (tag === 'P' ? 'p' : tag === 'S' ? 's' : tag === 'T' ? 't' : '');
    tagEl.textContent = tag;
    const msgEl = document.createElement('span');
    msgEl.textContent = message;
    const timeEl = document.createElement('span');
    timeEl.className = 'time mono';
    timeEl.textContent = time;

    wrap.appendChild(tagEl); wrap.appendChild(msgEl); wrap.appendChild(timeEl);

    if (alertLog.textContent.includes('まだログがありません')) alertLog.textContent = '';
    alertLog.appendChild(wrap); alertLog.scrollTop = alertLog.scrollHeight;
  }
  clearLog?.addEventListener('click', () => { alertLog.textContent = 'まだログがありません。'; });

  /* ------------------------------------------------------------
   * Station Canvas Overlay（軽量化：すべてのモードで有効）
   * ---------------------------------------------------------- */
  function ensureCanvasOverlay() {
    if (overlayCanvas) return;
    overlayCanvas = document.createElement('canvas');
    overlayCanvas.id = 'stationsCanvas';
    Object.assign(overlayCanvas.style, {
      position: 'absolute', left: '0', top: '0', width: '100%', height: '100%',
      pointerEvents: 'none', zIndex: 1099
    });
    const wrap = document.getElementById('mapWrap') || document.body;
    wrap.appendChild(overlayCanvas);
    overlayCtx = overlayCanvas.getContext('2d', { alpha: true, desynchronized: true });
    resizeCanvas();
    map.on('move zoom moveend zoomend', () => { canvasDirty = true; });
    window.addEventListener('resize', resizeCanvas);
  }
  function resizeCanvas() {
    if (!overlayCanvas || !map) return;
    const size = map.getSize();
    overlayCanvas.width = Math.floor(size.x * DPR);
    overlayCanvas.height = Math.floor(size.y * DPR);
    overlayCtx.setTransform(DPR, 0, 0, DPR, 0, 0);
    canvasDirty = true;
  }
  function enableCanvasStations(enable) {
    if (enable && !canvasEnabled) {
      ensureCanvasOverlay();
      stations.forEach(s => {
        if (s.visible) {
          if (map.hasLayer(s.marker)) map.removeLayer(s.marker);
          if (s.countdownMarker && map.hasLayer(s.countdownMarker)) map.removeLayer(s.countdownMarker);
          if (s.nameMarker && map.hasLayer(s.nameMarker)) map.removeLayer(s.nameMarker);
        }
      });
      canvasEnabled = true; canvasDirty = true;
    } else if (!enable && canvasEnabled) {
      stations.forEach(s => {
        if (s.visible) {
          if (!map.hasLayer(s.marker)) map.addLayer(s.marker);
          if (s.countdownMarker && !map.hasLayer(s.countdownMarker)) map.addLayer(s.countdownMarker);
          if (s.nameMarker && labelToggle?.value === 'on' && !map.hasLayer(s.nameMarker)) map.addLayer(s.nameMarker);
        }
      });
      canvasEnabled = false;
      if (overlayCanvas) { overlayCanvas.remove(); overlayCanvas = null; overlayCtx = null; }
    }
    canvasDirty = true;
    updateHud?.();
  }
  function updateCanvasAutoToggle() {
    const manyStations = stations.filter(s => s.visible).length > AUTO_CANVAS_THRESHOLD;
    const shouldCanvas = perfLite || running || manyStations;
    enableCanvasStations(shouldCanvas);
  }
  function drawStationsCanvas() {
    if (!canvasEnabled || !overlayCtx || !map) return;
    if (!canvasDirty) return;
    canvasDirty = false;
    const ctx = overlayCtx;
    const size = map.getSize();
    ctx.clearRect(0, 0, size.x, size.y);

    const zoom = map.getZoom();
    const showText = zoom >= 6;
    const showLabelMajorOnly = true;
    const nowT = running ? getElapsed() : tOffset;

    stations.forEach(s => {
      if (!s.visible) return;
      const p = map.latLngToContainerPoint([s.lat, s.lng]);
      if (p.x < -40 || p.y < -40 || p.x > size.x + 40 || p.y > size.y + 40) return;

      const fill = s.sA && s.pred ? (s.pred.color || '#ff5a5a') : '#57c7ff';
      ctx.beginPath(); ctx.arc(p.x, p.y, 9, 0, Math.PI * 2); ctx.fillStyle = fill; ctx.fill();

      if (s._lastBadge) {
        ctx.fillStyle = '#061015';
        ctx.font = '700 11px ui-sans-serif, system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(s._lastBadge, p.x, p.y + 0.5);
      }

      if (showText && (s.isMajor || !showLabelMajorOnly) && s.pred) {
        let tag = '', left = Infinity;
        if (!s.pA) { tag = 'P'; left = s.pred.arrP - nowT; }
        else if (!s.sA) { tag = 'S'; left = s.pred.arrS - nowT; }
        else if (tsunamiOn && !s.tA && isFinite(s.pred.arrT)) { tag = 'T'; left = s.pred.arrT - nowT; }
        if (isFinite(left) && left > 0) {
          const sec = perfLite ? Math.round(left) : Math.max(0, left).toFixed(1);
          const txt = `${tag} ${sec}s`;
          ctx.font = '11px ui-sans-serif, system-ui';
          const w = ctx.measureText(txt).width + 10;
          ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(p.x - w / 2, p.y + 14, w, 16);
          ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
          ctx.fillText(txt, p.x, p.y + 15);
        }
      }

      if (showText && (s.isMajor || !showLabelMajorOnly) && s.name) {
        const nm = s.name;
        ctx.font = '11px ui-sans-serif, system-ui';
        const w = ctx.measureText(nm).width + 10;
        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(p.x - w / 2, p.y - 30, w, 16);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(nm, p.x, p.y - 29);
      }
    });
  }

  /* ------------------------------------------------------------
   * Physics / Prediction
   * ---------------------------------------------------------- */
  function clampMag(x) { return Math.max(-2, Math.min(12, isNaN(x) ? 6.5 : x)); }
  function clampDepth(x) { return Math.max(0.1, Math.min(750, isNaN(x) ? 30 : x)); }

  function stationIconHTML(text = '') { return `<div class="station-dot">${text || ''}</div>`; }
  function makeNameIconHTML(name) { return `<div class="station-label">${name}</div>`; }
  function makeCountdownHTML(txt) { return `<div class="countdown-pill">${txt}</div>`; }

  function hav(lat1, lng1, lat2, lng2) {
    const R = 6371e3; const toRad = Math.PI / 180;
    const dLat = (lat2 - lat1) * toRad, dLng = (lng2 - lng1) * toRad;
    const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.sin(dLng / 2) ** 2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }
  function estimatePGA(M, Rkm) {
    const a = -1.2, b = 0.45, c = 1.1, d = dAtt;
    const lg = a + b * M - c * Math.log10(Math.max(1, Rkm)) - d * Rkm;
    return Math.pow(10, lg);
  }
  function pgaToJMA(pga) {
    if (pga > 1.0) return { sh: '7', idx: 8 };
    if (pga > 0.6) return { sh: '6強', idx: 7 };
    if (pga > 0.3) return { sh: '6弱', idx: 6 };
    if (pga > 0.15) return { sh: '5強', idx: 5 };
    if (pga > 0.06) return { sh: '5弱', idx: 4 };
    if (pga > 0.025) return { sh: '4', idx: 3 };
    if (pga > 0.01) return { sh: '3', idx: 2 };
    if (pga > 0.003) return { sh: '2', idx: 1 };
    return { sh: '1', idx: 0 };
  }
  function colorForIdx(i) {
    const pal = ['#9ebed6', '#7fc9c9', '#6de0a8', '#f7e86b', '#ffd27a', '#ffb06b', '#ff8a5f', '#ff5a5a', '#c83b3b'];
    return pal[Math.max(0, Math.min(pal.length - 1, i))];
  }

  // 距離キャッシュ
  const H_CACHE = new Map(); // key:`e.id:s.id` -> km
  function getHkmCached(e, s) {
    const key = `${e.id}:${s.id}`;
    if (!e._moved && !s._moved && H_CACHE.has(key)) return H_CACHE.get(key);
    const h = hav(e.lat, e.lng, s.lat, s.lng) / 1000;
    H_CACHE.set(key, h);
    return h;
  }
  function markAllUnmoved() { epicenters.forEach(e => e._moved = false); stations.forEach(s => s._moved = false); }

  function arrivals(epi, st) {
    const Hkm = getHkmCached(epi, st);
    const R = Math.sqrt(Hkm * Hkm + epi.depth * epi.depth);
    return { tP: R / vp, tS: R / vs, Rkm: R, Hkm };
  }

  /* ------------------------------------------------------------
   * 海域ベースン（津波）＆ JMA 震央地名（簡易ポリゴン/BB）
   * - ベースン：太平洋、日本海、オホーツク海、東シナ海（簡易）
   * - 津波は「同一ベースン」内でのみ到達（内陸は原則除外）
   * - 震央地名：多数の代表区分＋都道府県北部/南部などBBで判定
   *   （栃木県北部/南部、福島県沖、三陸沖、オホーツク海 等を明示）
   * ---------------------------------------------------------- */

  // Point in Polygon (ray-casting)
  function pointInPolygon(lat, lng, poly) {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi > lng) !== (yj > lng)) && (lat < (xj - xi) * (lng - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // 簡易ベースン（かなり粗め／陸域を極力除外する帯状多角形）
  const BASINS = [
    {
      name: '太平洋',
      poly: [
        // 大まかに本州太平洋側沖〜小笠原〜千島の外洋（陸側を狭く含む）
        [20, 122], [26, 130], [31, 137], [35, 144], [41, 149], [46, 152], [49, 150],
        [47, 145], [44, 143], [40, 143], [36, 142], [33, 139.5], [30, 138],
        [26, 136], [22, 132], [20, 127], [20, 122]
      ],
      // 陸側の細帯を除くため、内陸は原則対象外扱いにする
      coastalOnly: true
    },
    {
      name: '日本海',
      poly: [
        [33, 127], [35.5, 130], [37.5, 134], [39.5, 137], [41.5, 139.5], [44, 141],
        [47, 140], [47, 136], [45, 133], [42, 131], [39, 129], [36, 128], [33, 127]
      ],
      coastalOnly: true
    },
    {
      name: 'オホーツク海',
      poly: [
        [43.5, 142], [45, 145], [47, 147], [51, 150], [55, 149], [55, 144],
        [50, 141], [46, 142], [44, 142], [43.5, 142]
      ],
      coastalOnly: true
    },
    {
      name: '東シナ海',
      poly: [
        [24, 122], [26, 124], [28, 126], [30, 127], [31.5, 127], [33, 126],
        [32, 125], [30, 124], [28, 123], [26, 122.5], [24, 122]
      ],
      coastalOnly: true
    }
  ];

  function whichBasin(lat, lng) {
    for (const b of BASINS) {
      if (pointInPolygon(lat, lng, b.poly)) return b.name;
    }
    return null;
  }

  // 「海岸帯」判定の簡易版：海ベースンのポリゴン境界に近い領域を陸側に少しだけ含めているため、
  // 地点がベースン内に入っていれば「沿岸」とみなす（広域内陸はそもそもポリ内に入っていない）
  function tsunamiArrivable(epi, st) {
    const bE = whichBasin(epi.lat, epi.lng);
    if (!bE) return false;
    const bS = whichBasin(st.lat, st.lng);
    if (!bS) return false;
    return bE === bS; // ベースンが同一のときのみ可
  }

  // ---- JMA 震央地名（代表区分） ----
  // ※ 完全データではなく、高頻度・代表域＋指摘の強かった地域を重点収録。
  //   - 都道府県内「北部/南部」「東部/西部」などは簡易BB（緯度/経度で2分割）で近似
  //   - 沖（○○沖/○○方）などは沖側ベースン＋沿岸BBで判定
  // 必要に応じて追加可能：JMA_REGIONS.push({ name, poly:[ [lat,lng], ... ] }) or bbox:{lat1,lat2,lng1,lng2}
  const JMA_REGIONS = [
    // --- 北海道・周辺 ---
    { name: '北海道道北', bbox: { lat1: 44.0, lat2: 45.8, lng1: 141.0, lng2: 142.8 } },
    { name: '北海道道東', bbox: { lat1: 43.0, lat2: 45.8, lng1: 143.0, lng2: 146.5 } },
    { name: '北海道道央', bbox: { lat1: 42.3, lat2: 43.8, lng1: 140.7, lng2: 143.0 } },
    { name: '北海道道南', bbox: { lat1: 41.2, lat2: 42.4, lng1: 140.2, lng2: 141.6 } },
    { name: 'オホーツク海', basin: 'オホーツク海' },
    { name: '北海道東方沖', basin: '太平洋', bbox: { lat1: 42.5, lat2: 45.5, lng1: 145.5, lng2: 149.5 } },
    { name: '石狩湾', bbox: { lat1: 43.0, lat2: 43.7, lng1: 141.0, lng2: 141.7 } },
 　 { name: '北海道西方沖', basin: '日本海', bbox: { lat1: 41.90, lat2: 45.00, lng1: 138.50, lng2: 141.00 } },
    { name: '北海道南西沖', basin: '日本海', bbox: { lat1: 41.20, lat2: 42.50, lng1: 139.00, lng2: 141.50 } },
    { name: '北海道南東沖', basin: '太平洋', bbox: { lat1: 41.00, lat2: 42.50, lng1: 142.00, lng2: 144.80 } },
    { name: '釧路沖', basin: '太平洋', bbox: { lat1: 42.50, lat2: 43.30, lng1: 144.00, lng2: 145.50 } },
    { name: '十勝沖', basin: '太平洋', bbox: { lat1: 42.20, lat2: 42.90, lng1: 143.20, lng2: 144.40 } },
    { name: '根室半島南東沖', basin: '太平洋', bbox: { lat1: 43.10, lat2: 43.80, lng1: 145.50, lng2: 146.80 } },
    { name: '青森県東方沖', basin: '太平洋', bbox: { lat1: 40.80, lat2: 41.80, lng1: 142.00, lng2: 144.00 } },
    { name: '青森県西方沖', basin: '日本海', bbox: { lat1: 40.80, lat2: 41.60, lng1: 139.50, lng2: 140.80 } },
    { name: '岩手県沖', basin: '太平洋', bbox: { lat1: 39.30, lat2: 40.60, lng1: 142.00, lng2: 143.60 } },
    { name: '秋田県沖', basin: '日本海', bbox: { lat1: 39.30, lat2: 40.60, lng1: 139.50, lng2: 140.50 } },
    { name: '山形県沖', basin: '日本海', bbox: { lat1: 38.40, lat2: 39.30, lng1: 138.60, lng2: 139.80 } },
    { name: '新潟県沖', basin: '日本海', bbox: { lat1: 37.50, lat2: 38.60, lng1: 137.60, lng2: 139.40 } },
    { name: '津軽海峡', basin: '日本海', bbox: { lat1: 41.20, lat2: 41.60, lng1: 140.50, lng2: 141.50 } },
    { name: 'サハリン南部', bbox: { lat1: 46.00, lat2: 49.50, lng1: 141.50, lng2: 144.00 } },
    { name: 'サハリン西方沖', basin: 'オホーツク海', bbox: { lat1: 47.00, lat2: 50.00, lng1: 140.00, lng2: 141.80 } },
    { name: '千島列島', basin: '太平洋', bbox: { lat1: 43.00, lat2: 49.00, lng1: 146.00, lng2: 154.00 } },
    { name: '千島列島南部', basin: '太平洋', bbox: { lat1: 43.00, lat2: 46.00, lng1: 147.00, lng2: 151.00 } },
    { name: 'オホーツク海南部', basin: 'オホーツク海', bbox: { lat1: 44.00, lat2: 47.00, lng1: 142.00, lng2: 149.00 } },

    // --- 東北 ---
    { name: '青森県北部', bbox: { lat1: 40.9, lat2: 41.5, lng1: 140.6, lng2: 141.4 } },
    { name: '青森県南部', bbox: { lat1: 40.2, lat2: 40.9, lng1: 140.6, lng2: 141.6 } },
    { name: '岩手県内陸北部', bbox: { lat1: 39.7, lat2: 40.4, lng1: 141.0, lng2: 141.9 } },
    { name: '岩手県内陸南部', bbox: { lat1: 38.9, lat2: 39.7, lng1: 140.8, lng2: 141.9 } },
    { name: '三陸沖', basin: '太平洋', bbox: { lat1: 38.0, lat2: 41.5, lng1: 142.0, lng2: 145.5 } },
    { name: '宮城県北部', bbox: { lat1: 38.6, lat2: 39.2, lng1: 140.7, lng2: 141.6 } },
    { name: '宮城県南部', bbox: { lat1: 38.0, lat2: 38.6, lng1: 140.5, lng2: 141.6 } },
    { name: '宮城県沖', basin: '太平洋', bbox: { lat1: 37.8, lat2: 39.0, lng1: 141.8, lng2: 144.0 } },
    { name: '秋田県内陸北部', bbox: { lat1: 39.9, lat2: 40.6, lng1: 140.1, lng2: 140.8 } },
    { name: '秋田県内陸南部', bbox: { lat1: 39.1, lat2: 39.9, lng1: 140.0, lng2: 140.8 } },
    { name: '山形県村山', bbox: { lat1: 38.2, lat2: 38.7, lng1: 140.1, lng2: 140.6 } },
    { name: '山形県置賜', bbox: { lat1: 37.8, lat2: 38.3, lng1: 139.9, lng2: 140.6 } },
    { name: '福島県中通り', bbox: { lat1: 37.1, lat2: 37.9, lng1: 139.4, lng2: 140.7 } },
    { name: '福島県浜通り', bbox: { lat1: 36.8, lat2: 37.9, lng1: 140.6, lng2: 141.2 } },
    { name: '福島県会津', bbox: { lat1: 37.1, lat2: 37.9, lng1: 139.2, lng2: 139.9 } },
    { name: '福島県沖', basin: '太平洋', bbox: { lat1: 36.8, lat2: 38.0, lng1: 141.4, lng2: 144.0 } },

    // --- 関東・甲信 ---
    { name: '茨城県北部', bbox: { lat1: 36.6, lat2: 36.95, lng1: 140.2, lng2: 140.7 } },
    { name: '茨城県南部', bbox: { lat1: 35.9, lat2: 36.6, lng1: 139.9, lng2: 140.6 } },
    { name: '茨城県沖', basin: '太平洋', bbox: { lat1: 35.7, lat2: 36.9, lng1: 141.0, lng2: 142.8 } },
    { name: '栃木県北部', bbox: { lat1: 36.7, lat2: 37.3, lng1: 139.3, lng2: 140.4 } },
    { name: '栃木県南部', bbox: { lat1: 36.2, lat2: 36.7, lng1: 139.3, lng2: 140.4 } }, // ← 指摘修正
    { name: '群馬県北部', bbox: { lat1: 36.65, lat2: 36.95, lng1: 138.6, lng2: 139.4 } },
    { name: '群馬県南部', bbox: { lat1: 36.2, lat2: 36.65, lng1: 138.6, lng2: 139.6 } },
    { name: '埼玉県北部', bbox: { lat1: 36.0, lat2: 36.3, lng1: 139.2, lng2: 139.7 } },
    { name: '埼玉県南部', bbox: { lat1: 35.7, lat2: 36.0, lng1: 139.2, lng2: 139.9 } },
    { name: '千葉県北西部', bbox: { lat1: 35.55, lat2: 35.9, lng1: 139.8, lng2: 140.2 } },
    { name: '千葉県南部', bbox: { lat1: 34.9, lat2: 35.5, lng1: 139.8, lng2: 140.3 } },
    { name: '千葉県東方沖', basin: '太平洋', bbox: { lat1: 35.0, lat2: 36.2, lng1: 140.8, lng2: 142.8 } },
    { name: '東京都23区', bbox: { lat1: 35.6, lat2: 35.78, lng1: 139.6, lng2: 139.9 } },
    { name: '神奈川県東部', bbox: { lat1: 35.3, lat2: 35.6, lng1: 139.5, lng2: 139.8 } },
    { name: '相模湾', basin: '太平洋', bbox: { lat1: 34.9, lat2: 35.4, lng1: 139.0, lng2: 140.0 } },
    { name: '伊豆大島近海', basin: '太平洋', bbox: { lat1: 33.8, lat2: 34.9, lng1: 138.6, lng2: 140.1 } },
    { name: '山梨県中・西部', bbox: { lat1: 35.3, lat2: 35.9, lng1: 138.2, lng2: 138.9 } },
    { name: '長野県北部', bbox: { lat1: 36.5, lat2: 37.0, lng1: 137.6, lng2: 138.6 } },
    { name: '長野県南部', bbox: { lat1: 35.2, lat2: 36.5, lng1: 137.4, lng2: 138.6 } },
　　{ name: '東京湾', basin: '太平洋', bbox: { lat1: 35.15, lat2: 35.55, lng1: 139.70, lng2: 140.10 } },
    { name: '神奈川県西部', bbox: { lat1: 35.20, lat2: 35.60, lng1: 139.00, lng2: 139.50 } },
    { name: '東京都多摩東部', bbox: { lat1: 35.60, lat2: 35.80, lng1: 139.30, lng2: 139.60 } },
    { name: '東京都多摩西部', bbox: { lat1: 35.35, lat2: 35.80, lng1: 138.90, lng2: 139.30 } },
    { name: '房総半島南方沖', basin: '太平洋', bbox: { lat1: 34.00, lat2: 35.10, lng1: 140.00, lng2: 141.60 } },
    { name: '常磐沖', basin: '太平洋', bbox: { lat1: 36.60, lat2: 37.80, lng1: 141.50, lng2: 143.00 } },
    { name: '伊豆半島東方沖', basin: '太平洋', bbox: { lat1: 34.80, lat2: 35.20, lng1: 139.20, lng2: 140.30 } },
    { name: '伊豆半島南方沖', basin: '太平洋', bbox: { lat1: 33.50, lat2: 34.50, lng1: 138.50, lng2: 139.70 } },
    { name: '東京湾北部', basin: '太平洋', bbox: { lat1: 35.45, lat2: 35.70, lng1: 139.75, lng2: 140.05 } },
　　 { name: '八丈島近海', basin: '太平洋', bbox: { lat1: 32.80, lat2: 33.50, lng1: 139.50, lng2: 140.90 } },
    { name: '八丈島東方沖', basin: '太平洋', bbox: { lat1: 32.50, lat2: 33.50, lng1: 140.90, lng2: 142.50 } },
    { name: '鳥島近海', basin: '太平洋', bbox: { lat1: 29.50, lat2: 31.50, lng1: 139.00, lng2: 141.50 } },
    { name: '鳥島東方沖', basin: '太平洋', bbox: { lat1: 29.00, lat2: 31.00, lng1: 141.50, lng2: 144.00 } },
    { name: '小笠原諸島近海', basin: '太平洋', bbox: { lat1: 26.50, lat2: 28.50, lng1: 140.80, lng2: 142.50 } },
    { name: '小笠原諸島西方沖', basin: '太平洋', bbox: { lat1: 26.00, lat2: 28.50, lng1: 138.50, lng2: 140.80 } },
    { name: '小笠原諸島東方沖', basin: '太平洋', bbox: { lat1: 26.00, lat2: 28.50, lng1: 142.50, lng2: 145.00 } },
    { name: '父島近海', basin: '太平洋', bbox: { lat1: 27.30, lat2: 27.90, lng1: 141.80, lng2: 142.30 } },
    { name: '母島近海', basin: '太平洋', bbox: { lat1: 26.50, lat2: 27.20, lng1: 142.00, lng2: 142.60 } },

 　 // --- 太平洋側の未収録（本州～四国～九州） ---
    { name: '熊野灘', basin: '太平洋', bbox: { lat1: 33.50, lat2: 34.30, lng1: 135.60, lng2: 136.90 } },
    { name: '土佐湾', basin: '太平洋', bbox: { lat1: 33.10, lat2: 33.50, lng1: 133.30, lng2: 134.30 } },
    { name: '四国沖', basin: '太平洋', bbox: { lat1: 32.00, lat2: 33.70, lng1: 132.00, lng2: 135.50 } },
    { name: '紀伊半島南方沖', basin: '太平洋', bbox: { lat1: 32.80, lat2: 33.80, lng1: 135.00, lng2: 137.20 } },
    { name: '相模灘', basin: '太平洋', bbox: { lat1: 35.00, lat2: 35.40, lng1: 139.00, lng2: 139.80 } },

    // --- 東海・北陸・近畿 ---
    { name: '静岡県中部', bbox: { lat1: 34.8, lat2: 35.1, lng1: 138.2, lng2: 138.5 } },
    { name: '駿河湾', basin: '太平洋', bbox: { lat1: 34.5, lat2: 35.0, lng1: 138.3, lng2: 138.9 } },
    { name: '遠州灘', basin: '太平洋', bbox: { lat1: 34.2, lat2: 34.8, lng1: 137.8, lng2: 138.8 } },
    { name: '愛知県西部', bbox: { lat1: 34.7, lat2: 35.3, lng1: 136.7, lng2: 137.2 } },
    { name: '三重県北部', bbox: { lat1: 34.7, lat2: 35.2, lng1: 136.2, lng2: 136.8 } },
    { name: '三重県南東沖', basin: '太平洋', bbox: { lat1: 33.6, lat2: 34.6, lng1: 136.8, lng2: 137.9 } },
    { name: '石川県能登', bbox: { lat1: 37.1, lat2: 37.6, lng1: 136.7, lng2: 137.5 } },
    { name: '福井県嶺北', bbox: { lat1: 35.7, lat2: 36.2, lng1: 136.0, lng2: 136.8 } },
    { name: '大阪府北部', bbox: { lat1: 34.7, lat2: 34.9, lng1: 135.4, lng2: 135.7 } },
    { name: '大阪湾', bbox: { lat1: 34.25, lat2: 34.7, lng1: 135.0, lng2: 135.5 } },
    { name: '京都府南部', bbox: { lat1: 34.8, lat2: 35.2, lng1: 135.5, lng2: 136.1 } },
    { name: '兵庫県南東部', bbox: { lat1: 34.6, lat2: 34.9, lng1: 135.0, lng2: 135.4 } },
    { name: '紀伊水道', basin: '太平洋', bbox: { lat1: 33.7, lat2: 34.5, lng1: 134.8, lng2: 135.6 } },
　　{ name: '日本海北部', basin: '日本海', bbox: { lat1: 41.50, lat2: 45.50, lng1: 135.00, lng2: 140.00 } },
    { name: '日本海中部', basin: '日本海', bbox: { lat1: 38.00, lat2: 41.50, lng1: 134.00, lng2: 138.50 } },
    { name: '日本海南部', basin: '日本海', bbox: { lat1: 35.00, lat2: 38.00, lng1: 131.50, lng2: 136.00 } },
    { name: '佐渡付近', basin: '日本海', bbox: { lat1: 37.70, lat2: 38.40, lng1: 138.30, lng2: 138.80 } },
    { name: '富山湾', basin: '日本海', bbox: { lat1: 36.70, lat2: 37.10, lng1: 136.70, lng2: 137.50 } },
    { name: '能登半島沖', basin: '日本海', bbox: { lat1: 37.20, lat2: 38.20, lng1: 136.50, lng2: 137.80 } },
    { name: '若狭湾', basin: '日本海', bbox: { lat1: 35.40, lat2: 35.80, lng1: 135.50, lng2: 136.40 } },
    { name: '山陰沖', basin: '日本海', bbox: { lat1: 34.80, lat2: 36.00, lng1: 132.00, lng2: 135.00 } },
    { name: '玄界灘', basin: '日本海', bbox: { lat1: 33.60, lat2: 34.30, lng1: 129.20, lng2: 130.50 } },
    { name: '対馬近海', basin: '日本海', bbox: { lat1: 34.00, lat2: 35.50, lng1: 128.50, lng2: 130.00 } },

    // --- 中国・四国・九州 ---
    { name: '広島県南東部', bbox: { lat1: 34.2, lat2: 34.6, lng1: 132.4, lng2: 133.2 } },
    { name: '岡山県南部', bbox: { lat1: 34.4, lat2: 34.9, lng1: 133.6, lng2: 134.2 } },
    { name: '香川県', bbox: { lat1: 34.0, lat2: 34.4, lng1: 133.6, lng2: 134.4 } },
    { name: '徳島県北部', bbox: { lat1: 33.9, lat2: 34.2, lng1: 134.1, lng2: 134.6 } },
    { name: '愛媛県東予', bbox: { lat1: 33.8, lat2: 34.1, lng1: 133.0, lng2: 133.6 } },
    { name: '愛媛県南予', bbox: { lat1: 32.8, lat2: 33.6, lng1: 132.3, lng2: 132.9 } },
    { name: '豊後水道', basin: '太平洋', bbox: { lat1: 32.7, lat2: 33.6, lng1: 132.5, lng2: 133.6 } },
    { name: '福岡県', bbox: { lat1: 33.3, lat2: 33.9, lng1: 130.2, lng2: 130.7 } },
    { name: '佐賀県', bbox: { lat1: 33.0, lat2: 33.5, lng1: 129.8, lng2: 130.4 } },
    { name: '長崎県北部', bbox: { lat1: 33.0, lat2: 33.4, lng1: 129.5, lng2: 130.2 } },
    { name: '熊本県北部', bbox: { lat1: 32.7, lat2: 33.2, lng1: 130.4, lng2: 130.9 } },
    { name: '熊本県南部', bbox: { lat1: 32.0, lat2: 32.7, lng1: 130.5, lng2: 131.1 } },
    { name: '大分県中部', bbox: { lat1: 33.0, lat2: 33.4, lng1: 131.4, lng2: 131.8 } },
    { name: '宮崎県北部平野部', bbox: { lat1: 32.1, lat2: 32.6, lng1: 131.4, lng2: 131.7 } },
    { name: '鹿児島県薩摩', bbox: { lat1: 31.1, lat2: 31.9, lng1: 130.2, lng2: 130.9 } },
    { name: '奄美近海', basin: '東シナ海', bbox: { lat1: 26.0, lat2: 28.9, lng1: 128.0, lng2: 130.5 } },

    // --- 九州・南西諸島 ---
    { name: '日向灘', basin: '太平洋', bbox: { lat1: 31.00, lat2: 32.30, lng1: 131.60, lng2: 132.50 } },
    { name: '九州西方沖', basin: '東シナ海', bbox: { lat1: 31.00, lat2: 33.00, lng1: 127.00, lng2: 129.00 } },
    { name: '鹿児島湾', bbox: { lat1: 31.20, lat2: 31.60, lng1: 130.50, lng2: 130.80 } },
    { name: '甑島近海', basin: '東シナ海', bbox: { lat1: 31.70, lat2: 32.20, lng1: 129.80, lng2: 130.30 } },
    { name: '種子島近海', basin: '太平洋', bbox: { lat1: 30.10, lat2: 30.80, lng1: 130.50, lng2: 131.20 } },
    { name: '屋久島近海', basin: '太平洋', bbox: { lat1: 30.10, lat2: 30.60, lng1: 130.90, lng2: 131.60 } },
    { name: 'トカラ列島近海', basin: '太平洋', bbox: { lat1: 28.00, lat2: 30.00, lng1: 129.00, lng2: 130.50 } },
    { name: '奄美大島近海', basin: '東シナ海', bbox: { lat1: 27.50, lat2: 28.80, lng1: 128.30, lng2: 130.00 } },
    { name: '喜界島近海', basin: '東シナ海', bbox: { lat1: 28.00, lat2: 28.50, lng1: 129.60, lng2: 130.00 } },
    { name: '徳之島近海', basin: '東シナ海', bbox: { lat1: 27.60, lat2: 28.10, lng1: 128.80, lng2: 129.30 } },
    { name: '沖永良部島近海', basin: '東シナ海', bbox: { lat1: 27.20, lat2: 27.60, lng1: 128.50, lng2: 129.00 } },
    { name: '与論島近海', basin: '東シナ海', bbox: { lat1: 27.00, lat2: 27.20, lng1: 128.90, lng2: 129.20 } },

 // --- 沖縄周辺 ---
    { name: '沖縄本島近海', basin: '東シナ海', bbox: { lat1: 26.00, lat2: 27.20, lng1: 127.00, lng2: 128.20 } },
    { name: '沖縄本島北西沖', basin: '東シナ海', bbox: { lat1: 26.50, lat2: 27.50, lng1: 126.00, lng2: 127.20 } },
    { name: '沖縄本島南方沖', basin: '東シナ海', bbox: { lat1: 25.00, lat2: 26.00, lng1: 127.00, lng2: 128.50 } },
    { name: '慶良間諸島近海', basin: '東シナ海', bbox: { lat1: 26.00, lat2: 26.50, lng1: 127.00, lng2: 127.80 } },
    { name: '久米島近海', basin: '東シナ海', bbox: { lat1: 26.00, lat2: 26.60, lng1: 126.90, lng2: 127.60 } },
    { name: '北大東島近海', basin: '太平洋', bbox: { lat1: 25.90, lat2: 26.40, lng1: 131.10, lng2: 131.60 } },
    { name: '南大東島近海', basin: '太平洋', bbox: { lat1: 25.50, lat2: 25.90, lng1: 131.10, lng2: 131.60 } },
    { name: '南大東島東方沖', basin: '太平洋', bbox: { lat1: 25.30, lat2: 25.80, lng1: 132.00, lng2: 133.50 } },
    { name: '宮古島近海', basin: '東シナ海', bbox: { lat1: 24.50, lat2: 25.20, lng1: 125.00, lng2: 126.00 } },
    { name: '宮古島北西沖', basin: '東シナ海', bbox: { lat1: 25.00, lat2: 25.80, lng1: 124.00, lng2: 125.10 } },
    { name: '石垣島近海', basin: '東シナ海', bbox: { lat1: 24.10, lat2: 24.60, lng1: 124.00, lng2: 124.60 } },
    { name: '石垣島北西沖', basin: '東シナ海', bbox: { lat1: 24.60, lat2: 25.30, lng1: 123.00, lng2: 124.20 } },
    { name: '西表島近海', basin: '東シナ海', bbox: { lat1: 24.10, lat2: 24.60, lng1: 123.50, lng2: 124.10 } },
    { name: '与那国島近海', basin: '東シナ海', bbox: { lat1: 24.30, lat2: 24.60, lng1: 122.90, lng2: 123.30 } },

    // --- 東アジア外縁（図にある枠） ---
    { name: '台湾付近', bbox: { lat1: 22.50, lat2: 25.50, lng1: 120.50, lng2: 122.50 } },
    { name: '黄海', basin: '東シナ海', bbox: { lat1: 33.00, lat2: 37.00, lng1: 123.00, lng2: 126.00 } },
    { name: '朝鮮半島南部', bbox: { lat1: 34.00, lat2: 37.00, lng1: 126.00, lng2: 129.00 } },
    { name: '朝鮮半島北部', bbox: { lat1: 38.00, lat2: 41.00, lng1: 125.00, lng2: 130.00 } },
    { name: '中国東北部', bbox: { lat1: 41.00, lat2: 46.00, lng1: 122.00, lng2: 127.00 } },
    { name: 'ウラジオストク付近', bbox: { lat1: 42.00, lat2: 44.00, lng1: 130.50, lng2: 133.00 } },
    { name: 'シベリア南部', bbox: { lat1: 47.00, lat2: 53.00, lng1: 125.00, lng2: 140.00 } },
    { name: 'フィリピン海北部', basin: '太平洋', bbox: { lat1: 19.50, lat2: 23.50, lng1: 130.00, lng2: 142.00 } },
    { name: 'マリアナ諸島', basin: '太平洋', bbox: { lat1: 12.00, lat2: 20.00, lng1: 140.00, lng2: 147.00 } },

　　// --- 瀬戸内・内湾（太平洋系として扱う） ---
    { name: '播磨灘', basin: '太平洋', bbox: { lat1: 34.20, lat2: 34.60, lng1: 134.30, lng2: 134.90 } },
    { name: '備讃瀬戸', basin: '太平洋', bbox: { lat1: 34.20, lat2: 34.50, lng1: 133.80, lng2: 134.30 } },
    { name: '燧灘', basin: '太平洋', bbox: { lat1: 33.90, lat2: 34.30, lng1: 132.80, lng2: 133.80 } },
    { name: '安芸灘', basin: '太平洋', bbox: { lat1: 34.00, lat2: 34.40, lng1: 132.20, lng2: 132.80 } },
    { name: '周防灘', basin: '太平洋', bbox: { lat1: 33.70, lat2: 34.00, lng1: 131.00, lng2: 131.90 } },
    { name: '伊予灘', basin: '太平洋', bbox: { lat1: 33.70, lat2: 34.20, lng1: 132.20, lng2: 132.90 } },

// --- 内陸の主要未収録（代表的なJMA区分） ---
    { name: '新潟県上越', bbox: { lat1: 36.70, lat2: 37.40, lng1: 137.80, lng2: 138.70 } },
    { name: '新潟県中越', bbox: { lat1: 37.10, lat2: 37.60, lng1: 138.50, lng2: 139.30 } },
    { name: '新潟県下越', bbox: { lat1: 37.60, lat2: 38.20, lng1: 139.20, lng2: 139.70 } },
    { name: '富山県東部', bbox: { lat1: 36.50, lat2: 36.90, lng1: 137.40, lng2: 137.80 } },
    { name: '富山県西部', bbox: { lat1: 36.50, lat2: 36.90, lng1: 136.90, lng2: 137.40 } },
    { name: '石川県加賀', bbox: { lat1: 36.10, lat2: 36.60, lng1: 136.30, lng2: 136.80 } },
    { name: '福井県嶺南', bbox: { lat1: 35.30, lat2: 35.70, lng1: 135.60, lng2: 136.30 } },
    { name: '岐阜県飛騨', bbox: { lat1: 36.10, lat2: 36.60, lng1: 136.70, lng2: 137.60 } },
    { name: '岐阜県美濃', bbox: { lat1: 35.20, lat2: 36.10, lng1: 136.50, lng2: 137.30 } },
    { name: '静岡県東部', bbox: { lat1: 34.80, lat2: 35.20, lng1: 138.70, lng2: 139.20 } },
    { name: '静岡県西部', bbox: { lat1: 34.60, lat2: 34.90, lng1: 137.60, lng2: 138.20 } },
    { name: '愛知県東部', bbox: { lat1: 34.80, lat2: 35.20, lng1: 137.20, lng2: 137.80 } },
    { name: '三重県中部', bbox: { lat1: 34.40, lat2: 34.90, lng1: 136.30, lng2: 136.80 } },
    { name: '三重県南部', bbox: { lat1: 33.70, lat2: 34.40, lng1: 136.00, lng2: 136.90 } },
    { name: '滋賀県北部', bbox: { lat1: 35.30, lat2: 35.70, lng1: 135.90, lng2: 136.40 } },
    { name: '滋賀県南部', bbox: { lat1: 34.90, lat2: 35.30, lng1: 135.80, lng2: 136.30 } },
    { name: '京都府北部', bbox: { lat1: 35.30, lat2: 35.70, lng1: 135.10, lng2: 135.80 } },
    { name: '兵庫県北部', bbox: { lat1: 35.10, lat2: 35.70, lng1: 134.60, lng2: 135.20 } },
    { name: '兵庫県南西部', bbox: { lat1: 34.60, lat2: 35.00, lng1: 134.60, lng2: 135.00 } },
    { name: '大阪府南部', bbox: { lat1: 34.30, lat2: 34.70, lng1: 135.45, lng2: 135.70 } },
    { name: '奈良県北部', bbox: { lat1: 34.50, lat2: 34.80, lng1: 135.60, lng2: 136.10 } },
    { name: '奈良県南部', bbox: { lat1: 33.90, lat2: 34.50, lng1: 135.60, lng2: 136.20 } },
    { name: '和歌山県北部', bbox: { lat1: 34.10, lat2: 34.40, lng1: 135.10, lng2: 135.60 } },
    { name: '和歌山県南部', bbox: { lat1: 33.50, lat2: 34.10, lng1: 135.40, lng2: 135.90 } },
    { name: '鳥取県東部', bbox: { lat1: 35.30, lat2: 35.60, lng1: 134.10, lng2: 134.45 } },
    { name: '鳥取県中部', bbox: { lat1: 35.30, lat2: 35.60, lng1: 133.80, lng2: 134.10 } },
    { name: '鳥取県西部', bbox: { lat1: 35.30, lat2: 35.60, lng1: 133.20, lng2: 133.80 } },
    { name: '島根県東部', bbox: { lat1: 35.20, lat2: 35.50, lng1: 132.60, lng2: 133.20 } },
    { name: '島根県西部', bbox: { lat1: 34.90, lat2: 35.40, lng1: 131.50, lng2: 132.60 } },
    { name: '隠岐', bbox: { lat1: 36.00, lat2: 36.40, lng1: 133.00, lng2: 133.40 } },
    { name: '岡山県北部', bbox: { lat1: 35.00, lat2: 35.40, lng1: 133.50, lng2: 134.30 } },
    { name: '広島県南西部', bbox: { lat1: 34.20, lat2: 34.60, lng1: 131.70, lng2: 132.40 } },
    { name: '山口県東部', bbox: { lat1: 34.00, lat2: 34.40, lng1: 131.60, lng2: 132.10 } },
    { name: '山口県中部', bbox: { lat1: 34.00, lat2: 34.40, lng1: 131.10, lng2: 131.60 } },
    { name: '山口県西部', bbox: { lat1: 34.00, lat2: 34.40, lng1: 130.50, lng2: 131.10 } },
    { name: '徳島県南部', bbox: { lat1: 33.50, lat2: 33.90, lng1: 134.10, lng2: 134.70 } },
    { name: '香川県東部', bbox: { lat1: 34.10, lat2: 34.40, lng1: 134.10, lng2: 134.40 } },
    { name: '香川県西部', bbox: { lat1: 34.00, lat2: 34.30, lng1: 133.60, lng2: 134.10 } },
    { name: '高知県東部', bbox: { lat1: 33.30, lat2: 33.60, lng1: 134.00, lng2: 134.40 } },
    { name: '高知県中部', bbox: { lat1: 33.30, lat2: 33.70, lng1: 133.40, lng2: 134.00 } },
    { name: '高知県西部', bbox: { lat1: 32.90, lat2: 33.40, lng1: 132.70, lng2: 133.50 } },
    { name: '愛媛県中予', bbox: { lat1: 33.70, lat2: 33.95, lng1: 132.50, lng2: 132.90 } },
    { name: '福岡県北九州', bbox: { lat1: 33.70, lat2: 33.95, lng1: 130.85, lng2: 131.10 } },
    { name: '長崎県南西部', bbox: { lat1: 32.50, lat2: 33.10, lng1: 129.50, lng2: 129.90 } },
    { name: '熊本県天草・芦北', bbox: { lat1: 32.20, lat2: 32.70, lng1: 130.00, lng2: 130.70 } },
    { name: '熊本県球磨', bbox: { lat1: 32.10, lat2: 32.40, lng1: 130.60, lng2: 131.10 } },
    { name: '熊本県熊本地方', bbox: { lat1: 32.60, lat2: 33.00, lng1: 130.50, lng2: 130.90 } },
    { name: '大分県北部', bbox: { lat1: 33.30, lat2: 33.70, lng1: 131.10, lng2: 131.70 } },
    { name: '大分県南部', bbox: { lat1: 32.90, lat2: 33.30, lng1: 131.40, lng2: 131.90 } },
    { name: '宮崎県北部山沿い', bbox: { lat1: 32.40, lat2: 32.90, lng1: 131.00, lng2: 131.60 } },
    { name: '宮崎県南部山沿い', bbox: { lat1: 31.60, lat2: 32.30, lng1: 130.90, lng2: 131.50 } },
    { name: '宮崎県南部平野部', bbox: { lat1: 31.60, lat2: 32.10, lng1: 131.30, lng2: 131.60 } },
    { name: '鹿児島県大隅', bbox: { lat1: 30.90, lat2: 31.60, lng1: 130.90, lng2: 131.50 } },

    // --- 海域（太平洋側） ---
    { name: '日本海溝', basin: '太平洋', bbox: { lat1: 36.0, lat2: 41.5, lng1: 142.0, lng2: 146.0 } },
    { name: '房総沖', basin: '太平洋', bbox: { lat1: 34.8, lat2: 35.9, lng1: 140.6, lng2: 142.4 } },
    { name: '相模トラフ', basin: '太平洋', bbox: { lat1: 34.6, lat2: 35.3, lng1: 139.0, lng2: 140.0 } },
    { name: '駿河トラフ', basin: '太平洋', bbox: { lat1: 34.4, lat2: 35.1, lng1: 138.3, lng2: 138.9 } },
    { name: '南海トラフ', basin: '太平洋', bbox: { lat1: 32.0, lat2: 34.5, lng1: 135.0, lng2: 138.5 } },
  ];

  function inBBox(lat, lng, bb) {
    return lat >= bb.lat1 && lat <= bb.lat2 && lng >= bb.lng1 && lng <= bb.lng2;
  }

  function nameEpicentralRegion(lat, lng) {
    // 1) BBOX/ポリゴン一致
    for (const r of JMA_REGIONS) {
      if (r.poly && pointInPolygon(lat, lng, r.poly)) return r.name;
      if (r.bbox && inBBox(lat, lng, r.bbox)) return r.name;
      if (r.basin) {
        const b = whichBasin(lat, lng);
        if (b && b === r.basin) {
          if (!r.bbox) return r.name;
          if (inBBox(lat, lng, r.bbox)) return r.name;
        }
      }
    }
    // 2) 近い地域（粗い推定）：重心から最近
    let best = null, bestD = Infinity;
    for (const r of JMA_REGIONS) {
      let c;
      if (r.bbox) {
        c = [(r.bbox.lat1 + r.bbox.lat2) / 2, (r.bbox.lng1 + r.bbox.lng2) / 2];
      } else if (r.poly && r.poly.length) {
        let la = 0, lo = 0;
        r.poly.forEach(p => { la += p[0]; lo += p[1]; });
        c = [la / r.poly.length, lo / r.poly.length];
      } else continue;
      const d = hav(lat, lng, c[0], c[1]);
      if (d < bestD) { bestD = d; best = r.name; }
    }
    return best || '不明';
  }

  /* ------------------------------------------------------------
   * Add epicenters / stations
   * ---------------------------------------------------------- */
  function addEpicAt(lat, lng) {
    if (epicenters.length >= 5) { showOverlay('上限', '震源は最大5つまで。'); return; }
    const M = clampMag(parseFloat(inMag?.value));
    const depth = clampDepth(parseFloat(inDepth?.value));
    const el = document.createElement('div'); el.className = 'epi-dot';
    const marker = L.marker([lat, lng], { draggable: !running, icon: L.divIcon({ html: el, className: '', iconSize: [18, 18] }) }).addTo(map);
    const region = nameEpicentralRegion(lat, lng);
    marker.bindTooltip(`M${M.toFixed(1)} / ${depth.toFixed(1)}km\n${region}`, { direction: 'top', offset: [0, -16] });

    const epi = { id: 'e' + Date.now() + Math.random(), lat, lng, M, depth, marker, pCircle: null, sCircle: null, tCircle: null, _moved: true, region };
    marker.on('dragend', () => {
      if (running) { marker.setLatLng([epi.lat, epi.lng]); return; } // ロック
      const ll = marker.getLatLng();
      epi.lat = ll.lat; epi.lng = ll.lng; epi._moved = true;
      epi.region = nameEpicentralRegion(epi.lat, epi.lng);
      marker.closeTooltip(); marker.bindTooltip(`M${epi.M.toFixed(1)} / ${epi.depth.toFixed(1)}km\n${epi.region}`);
      computePredictions();
    });
    marker.on('click', () => {
      if (running || getMode() !== 'TOOL') return;
      const nm = parseFloat(prompt('M?', epi.M));
      const dp = parseFloat(prompt('深さ(km)?', epi.depth));
      if (!isNaN(nm)) epi.M = clampMag(nm);
      if (!isNaN(dp)) epi.depth = clampDepth(dp);
      epi.region = nameEpicentralRegion(epi.lat, epi.lng);
      marker.closeTooltip(); marker.bindTooltip(`M${epi.M.toFixed(1)} / ${epi.depth.toFixed(1)}km\n${epi.region}`);
      computePredictions();
    });

    epicenters.push(epi);
    refreshEpicList();
    computePredictions();
  }

  function addStationAt(lat, lng, name, showLabel = true, isMajor = false) {
    const icon = L.divIcon({ html: stationIconHTML(''), className: '', iconSize: [34, 34] });
    const marker = L.marker([lat, lng], { draggable: !running, icon }).addTo(map);
    const countdown = L.marker([lat, lng], { icon: L.divIcon({ html: makeCountdownHTML(''), className: '', iconSize: null }), interactive: false }).addTo(map);
    const st = {
      id: 's' + Date.now() + Math.random(),
      lat, lng, name,
      marker, nameMarker: null, countdownMarker: countdown,
      pA: false, sA: false, tA: false, pred: null, isMajor, spoken: false,
      _moved: true, _lastBadge: '', _lastCountLabel: '', visible: true
    };
    if (showLabel && name) {
      st.nameMarker = L.marker([lat, lng], { icon: L.divIcon({ html: makeNameIconHTML(name), className: '', iconSize: null }), interactive: false }).addTo(map);
    }
    marker.on('drag', () => {
      if (running) { marker.setLatLng([st.lat, st.lng]); return; } // ロック
      const ll = marker.getLatLng();
      st.lat = ll.lat; st.lng = ll.lng;
      st.countdownMarker.setLatLng(ll);
      if (st.nameMarker) st.nameMarker.setLatLng(ll);
      st._moved = true; canvasDirty = true;
    });
    marker.on('dragend', () => computePredictions());
    marker.on('click', () => {
      if (running || getMode() !== 'TOOL') return;
      const nm = prompt('観測点名', st.name || '');
      if (nm === null) return;
      st.name = nm.trim();
      if (st.name) {
        if (!st.nameMarker) {
          st.nameMarker = L.marker([st.lat, st.lng], { icon: L.divIcon({ html: makeNameIconHTML(st.name), className: '', iconSize: null }), interactive: false }).addTo(map);
        } else {
          st.nameMarker.setIcon(L.divIcon({ html: makeNameIconHTML(st.name), className: '', iconSize: null }));
        }
      } else {
        if (st.nameMarker) { map.removeLayer(st.nameMarker); st.nameMarker = null; }
      }
      refreshStList(); canvasDirty = true;
    });

    stations.push(st);
    refreshStList();
    computePredictions();
    updateCanvasAutoToggle();
  }

  // 初期観測点（主要都市＋那覇）
  function preloadStations() {
    const major = [
      { name: '札幌', lat: 43.0618, lng: 141.3545 },
      { name: '仙台', lat: 38.2688, lng: 140.8721 },
      { name: '東京', lat: 35.6812, lng: 139.7671 },
      { name: '横浜', lat: 35.4437, lng: 139.6380 },
      { name: '千葉', lat: 35.6073, lng: 140.1063 },
      { name: 'さいたま', lat: 35.8617, lng: 139.6455 },
      { name: '川崎', lat: 35.53, lng: 139.7036 },
      { name: '静岡', lat: 34.971, lng: 138.3889 },
      { name: '名古屋', lat: 35.1815, lng: 136.9066 },
      { name: '京都', lat: 35.0116, lng: 135.7681 },
      { name: '大阪', lat: 34.6937, lng: 135.5023 },
      { name: '神戸', lat: 34.6901, lng: 135.1955 },
      { name: '広島', lat: 34.3853, lng: 132.4553 },
      { name: '岡山', lat: 34.6551, lng: 133.9195 },
      { name: '福岡', lat: 33.5902, lng: 130.4017 },
      { name: '北九州', lat: 33.883, lng: 130.8753 },
      { name: '熊本', lat: 32.8031, lng: 130.7079 },
      { name: '那覇', lat: 26.2125, lng: 127.6811 } // 主要都市に追加
    ];
    major.forEach(c => addStationAt(c.lat, c.lng, c.name, true, true));

    const extra = [
      { lat: 41.7687, lng: 140.7288 }, { lat: 40.822, lng: 140.7473 }, { lat: 39.7199, lng: 140.1024 },
      { lat: 37.9161, lng: 139.0364 }, { lat: 36.5613, lng: 136.6562 }, { lat: 36.6513, lng: 138.1809 },
      { lat: 35.4233, lng: 136.7607 }, { lat: 34.6851, lng: 135.8327 }, { lat: 34.226, lng: 135.1675 },
      { lat: 33.8416, lng: 132.7661 }, { lat: 33.5597, lng: 133.5311 }, { lat: 34.0703, lng: 134.5548 },
      { lat: 35.5039, lng: 134.2377 }, { lat: 35.4723, lng: 133.0505 }, { lat: 33.2396, lng: 131.6093 },
      { lat: 31.9077, lng: 131.4202 }, { lat: 31.5966, lng: 130.5571 }
    ];
    extra.forEach(p => addStationAt(p.lat, p.lng, '', false, false));
  }

  /* Lists */
  function refreshEpicList() {
    epicList.innerHTML = '';
    if (epicenters.length === 0) { epicList.textContent = '震源なし'; return; }
    epicenters.forEach((e) => {
      const row = document.createElement('div'); row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;margin:4px 0';
      const left = document.createElement('div'); left.innerHTML = `<b>M${e.M.toFixed(1)}</b> / ${e.depth.toFixed(1)}km @ ${e.lat.toFixed(2)},${e.lng.toFixed(2)} <span class="small">[${e.region}]</span>`;
      const right = document.createElement('div');
      const del = document.createElement('button'); del.className = 'ghost'; del.textContent = '削除';
      del.onclick = () => {
        if (e.pCircle) map.removeLayer(e.pCircle);
        if (e.sCircle) map.removeLayer(e.sCircle);
        if (e.tCircle) map.removeLayer(e.tCircle);
        map.removeLayer(e.marker);
        epicenters = epicenters.filter(x => x.id !== e.id);
        computePredictions(); refreshEpicList(); canvasDirty = true;
      };
      right.appendChild(del); row.appendChild(left); row.appendChild(right); epicList.appendChild(row);
    });
  }
  function refreshStList() {
    stList.innerHTML = '';
    if (stations.length === 0) { stList.textContent = '観測点なし'; return; }
    stations.forEach((s) => {
      const nm = s.name && s.name.trim() ? s.name : '(名称なし)';
      const predText = s.pred ? ` <span class="small">/ 予測:${s.pred.jma.sh} P:${s.pred.arrP.toFixed(1)}s S:${s.pred.arrS.toFixed(1)}s${(isFinite(s.pred.arrT) ? ` T:${s.pred.arrT.toFixed(1)}s` : '')}</span>` : '';
      const row = document.createElement('div'); row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;margin:4px 0';
      const left = document.createElement('div'); left.innerHTML = `<b>${nm}</b> <span class="small">@${s.lat.toFixed(3)},${s.lng.toFixed(3)}</span>${predText}`;
      const right = document.createElement('div');
      const del = document.createElement('button'); del.className = 'ghost'; del.textContent = '削除';
      del.onclick = () => {
        if (s.marker) map.removeLayer(s.marker);
        if (s.nameMarker) map.removeLayer(s.nameMarker);
        if (s.countdownMarker) map.removeLayer(s.countdownMarker);
        stations = stations.filter(x => x.id !== s.id); refreshStList(); computePredictions(); canvasDirty = true; updateCanvasAutoToggle();
      };
      right.appendChild(del); row.appendChild(left); row.appendChild(right); stList.appendChild(row);
    });
  }

  /* UI bindings */
  ringVis?.addEventListener('change', () => { ringsOn = (ringVis.value === 'on'); updateRingVisibility(); canvasDirty = true; });
  muteSel?.addEventListener('change', () => { if (!isMuted()) ensureAudio(); });
  modelPreset?.addEventListener('change', () => {
    if (modelPreset.value === 'dStrong') attIn.value = 0.005;
    else if (modelPreset.value === 'default') attIn.value = 0.0035;
    else attIn.value = 0.002;
    dAtt = parseFloat(attIn.value) || 0.002; computePredictions(); canvasDirty = true;
  });
  vpIn?.addEventListener('change', () => { vp = parseFloat(vpIn.value) || 6.0; computePredictions(); canvasDirty = true; });
  vsIn?.addEventListener('change', () => { vs = parseFloat(vsIn.value) || 3.5; computePredictions(); canvasDirty = true; });
  attIn?.addEventListener('input', () => { dAtt = parseFloat(attIn.value) || 0.002; computePredictions(); canvasDirty = true; });

  /* ------------------------------------------------------------
   * Simulation control（シミュ中は編集禁止）
   * ---------------------------------------------------------- */
  function getElapsed() { if (!running) return tOffset; if (!t0) return tOffset; return tOffset + (performance.now() - t0) / 1000 * speed; }

  runStart?.addEventListener('click', () => {
    if (epicenters.length === 0) { showOverlay('震源未設定', '震源を追加してからStartボタンを押してください。'); return; }
    vp = parseFloat(vpIn?.value) || 6.0; vs = parseFloat(vsIn?.value) || 3.5; dAtt = parseFloat(attIn?.value) || 0.002;
    running = true; t0 = performance.now(); tOffset = 0; speed = parseFloat(speedIn?.value || '1');
    modeSel.value = 'VIEW'; setModeUI();
    setupCircles();
    runStart.disabled = true; runStop.disabled = false; runPause.disabled = false; runResume.disabled = true;
    addLog('SYS', 'シミュレーション開始');

    // 震源の自動アナウンス
    unlockByUserGesture();
    const epicMsg = epicenters.map((e, idx) => `震源${idx + 1}、${e.region}、マグニチュード${e.M.toFixed(1)}、深さ${e.depth.toFixed(0)}キロ`).join('。');
    if (epicMsg) speakJP(epicMsg);

    updateCanvasAutoToggle();
  });
  runPause?.addEventListener('click', () => {
    if (!running) return;
    tOffset = getElapsed(); running = false;
    runPause.disabled = true; runResume.disabled = false; addLog('SYS', '一時停止');
  });
  runResume?.addEventListener('click', () => {
    if (running) return;
    t0 = performance.now(); running = true;
    runPause.disabled = false; runResume.disabled = true; addLog('SYS', '再開');
  });
  function stopSim(force = false) {
    running = false; t0 = null; tOffset = 0;
    epicenters.forEach(e => {
      if (e.pCircle) map.removeLayer(e.pCircle);
      if (e.sCircle) map.removeLayer(e.sCircle);
      if (e.tCircle) map.removeLayer(e.tCircle);
      e.pCircle = null; e.sCircle = null; e.tCircle = null;
    });
    stations.forEach(s => {
      s.pA = false; s.sA = false; s.tA = false; s.spoken = false;
      updateStationBadge(s, ''); updateCountdown(s, ''); s._lastBadge = ''; s._lastCountLabel = '';
    });
    if (!force) timeline.innerHTML = '停止中。Startで再開できます。';
    runStart.disabled = false; runStop.disabled = true; runPause.disabled = true; runResume.disabled = true;
    setModeUI();
    updateCanvasAutoToggle(); canvasDirty = true;
  }
  runStop?.addEventListener('click', () => stopSim());

  // Quick toolbar
  quickStart?.addEventListener('click', () => runStart.click());
  quickPause?.addEventListener('click', () => (running ? runPause : runResume).click());
  quickStop?.addEventListener('click', () => runStop.click());
  quickFit?.addEventListener('click', () => fitToAll());

  // Speed & jumps
  speedIn?.addEventListener('input', () => { speed = parseFloat(speedIn.value) || 1; updateHud(); canvasDirty = true; });
  function jumpBy(sec) {
    if (sec === 0) return;
    if (running) {
      const cur = getElapsed() + sec;
      tOffset = Math.max(0, cur);
      t0 = performance.now();
    } else {
      tOffset = Math.max(0, tOffset + sec);
    }
    updateTimeline(); canvasDirty = true;
  }
  jumpBack5?.addEventListener('click', () => jumpBy(-5));
  jumpFwd5?.addEventListener('click', () => jumpBy(+5));
  jumpFwd10?.addEventListener('click', () => jumpBy(+10));
  jumpToEnd?.addEventListener('click', () => {
    let maxT = 0;
    stations.forEach(s => {
      if (!s.pred) return;
      maxT = Math.max(maxT, s.pred.arrS || 0, (tsunamiOn && isFinite(s.pred.arrT)) ? s.pred.arrT : 0);
    });
    if (maxT <= 0) return;
    if (running) { tOffset = maxT + 0.5; t0 = performance.now(); } else { tOffset = maxT + 0.5; }
    updateTimeline(); canvasDirty = true;
  });

  /* ------------------------------------------------------------
   * Predictions compute（津波はベースン内のみ）
   * ---------------------------------------------------------- */
  function computePredictions() {
    stations.forEach(s => {
      let best = null;
      epicenters.forEach(e => {
        const at = arrivals(e, s);
        const pga = estimatePGA(e.M, Math.max(0.5, at.Rkm));
        const jma = pgaToJMA(pga);
        const pred = { arrP: at.tP, arrS: at.tS, pga, jma, color: colorForIdx(jma.idx) };
        if (!best || pred.jma.idx > best.jma.idx) best = pred;
      });
      if (best) {
        // 津波：同一ベースン内のみ到達可
        let minH = Infinity, any = false;
        epicenters.forEach(e => {
          if (!tsunamiOn) return;
          if (!tsunamiArrivable(e, s)) return;
          any = true;
          const h = getHkmCached(e, s);
          if (h < minH) minH = h;
        });
        best.arrT = (tsunamiOn && any && isFinite(minH) && cT > 0) ? (minH / cT) : Infinity;
      }
      s.pred = best; s.pA = false; s.sA = false; s.tA = false; s.spoken = false; s._lastBadge = ''; s._lastCountLabel = '';
      updateStationBadge(s, ''); updateCountdown(s, '');
    });
    updateHeatLayer();
    updateTimeline();
    markAllUnmoved();
    canvasDirty = true;
  }

  /* Rings */
  function setupCircles() {
    epicenters.forEach(e => {
      if (e.pCircle) map.removeLayer(e.pCircle);
      if (e.sCircle) map.removeLayer(e.sCircle);
      if (e.tCircle) map.removeLayer(e.tCircle);
    });
    epicenters.forEach(e => {
      e.pCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(80,170,255,0.5)', weight: 2, fill: false });
      e.sCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(255,100,100,0.4)', weight: 2, fill: false });
      e.tCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(80,255,200,0.75)', weight: 3, dashArray: '8 6', fill: false }).bringToFront();
      if (ringsOn) { e.pCircle.addTo(map); e.sCircle.addTo(map); }
      if (tsuRingsOn && tsunamiOn) e.tCircle.addTo(map);
    });
  }
  function updateRingVisibility() {
    epicenters.forEach(e => {
      if (e.pCircle) { if (ringsOn) e.pCircle.addTo(map); else map.removeLayer(e.pCircle); }
      if (e.sCircle) { if (ringsOn) e.sCircle.addTo(map); else map.removeLayer(e.sCircle); }
      if (e.tCircle) { if (tsuRingsOn && tsunamiOn) e.tCircle.addTo(map); else map.removeLayer(e.tCircle); }
    });
    canvasDirty = true;
  }

  /* Station UI */
  function updateStationBadge(st, text) { st.marker.setIcon(L.divIcon({ html: stationIconHTML(text), className: '', iconSize: [34, 34] })); }
  function updateCountdown(st, txt) { if (!st.countdownMarker) return; st.countdownMarker.setIcon(L.divIcon({ html: makeCountdownHTML(txt || ''), className: '', iconSize: null })); }

  /* Timeline */
  function updateTimeline() {
    if (!running) { timeline.innerHTML = '停止中。Startで再開できます。'; return; }
    const t = getElapsed();
    const rows = [];
    stations.forEach(s => {
      if (!s.pred) return;
      if (!s.pA) rows.push({ name: s.name || '(無名)', type: 'P', in: Math.max(0, s.pred.arrP - t) });
      if (!s.sA) rows.push({ name: s.name || '(無名)', type: 'S', in: Math.max(0, s.pred.arrS - t) });
      if (tsunamiOn && !s.tA && isFinite(s.pred.arrT)) rows.push({ name: s.name || '(無名)', type: 'T', in: Math.max(0, s.pred.arrT - t) });
    });
    rows.sort((a, b) => a.in - b.in);
    const html = rows.slice(0, 16).map(r => {
      const cls = r.type === 'P' ? 'timeline-p' : (r.type === 'S' ? 'timeline-s' : 'timeline-t');
      const sec = perfLite ? Math.round(r.in) : r.in.toFixed(1);
      return `<div>${sec}s → <b class="${cls}">${r.type}</b> @ ${r.name}</div>`;
    }).join('') || '全て到達済み';
    timeline.innerHTML = html;
  }

  /* Loop with throttling */
  function loop() {
    const now = performance.now();
    const shouldUpdate = (now - lastFrame) >= perfInterval;

    if (running && shouldUpdate) {
      lastFrame = now;
      const t = getElapsed();

      epicenters.forEach(e => {
        const rP = t * vp * 1000, rS = t * vs * 1000, rT = t * cT * 1000;
        if (e.pCircle) e.pCircle.setRadius(rP > 0 ? rP : 0);
        if (e.sCircle) e.sCircle.setRadius(rS > 0 ? rS : 0);
        if (e.tCircle) e.tCircle.setRadius(rT > 0 ? rT : 0);
      });

      stations.forEach(s => {
        if (!s.pred) return;
        // P 到達
        if (!s.pA) {
          const left = s.pred.arrP - t;
          const label = left > 0 ? `P ${(perfLite ? Math.ceil(left) : left.toFixed(1))}s` : '';
          if (s._lastCountLabel !== label) { updateCountdown(s, label); s._lastCountLabel = label; }
          if (left <= 0) { s.pA = true; addLog('P', `${s.name || '観測点'} P到達`); canvasDirty = true; }
        }
        // S 到達
        else if (!s.sA) {
          const left = s.pred.arrS - t;
          const label = left > 0 ? `S ${(perfLite ? Math.ceil(left) : left.toFixed(1))}s` : '';
          if (s._lastCountLabel !== label) { updateCountdown(s, label); s._lastCountLabel = label; }
          if (left <= 0) {
            s.sA = true;
            if (s._lastCountLabel !== '') { updateCountdown(s, ''); s._lastCountLabel = ''; }
            const newBadge = s.pred.jma.sh;
            if (s._lastBadge !== newBadge) { updateStationBadge(s, newBadge); s._lastBadge = newBadge; }
            addLog('S', `${s.name || '観測点'} 予想震度 ${s.pred.jma.sh}`);
            // 読み上げ設定
            const mode = ttsModeSel?.value || 'off';
            const idx = s.pred.jma.idx;
            const needSpeak = (mode === 'all') || (mode === 'major' && s.isMajor) || (mode === 'jma5' && idx >= 4);
            if (needSpeak && !s.spoken) {
              const nm = s.name && s.name.trim() ? s.name : '観測点';
              speakJP(`${nm}、予想震度、${s.pred.jma.sh}`);
              s.spoken = true;
            }
            canvasDirty = true;
          }
        }
        // 津波 到達
        if (tsunamiOn && !s.tA && isFinite(s.pred.arrT)) {
          const leftT = s.pred.arrT - t;
          if (leftT <= 0) {
            s.tA = true;
            if (!s.sA && s._lastBadge !== '🌊') { updateStationBadge(s, '🌊'); s._lastBadge = '🌊'; }
            addLog('T', `${s.name || '観測点'} 津波到達`);
            canvasDirty = true;
          }
        }

        // 最小残り表示
        const leftP = s.pA ? Infinity : (s.pred.arrP - t);
        const leftS = s.sA ? Infinity : (s.pred.arrS - t);
        const leftT = (!tsunamiOn || s.tA || !isFinite(s.pred.arrT)) ? Infinity : (s.pred.arrT - t);
        const minLeft = Math.min(leftP, leftS, leftT);
        if (isFinite(minLeft)) {
          const tag = (minLeft === leftP) ? 'P' : (minLeft === leftS) ? 'S' : 'T';
          const seconds = Math.max(0, minLeft);
          const coarse = perfLite ? Math.round(seconds).toString() : seconds.toFixed(1);
          const label = `${tag} ${coarse}s`;
          if (s._lastCountLabel !== label) { updateCountdown(s, label); s._lastCountLabel = label; }
        } else {
          if (s._lastCountLabel !== '') { updateCountdown(s, ''); s._lastCountLabel = ''; }
        }
      });

      if (now - lastTimelineUpdate > timelineInterval) {
        updateTimeline(); lastTimelineUpdate = now;
      }
    }

    if (canvasEnabled) drawStationsCanvas(); // Canvas描画
    updateFaultAnimation(); // Fault animation runner
    requestAnimationFrame(loop);
  }
  loop();

  /* Perf mode */
  function setPerfMode(on) {
    perfLite = !!on;
    const base = parseInt(perfIntervalIn?.value || '250', 10);
    perfInterval = Math.max(150, base);
    timelineInterval = perfLite ? Math.max(600, perfInterval * 3) : Math.max(250, Math.floor(perfInterval * 1.2));
    if (perfLite) {
      if (heatToggle && heatToggle.value !== 'off') { heatToggle.value = 'off'; updateHeatLayer(); }
      if (tsuRingVis && tsuRingVis.value !== 'off') { tsuRingVis.value = 'off'; tsuRingsOn = false; updateRingVisibility(); }
    }
    updateHud();
    updateCanvasAutoToggle();
    canvasDirty = true;
  }
  perfModeSel?.addEventListener('change', () => setPerfMode(perfModeSel.value === 'on'));
  perfIntervalIn?.addEventListener('change', () => setPerfMode(perfModeSel?.value === 'on'));

  /* Buttons (Add/Clear) */
  btnAddEpic?.addEventListener('click', () => {
    if (running) { showOverlay('編集中止', 'シミュレーション停止後に追加できます。'); return; }
    const c = map.getCenter(); addEpicAt(c.lat, c.lng);
  });
  btnAddStation?.addEventListener('click', () => {
    if (running) { showOverlay('編集中止', 'シミュレーション停止後に追加できます。'); return; }
    let name = stName?.value?.trim();
    let lat = parseFloat(stLat?.value), lng = parseFloat(stLon?.value);
    if (!isFinite(lat) || !isFinite(lng)) { const c = map.getCenter(); lat = c.lat; lng = c.lng; }
    addStationAt(lat, lng, name || `観測点${stations.length + 1}`, true, false);
    if (name) stName.value = '';
  });
  btnClearStations?.addEventListener('click', () => {
    if (running) { showOverlay('編集中止', 'シミュレーション停止後に削除できます。'); return; }
    stations.forEach(s => {
      if (s.marker) map.removeLayer(s.marker);
      if (s.nameMarker) map.removeLayer(s.nameMarker);
      if (s.countdownMarker) map.removeLayer(s.countdownMarker);
    });
    stations = []; refreshStList(); timeline.innerHTML = '観測点を全削除しました。'; computePredictions(); updateCanvasAutoToggle();
  });

  /* Filters / labels / search */
  stFilter?.addEventListener('change', applyStationFilter);
  function applyStationFilter() {
    const mode = stFilter.value; // 'all' | 'major' | 'custom'
    stations.forEach(s => {
      let vis = true;
      if (mode === 'major') vis = !!s.isMajor;
      if (vis && !s.visible) {
        s.visible = true;
        if (!canvasEnabled) {
          map.addLayer(s.marker); map.addLayer(s.countdownMarker);
          if (s.nameMarker && labelToggle.value === 'on') map.addLayer(s.nameMarker);
        }
      } else if (!vis && s.visible) {
        s.visible = false;
        if (map.hasLayer(s.marker)) map.removeLayer(s.marker);
        if (s.countdownMarker && map.hasLayer(s.countdownMarker)) map.removeLayer(s.countdownMarker);
        if (s.nameMarker && map.hasLayer(s.nameMarker)) map.removeLayer(s.nameMarker);
      }
    });
    updateCanvasAutoToggle();
    canvasDirty = true;
  }
  labelToggle?.addEventListener('change', () => {
    const on = (labelToggle.value === 'on');
    if (canvasEnabled) { canvasDirty = true; return; }
    stations.forEach(s => {
      if (!s.nameMarker) return;
      if (on && s.visible) map.addLayer(s.nameMarker);
      else map.removeLayer(s.nameMarker);
    });
  });
  stSearch?.addEventListener('input', () => {
    const q = (stSearch.value || '').trim().toLowerCase();
    stations.forEach(s => {
      const el = s.marker.getElement(); if (!el) return;
      const name = (s.name || '').toLowerCase();
      if (q && name.includes(q)) el.classList.add('highlight');
      else el.classList.remove('highlight');
    });
    canvasDirty = true;
  });

  /* Tsunami */
  function depthToSpeedKmPerS(h_m) { return Math.sqrt(9.81 * Math.max(100, h_m)) / 1000; }
  function ensureTsunamiCircles() {
    epicenters.forEach(e => {
      if (!e.tCircle) {
        e.tCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(80,255,200,0.75)', weight: 3, dashArray: '8 6', fill: false }).bringToFront();
        if (tsuRingsOn && tsunamiOn) e.tCircle.addTo(map);
      }
    });
  }
  tsuModeSel?.addEventListener('change', () => {
    tsunamiOn = (tsuModeSel.value === 'on');
    if (tsunamiOn) { cT = parseFloat(tsuSpeedIn.value) || cT; ensureTsunamiCircles(); }
    updateRingVisibility(); computePredictions(); updateTimeline(); canvasDirty = true;
  });
  tsuRingVis?.addEventListener('change', () => { tsuRingsOn = (tsuRingVis.value === 'on'); if (tsuRingsOn && tsunamiOn) ensureTsunamiCircles(); updateRingVisibility(); canvasDirty = true; });
  seaDepthIn?.addEventListener('change', () => {
    const h = Math.max(100, parseFloat(seaDepthIn.value) || 4000);
    cT = depthToSpeedKmPerS(h); tsuSpeedIn.value = cT.toFixed(3); computePredictions(); canvasDirty = true;
  });
  tsuSpeedIn?.addEventListener('change', () => {
    const v = parseFloat(tsuSpeedIn.value);
    if (isFinite(v) && v > 0) { cT = Math.max(0.05, Math.min(0.8, v)); computePredictions(); canvasDirty = true; }
  });

  /* Heat layer */
  function updateHeatLayer() {
    heatLayer.clearLayers();
    if (!heatToggle || heatToggle.value !== 'on') return;
    const opacity = parseFloat(heatOpacity?.value || '0.5');
    stations.forEach(s => {
      if (!s.pred || !s.visible) return;
      const idx = s.pred.jma.idx;
      const r = 12000 + idx * 6000;
      const col = s.pred.color || '#ff5a5a';
      const c = L.circle([s.lat, s.lng], { radius: r, color: col, weight: 1, fill: true, fillOpacity: opacity * 0.35, opacity: opacity * 0.85 });
      heatLayer.addLayer(c);
    });
  }
  heatToggle?.addEventListener('change', updateHeatLayer);
  heatOpacity?.addEventListener('input', updateHeatLayer);

  /* Fit to all */
  function fitToAll() {
    const pts = [];
    epicenters.forEach(e => pts.push([e.lat, e.lng]));
    stations.forEach(s => s.visible && pts.push([s.lat, s.lng]));
    if (pts.length) { const b = L.latLngBounds(pts); map.fitBounds(b.pad(0.2)); }
  }
  fitAllBtn?.addEventListener('click', fitToAll);

  /* Save / load / share */
  const LS_KEY = 'quakeSimState';
  function serializeState() {
    return {
      params: {
        vp: parseFloat(vpIn?.value) || 6, vs: parseFloat(vsIn?.value) || 3.5, att: parseFloat(attIn?.value) || 0.002,
        tsunamiOn, tsuRingsOn, cT, sea: parseFloat(seaDepthIn?.value) || 4000, theme: themeSel?.value || 'auto'
      },
      epicenters: epicenters.map(e => ({ lat: e.lat, lng: e.lng, M: e.M, depth: e.depth })),
      stations: stations.map(s => ({ lat: s.lat, lng: s.lng, name: s.name || '', isMajor: !!s.isMajor }))
    };
  }
  function restoreState(obj) {
    epicenters.forEach(e => { if (e.marker) map.removeLayer(e.marker); if (e.pCircle) map.removeLayer(e.pCircle); if (e.sCircle) map.removeLayer(e.sCircle); if (e.tCircle) map.removeLayer(e.tCircle); });
    epicenters = []; refreshEpicList();
    stations.forEach(s => { if (s.marker) map.removeLayer(s.marker); if (s.nameMarker) map.removeLayer(s.nameMarker); if (s.countdownMarker) map.removeLayer(s.countdownMarker); });
    stations = []; refreshStList();

    if (obj?.params) {
      vpIn.value = obj.params.vp ?? 6; vsIn.value = obj.params.vs ?? 3.5; attIn.value = obj.params.att ?? 0.002;
      seaDepthIn.value = obj.params.sea ?? 4000; cT = obj.params.cT ?? depthToSpeedKmPerS(parseFloat(seaDepthIn.value));
      tsuModeSel.value = obj.params.tsunamiOn ? 'on' : 'off';
      tsuRingVis.value = obj.params.tsuRingsOn ? 'on' : 'off';
      tsunamiOn = !!obj.params.tsunamiOn; tsuRingsOn = !!obj.params.tsuRingsOn;
      if (obj.params.theme) applyTheme(obj.params.theme), (themeSel.value = obj.params.theme);
    }
    (obj?.epicenters || []).forEach(e => { inMag.value = e.M; inDepth.value = e.depth; addEpicAt(e.lat, e.lng); });
    (obj?.stations || []).forEach(s => addStationAt(s.lat, s.lng, s.name || '', true, !!s.isMajor));
    fitToAll();
    computePredictions();
    updateCanvasAutoToggle();
  }
  saveLocal?.addEventListener('click', () => { try { localStorage.setItem(LS_KEY, JSON.stringify(serializeState())); showOverlay('保存', 'ブラウザに保存しました。'); } catch (e) { showOverlay('保存失敗', String(e?.message || e)); } });
  loadLocal?.addEventListener('click', () => { try { const raw = localStorage.getItem(LS_KEY); if (!raw) return showOverlay('読込', '保存データがありません。'); restoreState(JSON.parse(raw)); showOverlay('読込', '保存データを読み込みました。'); } catch (e) { showOverlay('読込失敗', String(e?.message || e)); } });
  delLocal?.addEventListener('click', () => { localStorage.removeItem(LS_KEY); showOverlay('削除', '保存データを削除しました。'); });

  exportJson?.addEventListener('click', () => {
    const data = JSON.stringify(serializeState(), null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'quakeSimState.json'; a.click();
    URL.revokeObjectURL(url);
  });
  importJson?.addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0]; if (!f) return;
    try {
      const text = await f.text();
      const obj = JSON.parse(text);
      restoreState(obj);
      showOverlay('インポート', 'ファイルを読み込みました。');
    } catch (e) { showOverlay('インポート失敗', String(e?.message || e)); }
    importJson.value = '';
  });
  copyPermalink?.addEventListener('click', async () => {
    try {
      const payload = encodeURIComponent(JSON.stringify(serializeState()));
      const url = location.origin + location.pathname + '#state=' + payload;
      await navigator.clipboard.writeText(url);
      showOverlay('共有URL', 'クリップボードにコピーしました。');
    } catch (e) { showOverlay('コピー失敗', String(e?.message || e)); }
  });
  window.addEventListener('load', () => {
    const m = location.hash.match(/#state=(.+)$/);
    if (m) { try { const obj = JSON.parse(decodeURIComponent(m[1])); setTimeout(() => restoreState(obj), 400); } catch { } }
  });

  /* ------------------------------------------------------------
   * Replay (簡易)
   * ---------------------------------------------------------- */
  const REPLAYS = {
    '20110311': { epicenters: [{ lat: 38.1, lng: 142.9, M: 9.0, depth: 24 }], stations: [] },
    '20160416': { epicenters: [{ lat: 32.754, lng: 130.763, M: 7.0, depth: 11 }], stations: [] },
    '20180906': { epicenters: [{ lat: 42.694, lng: 142.006, M: 6.7, depth: 37 }], stations: [] }
  };
  replayLoad?.addEventListener('click', () => {
    const v = replaySel.value;
    if (v === 'none') { showOverlay('リプレイ', 'プリセットを選択してください。'); return; }
    if (v !== 'custom') {
      applyAI(REPLAYS[v]);
      showOverlay('読み込み', 'プリセットを読み込みました。');
    } else {
      replayFile.click();
    }
  });
  replayFile?.addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0]; if (!f) return;
    try {
      const text = await f.text(); const obj = JSON.parse(text);
      applyAI(obj); showOverlay('読み込み', 'カスタムJSONを読み込みました。');
    } catch (e) { showOverlay('読み込み失敗', String(e?.message || e)); }
    replayFile.value = '';
  });
  replayPlay?.addEventListener('click', () => {
    if (epicenters.length === 0) { showOverlay('震源未設定', 'まず読み込みを行ってください。'); return; }
    runStart.click();
  });

  function applyAI(data) {
    try {
      let addedE = 0, addedS = 0;
      if (Array.isArray(data.epicenters)) {
        data.epicenters.forEach(ep => {
          if (!isFinite(ep.lat) || !isFinite(ep.lng)) return;
          addEpicAt(ep.lat, ep.lng);
          const e = epicenters[epicenters.length - 1];
          if (e) {
            if (isFinite(ep.M)) e.M = clampMag(parseFloat(ep.M));
            if (isFinite(ep.depth)) e.depth = clampDepth(parseFloat(ep.depth));
            e.region = nameEpicentralRegion(e.lat, e.lng);
            e.marker.closeTooltip(); e.marker.bindTooltip(`M${e.M.toFixed(1)} / ${e.depth.toFixed(1)}km\n${e.region}`);
            e.ai = true; addedE++;
          }
        });
      }
      if (Array.isArray(data.stations)) {
        data.stations.forEach(st => {
          if (!isFinite(st.lat) || !isFinite(st.lng)) return;
          addStationAt(st.lat, st.lng, st.name || '', true, !!st.isMajor);
          const s = stations[stations.length - 1];
          if (s) { s.ai = true; addedS++; }
        });
      }
      computePredictions(); fitToAll();
      showOverlay('AI適用', `震源${addedE}件・観測点${addedS}件を反映しました。`);
      updateCanvasAutoToggle();
    } catch (err) {
      showOverlay('AI適用エラー', String(err?.message || err || 'unknown'));
    }
  }

  /* ------------------------------------------------------------
   * Fault drawing & animation（専用モード）
   * ---------------------------------------------------------- */
  faultStart?.addEventListener('click', () => {
    faultDrawing = true; faultLineLatLngs = []; updateHud();
    if (faultPolyline) { map.removeLayer(faultPolyline); faultPolyline = null; }
    if (faultRunner) { map.removeLayer(faultRunner); faultRunner = null; }
    showOverlay('断層描画', '地図をクリックして頂点を追加。完了したら「終了」。');
  });
  faultFinish?.addEventListener('click', () => {
    faultDrawing = false; updateHud();
    if (faultLineLatLngs.length < 2) { showOverlay('断層ライン', '2点以上必要です。'); return; }
    if (faultPolyline) map.removeLayer(faultPolyline);
    faultPolyline = L.polyline(faultLineLatLngs, { color: '#ffcc66', weight: 4, opacity: 0.9 }).addTo(map).bringToFront();
    if (faultMode.value === 'animate') startFaultAnimation();
  });
  faultClear?.addEventListener('click', () => {
    faultDrawing = false; faultLineLatLngs = [];
    if (faultPolyline) { map.removeLayer(faultPolyline); faultPolyline = null; }
    if (faultRunner) { map.removeLayer(faultRunner); faultRunner = null; }
    faultAnim = null; canvasDirty = true;
  });
  function addFaultPoint(latlng) {
    faultLineLatLngs.push(latlng);
    if (faultPolyline) map.removeLayer(faultPolyline);
    faultPolyline = L.polyline(faultLineLatLngs, { color: '#ffcc66', weight: 3, opacity: 0.7, dashArray: '6 6' }).addTo(map).bringToFront();
    canvasDirty = true;
  }
  function startFaultAnimation() {
    if (faultLineLatLngs.length < 2) return;
    const pts = faultLineLatLngs.slice();
    const segCum = [0]; let total = 0;
    for (let i = 1; i < pts.length; i++) {
      total += hav(pts[i - 1].lat, pts[i - 1].lng, pts[i].lat, pts[i].lng) / 1000;
      segCum.push(total);
    }
    if (faultRunner) map.removeLayer(faultRunner);
    faultRunner = L.circle(pts[0], { radius: 25000, color: 'rgba(255,204,102,0.9)', weight: 2, fill: true, fillOpacity: 0.25 }).addTo(map).bringToFront();
    faultAnim = { running: true, start: performance.now(), distKm: 0, segCum, points: pts, speed: Math.max(0.1, Math.min(5, parseFloat(faultSpeed?.value) || 1.5)) };
  }
  function updateFaultAnimation() {
    if (!faultAnim || !faultAnim.running) return;
    const elapsed = (performance.now() - faultAnim.start) / 1000;
    const dist = elapsed * faultAnim.speed;
    const pts = faultAnim.points, seg = faultAnim.segCum;
    const total = seg[seg.length - 1];
    let d = Math.min(dist, total);
    let i = 1; while (i < seg.length && seg[i] < d) i++;
    const d1 = seg[i - 1], d2 = seg[i], frac = (d - d1) / Math.max(1e-6, (d2 - d1));
    const A = pts[i - 1], B = pts[i];
    const lat = A.lat + (B.lat - A.lat) * frac;
    const lng = A.lng + (B.lng - A.lng) * frac;
    if (faultRunner) faultRunner.setLatLng([lat, lng]);
    if (d >= total) { faultAnim.running = false; }
  }

  /* ------------------------------------------------------------
   * Screenshot（SVG化）
   * ---------------------------------------------------------- */
  btnShot?.addEventListener('click', exportSVG);
  function exportSVG() {
    if (!map) return;
    const size = map.getSize(); const W = size.x, H = size.y;
    const viewBox = `0 0 ${W} ${H}`;

    function pt(ll) { const p = map.latLngToContainerPoint(ll); return { x: p.x, y: p.y }; }
    function destPoint(lat, lng, dist, bearing) {
      const R = 6371e3, br = bearing * Math.PI / 180;
      const φ1 = lat * Math.PI / 180, λ1 = lng * Math.PI / 180, δ = dist / R;
      const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(br));
      const λ2 = λ1 + Math.atan2(Math.sin(br) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
      return { lat: φ2 * 180 / Math.PI, lng: ((λ2 * 180 / Math.PI + 540) % 360) - 180 };
    }
    function radiusPx(centerLatLng, meters) {
      const c = pt(centerLatLng);
      const east = destPoint(centerLatLng.lat, centerLatLng.lng, meters, 90);
      const e = pt(east);
      return Math.hypot(e.x - c.x, e.y - c.y);
    }

    const svg = [`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="${viewBox}" style="background:#000">`];
    svg.push(`<text x="12" y="22" fill="#9fb0b8" font-size="14">Overlay Snapshot (tiles省略)</text>`);

    if (faultPolyline) {
      const latlngs = faultLineLatLngs.map(pt);
      if (latlngs.length > 1) {
        const d = 'M ' + latlngs.map(p => `${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' L ');
        svg.push(`<path d="${d}" stroke="#ffcc66" stroke-width="3" fill="none" />`);
      }
    }

    epicenters.forEach(e => {
      const cpt = pt([e.lat, e.lng]);
      svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="6" fill="#ff6b6b" stroke="#d74f4f" stroke-width="2"/>`);
      if (e.pCircle && ringsOn) {
        const r = e.pCircle.getRadius(); if (r > 0) { const R = radiusPx({ lat: e.lat, lng: e.lng }, r); svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="${R.toFixed(1)}" fill="none" stroke="rgba(80,170,255,0.6)" stroke-width="2"/>`); }
      }
      if (e.sCircle && ringsOn) {
        const r = e.sCircle.getRadius(); if (r > 0) { const R = radiusPx({ lat: e.lat, lng: e.lng }, r); svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="${R.toFixed(1)}" fill="none" stroke="rgba(255,100,100,0.5)" stroke-width="2"/>`); }
      }
      if (e.tCircle && tsunamiOn && tsuRingsOn) {
        const r = e.tCircle.getRadius(); if (r > 0) { const R = radiusPx({ lat: e.lat, lng: e.lng }, r); svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="${R.toFixed(1)}" fill="none" stroke="rgba(80,255,200,0.8)" stroke-width="3" stroke-dasharray="8 6"/>`); }
      }
    });

    stations.forEach(s => {
      if (!s.visible) return;
      const p = pt([s.lat, s.lng]);
      svg.push(`<g transform="translate(${p.x.toFixed(1)},${p.y.toFixed(1)})">`);
      svg.push(`<circle r="16" fill="#57c7ff" stroke="rgba(0,0,0,0.2)" stroke-width="2"/>`);
      if (s._lastBadge) svg.push(`<text text-anchor="middle" y="4" font-size="12" font-weight="700" fill="#061015">${escapeXML(s._lastBadge)}</text>`);
      const nm = (s.name || '').trim();
      if (nm && labelToggle?.value === 'on') {
        const w = nm.length * 6 + 6;
        svg.push(`<rect x="-${w / 2}" y="-32" rx="6" ry="6" width="${w}" height="16" fill="rgba(0,0,0,0.6)"/>`);
        svg.push(`<text text-anchor="middle" y="-20" font-size="11" fill="#fff">${escapeXML(nm)}</text>`);
      }
      svg.push(`</g>`);
    });

    svg.push(`</svg>`);
    const out = svg.join('');
    const blob = new Blob([out], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'quake_overlay.svg'; a.click();
    URL.revokeObjectURL(url);
    function escapeXML(s) { return (s || '').replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&apos;' }[m])); }
  }

  /* ------------------------------------------------------------
   * Keyboard Shortcuts
   * ---------------------------------------------------------- */
  document.addEventListener('keydown', (e) => {
    const tag = (e.target || {}).tagName || '';
    if (/INPUT|SELECT|TEXTAREA/.test(tag)) return;
    if (e.code === 'Space') { e.preventDefault(); (running ? runPause : runResume).click(); return; }
    if (e.key === 's' || e.key === 'S') { runStop.click(); return; }
    if (e.key === 'f' || e.key === 'F') { fitToAll(); return; }
    if (e.key === '[') { jumpBy(-5); return; }
    if (e.key === ']') { jumpBy(+5); return; }
    if (e.key === '1') { perfModeSel.value = 'off'; setPerfMode(false); return; }
    if (e.key === '2') { perfModeSel.value = 'on'; setPerfMode(true); return; }
    if (e.key === 't' || e.key === 'T') {
      tsuRingVis.value = (tsuRingVis.value === 'on') ? 'off' : 'on';
      tsuRingsOn = (tsuRingVis.value === 'on'); updateRingVisibility();
      return;
    }
  });

  /* ------------------------------------------------------------
   * End
   * ---------------------------------------------------------- */

 /* ------------------------------------------------------------
   * Fault drawing / animation
   * ---------------------------------------------------------- */
  function kmBetween(a, b){ return hav(a.lat, a.lng, b.lat, b.lng) / 1000; }

  function resetFault(){
    faultDrawing = false;
    faultLineLatLngs = [];
    if (faultPolyline) { map.removeLayer(faultPolyline); faultPolyline = null; }
    if (faultRunner) { map.removeLayer(faultRunner); faultRunner = null; }
    faultAnim = null;
  }

  function addFaultPoint(latlng){
    if (!faultPolyline){
      faultPolyline = L.polyline([latlng], {
        color: 'rgba(255,180,60,0.9)',
        weight: 3,
        dashArray: '6 6'
      }).addTo(map);
    } else {
      const pts = faultPolyline.getLatLngs();
      pts.push(latlng);
      faultPolyline.setLatLngs(pts);
    }
    faultLineLatLngs.push(latlng);
  }

  function startFaultDraw(){
    resetFault();
    faultDrawing = true;
    addLog('SYS','断層描画を開始');
    hud.textContent = '断層描画: 地図をクリックして線分を追加（終了ボタンで確定）';
  }

  function finishFaultDraw(){
    if (!faultPolyline || faultLineLatLngs.length < 2){
      addLog('SYS','線分が不足しています');
      faultDrawing = false;
      return;
    }
    faultDrawing = false;
    addLog('SYS','断層描画を確定');
  }

  function polyTotalKm(pts){
    let s = 0;
    for (let i=1;i<pts.length;i++) s += kmBetween(pts[i-1], pts[i]);
    return s;
  }

  function subPolylineByDistKm(pts, dKm){
    if (dKm <= 0) return [pts[0]];
    let acc = 0;
    const out = [pts[0]];
    for (let i=1;i<pts.length;i++){
      const seg = kmBetween(pts[i-1], pts[i]);
      if (acc + seg >= dKm){
        const r = (dKm - acc) / seg;
        const lat = pts[i-1].lat + (pts[i].lat - pts[i-1].lat) * r;
        const lng = pts[i-1].lng + (pts[i].lng - pts[i-1].lng) * r;
        out.push(L.latLng(lat, lng));
        return out;
      } else {
        out.push(pts[i]);
        acc += seg;
      }
    }
    return out;
  }

  function startFaultAnim(){
    if (!faultPolyline || faultLineLatLngs.length < 2){
      addLog('SYS','まず「描画」で線を作成してください');
      return;
    }
    const pts = faultLineLatLngs.slice();
    const total = polyTotalKm(pts);
    if (total <= 0) return;

    const speedKmS = Math.max(0.1, Math.min(5, parseFloat(faultSpeed?.value || '1.5')));
    faultAnim = {
      running: true,
      startMs: performance.now(),
      lastMs: performance.now(),
      speed: speedKmS,
      totalKm: total,
      pts,
      distKm: 0
    };

    if (!faultRunner){
      faultRunner = L.polyline([pts[0]], {
        color: 'rgba(255,100,60,1)',
        weight: 4
      }).addTo(map);
    }
    addLog('SYS', `断層アニメ開始（${speedKmS}km/s）`);
  }

  function stopFaultAnim(){
    if (faultAnim?.running){
      faultAnim.running = false;
      addLog('SYS','断層アニメ停止');
    }
  }

  function updateFaultAnimation(){
    if (!faultAnim || !faultAnim.running) return;
    const now = performance.now();
    const dt = (now - faultAnim.lastMs) / 1000;
    faultAnim.lastMs = now;

    faultAnim.distKm += dt * faultAnim.speed;
    if (faultAnim.distKm >= faultAnim.totalKm){
      faultAnim.distKm = faultAnim.totalKm;
      faultAnim.running = false;
      addLog('SYS','断層アニメ完了');
    }

    const partial = subPolylineByDistKm(faultAnim.pts, faultAnim.distKm);
    if (faultRunner) faultRunner.setLatLngs(partial);
  }

  // Fault UI bindings
  faultStart?.addEventListener('click', () => {
    faultMode.value = 'draw';
    startFaultDraw();
  });
  faultFinish?.addEventListener('click', () => {
    if (faultMode.value === 'draw'){
      finishFaultDraw();
      // そのまま待機（必要なら animate を選ぶ）
    } else if (faultMode.value === 'animate'){
      stopFaultAnim();
    }
  });
  faultClear?.addEventListener('click', () => {
    resetFault();
    addLog('SYS','断層クリア');
  });
  faultMode?.addEventListener('change', () => {
    if (faultMode.value === 'draw'){
      startFaultDraw();
    } else if (faultMode.value === 'animate'){
      finishFaultDraw();
      startFaultAnim();
    } else {
      resetFault();
      hud.textContent = baseHudText();
    }
  });

  /* ------------------------------------------------------------
   * Presets / Replay
   * ---------------------------------------------------------- */
  function applyScenario(key){
    // 既存をクリアして代表的な震源＋推奨深さをセット
    if (running) stopSim();
    epicenters.forEach(e => { if (e.marker) map.removeLayer(e.marker); });
    epicenters = []; refreshEpicList();

    const presets = {
      nankai: { lat: 33.1, lng: 136.7, M: 8.2, depth: 20 },
      sagami: { lat: 34.9, lng: 139.3, M: 7.6, depth: 30 },
      japantrench: { lat: 38.5, lng: 143.0, M: 8.5, depth: 25 }
    };
    const p = presets[key];
    if (!p) return;

    inMag.value = p.M; inDepth.value = p.depth;
    addEpicAt(p.lat, p.lng);
    fitToAll();
  }
  applyPreset?.addEventListener('click', () => {
    const key = presetScenario?.value || 'none';
    if (key === 'none'){ showOverlay('プリセット','シナリオを選択してください。'); return; }
    applyScenario(key);
  });
  clearAll?.addEventListener('click', () => {
    if (running) stopSim();
    // epic
    epicenters.forEach(e => {
      if (e.pCircle) map.removeLayer(e.pCircle);
      if (e.sCircle) map.removeLayer(e.sCircle);
      if (e.tCircle) map.removeLayer(e.tCircle);
      map.removeLayer(e.marker);
    });
    epicenters = []; refreshEpicList();
    // stations
    stations.forEach(s => {
      if (s.marker) map.removeLayer(s.marker);
      if (s.nameMarker) map.removeLayer(s.nameMarker);
      if (s.countdownMarker) map.removeLayer(s.countdownMarker);
    });
    stations = []; refreshStList();
    heatLayer.clearLayers();
    H_CACHE.clear();
    timeline.innerHTML = '全てクリアしました。';
    updateCanvasAutoToggle();
  });

  const REPLAY_PRESETS = {
    '20110311': {
      title: '2011-03-11 東北地方太平洋沖',
      epicenters: [{lat: 38.103, lng: 142.861, M: 9.0, depth: 24}],
      stationsMajor: ['札幌','仙台','東京','横浜','千葉','さいたま','名古屋','京都','大阪','神戸','広島','福岡','那覇']
    },
    '20160416': {
      title: '2016-04-16 熊本',
      epicenters: [{lat: 32.75, lng: 130.76, M: 7.0, depth: 11}],
      stationsMajor: ['福岡','北九州','熊本','大分','広島','大阪','神戸','名古屋','東京']
    },
    '20180906': {
      title: '2018-09-06 胆振東部',
      epicenters: [{lat: 42.69, lng: 142.0, M: 6.7, depth: 37}],
      stationsMajor: ['札幌','仙台','東京','千葉','さいたま','名古屋','大阪','広島','福岡']
    }
  };

  function loadReplay(sel){
    const info = REPLAY_PRESETS[sel];
    if (!info){ showOverlay('リプレイ','プリセットを選択してください。'); return; }
    if (running) stopSim();

    // epic reset
    epicenters.forEach(e => { if (e.marker) map.removeLayer(e.marker); });
    epicenters = []; refreshEpicList();

    // keep stations but ensure majors exist
    const need = new Set(info.stationsMajor || []);
    const have = new Set(stations.filter(s => s.isMajor).map(s => s.name));
    need.forEach(n => {
      if (!have.has(n)){
        // ざっくりジオコード不要：主要都市は preload 済み。無ければ追加しない。
        // （ユーザーの既存主要都市で足りるはず）
      }
    });

    info.epicenters.forEach(ei => {
      inMag.value = ei.M; inDepth.value = ei.depth;
      addEpicAt(ei.lat, ei.lng);
    });

    computePredictions();
    fitToAll();
    showOverlay('読み込み', `${info.title} をロードしました。再生を押してください。`);
  }

  replayLoad?.addEventListener('click', () => {
    const key = replaySel?.value || 'none';
    if (key === 'none'){ showOverlay('読み込み','プリセットを選んでください。'); return; }
    if (key === 'custom'){
      replayFile?.click();
      return;
    }
    loadReplay(key);
  });

  replayPlay?.addEventListener('click', () => {
    if (!running) runStart?.click();
  });

  replayFile?.addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      restoreState(obj);
      showOverlay('カスタム','JSONを読み込みました。再生を押してください。');
    } catch(e){
      showOverlay('失敗', 'JSONの読み込みに失敗しました。');
    } finally {
      replayFile.value = '';
    }
  });

  /* ------------------------------------------------------------
   * Screenshot (best-effort)
   * ---------------------------------------------------------- */
  async function captureAndDownload(){
    // html2canvas があれば使う（外部読み込み前提 / タイルは CORS 必要）
    const target = document.querySelector('#mapWrap') || document.body;
    if (window.html2canvas){
      try{
        const canvas = await window.html2canvas(target, {useCORS: true, backgroundColor: null, scale: DPR});
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url; a.download = `QuakeSimX_${Date.now()}.png`; a.click();
        return;
      } catch(e){
        // fallthrough
      }
    }
    // フォールバック：状態JSONを添えて案内
    const data = JSON.stringify(serializeState());
    try{
      await navigator.clipboard.writeText(data);
      showOverlay('スクリーンショット',
        '外部ライブラリ（html2canvas等）未読込のため、画像キャプチャはブラウザの機能で取得してください。状態JSONをクリップボードにコピーしました。');
    } catch{
      showOverlay('スクリーンショット',
        '外部ライブラリ（html2canvas等）未読込のため、画像キャプチャはブラウザの機能で取得してください。');
    }
  }
  btnShot?.addEventListener('click', captureAndDownload);

  /* ------------------------------------------------------------
   * Keyboard shortcuts
   * ---------------------------------------------------------- */
  window.addEventListener('keydown', (e) => {
    // 入力系（テキスト/数値/セレクト）にフォーカス時は無視
    const tag = (document.activeElement?.tagName || '').toLowerCase();
    if (['input','textarea','select'].includes(tag)) return;

    if (e.code === 'Space'){ e.preventDefault(); (running ? runPause : runResume).click(); }
    else if (e.key.toLowerCase() === 's'){ runStop.click(); }
    else if (e.key.toLowerCase() === 'f'){ fitToAll(); }
    else if (e.key === '['){ jumpBy(-5); }
    else if (e.key === ']'){ jumpBy(+5); }
    else if (e.key === '1'){ perfModeSel.value = 'off'; setPerfMode(false); }
    else if (e.key === '2'){ perfModeSel.value = 'on'; setPerfMode(true); }
    else if (e.key.toLowerCase() === 't'){
      tsuRingVis.value = (tsuRingVis.value === 'on' ? 'off' : 'on');
      tsuRingsOn = (tsuRingVis.value === 'on');
      updateRingVisibility();
    }
  });

  /* ------------------------------------------------------------
   * Misc small hooks
   * ---------------------------------------------------------- */
  // タイル種変更時に CORS の有無でスクショ挙動が変わるため注意喚起
  tileSel?.addEventListener('change', () => {
    if (!window.html2canvas) return;
    // 軽いガイダンス
    if (tileSel.value === 'toner'){
      addLog('SYS','StamenタイルはCORSによりスクショが失敗する場合があります');
    }
  });

  // 主要 UI の初期案内
  window.addEventListener('load', () => {
    // 軽量モード初期値反映
    setPerfMode(perfModeSel?.value === 'on');
    updateHud();
  });

})(); // end IIFE

</script>
</body>
</html>
