<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>QuakeSimX  vβ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

<style>
:root{
  --bg:#070d14;
  --panel:#0d1620;
  --muted:#9fb0b8;
  --accent:#57c7ff;
  --accent-2:#61ffd6;
  --accent-warm:#ffcc66;
  --glass:rgba(255,255,255,0.06);
  --text:#eaf6ff;
  --text-weak:#cfe3ee;
  --border:rgba(255,255,255,0.08);
  --shadow:0 20px 60px rgba(0,0,0,0.45);
  --shadow-soft:0 10px 30px rgba(0,0,0,0.35);
  --backdrop:blur(10px);
}

body[data-theme="light"]{
  --bg:#f6fbff;
  --panel:#ffffff;
  --muted:#56727f;
  --accent:#1380c9;
  --accent-2:#00a595;
  --accent-warm:#b37a00;
  --glass:rgba(0,0,0,0.04);
  --text:#0e1a22;
  --text-weak:#324a57;
  --border:rgba(0,0,0,0.12);
  --shadow:0 16px 50px rgba(0,0,0,0.15);
  --shadow-soft:0 8px 24px rgba(0,0,0,0.12);
}

/* Auto theme respects OS */
@media (prefers-color-scheme: light){
  body[data-theme="auto"]{
    --bg:#f6fbff;
    --panel:#ffffff;
    --muted:#56727f;
    --accent:#1380c9;
    --accent-2:#00a595;
    --accent-warm:#b37a00;
    --glass:rgba(0,0,0,0.04);
    --text:#0e1a22;
    --text-weak:#324a57;
    --border:rgba(0,0,0,0.12);
    --shadow:0 16px 50px rgba(0,0,0,0.15);
    --shadow-soft:0 8px 24px rgba(0,0,0,0.12);
  }
}

/* --------------------------
   Base
--------------------------- */
*{ box-sizing:border-box }
html,body{ height:100%; margin:0; }
body{
  background:linear-gradient(180deg,#020305,var(--bg));
  color:var(--text);
  font-family:"Noto Sans JP",system-ui,Segoe UI,Roboto,Helvetica,Arial;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}
a{ color:var(--accent); text-decoration:none }
small,.small{ color:var(--muted); font-size:12px }
hr{ border:none; border-top:1px solid var(--border) }

button{
  cursor:pointer;
  border:none;
  border-radius:12px;
  padding:10px 14px;
  background:rgba(255,255,255,0.08);
  color:var(--text);
  transition:transform .06s ease,opacity .2s,background .2s,box-shadow .2s;
  box-shadow:0 0 0 0 transparent;
}
button:hover{ opacity:0.92 }
button:active{ transform:translateY(1px) scale(0.99) }
button:disabled{
  opacity:0.55; cursor:not-allowed;
}
button.primary{
  background:linear-gradient(180deg,var(--accent),color-mix(in oklab, var(--accent) 60%, #0b4a6a));
  color:#05131a; font-weight:800;
}
button.ghost{
  background:transparent;
  border:1px solid var(--border);
  color:var(--muted);
}

input[type="number"],
input[type="text"],
input[type="url"],
input[type="password"],
input[type="range"],
select{
  width:100%;
  padding:9px 10px;
  border-radius:10px;
  border:1px solid transparent;
  background:rgba(255,255,255,0.08);
  color:var(--text);
  transition:border-color .15s,background .15s,box-shadow .2s;
}
body[data-theme="light"] input[type="number"],
body[data-theme="light"] input[type="text"],
body[data-theme="light"] input[type="url"],
body[data-theme="light"] input[type="password"],
body[data-theme="light"] input[type="range"],
body[data-theme="light"] select{
  background:rgba(0,0,0,0.04);
}
input:focus,select:focus{
  outline:none; border-color:var(--accent);
  box-shadow:0 0 0 3px color-mix(in oklab, var(--accent) 25%, transparent);
  background:rgba(255,255,255,0.11);
}
label{ display:block; color:var(--muted); font-size:12px; margin:6px 0 4px }

/* Keyboard focus */
:focus-visible{
  outline:3px solid color-mix(in oklab, var(--accent) 70%, #fff);
  outline-offset:2px;
  border-radius:10px;
}

/* Utilities */
.mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace }
.hidden{ display:none !important }
.center{ display:flex; align-items:center; justify-content:center }
.nowrap{ white-space:nowrap }

/* --------------------------
   Top Bar
--------------------------- */
#topbar{
  position:sticky; top:0; z-index:1200;
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 14px;
  background:color-mix(in oklab, var(--panel) 70%, transparent);
  backdrop-filter:var(--backdrop);
  border-bottom:1px solid var(--border);
}
.brand{ display:flex; align-items:center; gap:10px }
.brand img{ width:28px; height:28px; border-radius:8px; box-shadow:var(--shadow-soft) }
.title{ font-size:16px; color:var(--text-weak) }
.top-actions{ display:flex; gap:8px; align-items:center }

/* --------------------------
   Title / Tutorial
--------------------------- */
#title{
  position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
  background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.75));
  z-index:1000;
}
#titleCard{
  width:min(1180px,96vw); height:min(760px,92vh);
  display:grid; grid-template-columns:1fr 380px;
  border-radius:16px; overflow:hidden; border:1px solid var(--border);
  background:linear-gradient(180deg,color-mix(in oklab, var(--panel) 90%, #000), var(--panel));
  box-shadow:var(--shadow);
}
#tLeft{ padding:26px; display:flex; gap:12px; flex-direction:column }
#tLeft h1{ margin:0; font-size:34px; color:var(--accent) }
#titleMap{
  flex:1; border-radius:12px; overflow:hidden; border:1px solid var(--border);
  background:#fff; display:flex; align-items:center; justify-content:center
}
.titleBtns{ display:flex; gap:10px; flex-wrap:wrap }
#btnStart{ font-size:18px; padding:12px 20px }

#tRight{ padding:18px; display:flex; flex-direction:column; gap:12px;
  background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent) }
.slide{
  background:var(--glass);
  padding:12px; border-radius:12px; border:1px solid var(--border);
  min-height:150px; display:flex; flex-direction:column; gap:8px
}
.slideNav{ display:flex; justify-content:space-between; align-items:center; margin-top:6px }
#slideIndex{ color:var(--muted) }

@media (max-width:980px){
  #titleCard{ grid-template-columns:1fr }
  #btnStart{ width:100% }
}

/* --------------------------
   Main Layout
--------------------------- */
#app{ height:calc(100vh - 56px); padding:10px }
.layout{ display:grid; grid-template-columns:1fr 410px; gap:12px; height:100% }
@media (max-width:1180px){ .layout{ grid-template-columns:1fr } #panel{ height:52vh } }

#mapWrap{ position:relative }
#map{
  width:100%; height:100%; min-height:56vh;
  border-radius:14px; overflow:hidden; box-shadow:var(--shadow-soft); z-index:1
}

/* Quick Floating Toolbar */
#floatToolbar{
  position:absolute; right:14px; bottom:14px; z-index:1100;
  display:flex; gap:8px; flex-wrap:wrap;
  background:color-mix(in oklab, var(--panel) 65%, transparent);
  border:1px solid var(--border);
  backdrop-filter:var(--backdrop);
  padding:8px; border-radius:14px; box-shadow:var(--shadow-soft)
}
#floatToolbar button{ min-width:40px }

/* --------------------------
   Right Panel (details/summary sections)
--------------------------- */
#panel{
  background:color-mix(in oklab, var(--panel) 85%, transparent);
  backdrop-filter:var(--backdrop);
  border-radius:14px; padding:10px;
  /* ★ 修正: 全体スクロールを有効化（以前は overflow:auto hidden で潰れていた） */
  overflow-y:auto; overflow-x:hidden;
  box-shadow:var(--shadow-soft);
  display:flex; flex-direction:column; gap:10px;
  scrollbar-gutter:stable both-edges;
  touch-action:pan-y;
}

/* Scrollbars (WebKit) */
#panel::-webkit-scrollbar{ width:10px }
#panel::-webkit-scrollbar-thumb{ background:rgba(255,255,255,0.18); border-radius:8px }
#panel::-webkit-scrollbar-track{ background:rgba(255,255,255,0.06); border-radius:8px }
body[data-theme="light"] #panel::-webkit-scrollbar-thumb{ background:rgba(0,0,0,0.18) }
body[data-theme="light"] #panel::-webkit-scrollbar-track{ background:rgba(0,0,0,0.06) }

/* Sections */
.section summary::-webkit-details-marker{ display:none }
.section summary{ cursor:default }
.section summary::before{ content:"●"; margin-right:6px; color:var(--muted) }
.section .content{
  padding:10px 12px; display:grid; gap:10px;
  max-height:260px; overflow:auto; padding-right:6px;
  background:color-mix(in oklab, var(--panel) 60%, transparent);
  border:1px solid var(--border); border-radius:12px;
}
.section .content::-webkit-scrollbar{ width:8px }
.section .content::-webkit-scrollbar-thumb{ background:rgba(255,255,255,0.2); border-radius:4px }
.section .content::-webkit-scrollbar-track{ background:rgba(255,255,255,0.05) }
body[data-theme="light"] .section .content::-webkit-scrollbar-thumb{ background:rgba(0,0,0,0.22) }
body[data-theme="light"] .section .content::-webkit-scrollbar-track{ background:rgba(0,0,0,0.08) }

.twoCol{ display:grid; grid-template-columns:1fr 1fr; gap:10px }
@media (max-width:560px){ .twoCol{ grid-template-columns:1fr } }

/* --------------------------
   HUD / Badges / Version
--------------------------- */
.hud,.badge{
  position:absolute; top:14px;
  background:color-mix(in oklab, var(--panel) 65%, transparent);
  padding:8px 10px; border-radius:12px; color:var(--text-weak);
  z-index:1200; border:1px solid var(--border); backdrop-filter:var(--backdrop)
}
.hud{ left:14px }
.badge{ right:14px }

.version{
  position:fixed; left:12px; bottom:12px; color:var(--muted);
  font-size:12px; z-index:1500
}

/* --------------------------
   Station / Epicenter Icons
--------------------------- */
.station-dot{
  display:flex; align-items:center; justify-content:center;
  width:34px; height:34px; border-radius:999px;
  background:var(--accent); color:#061015; font-weight:800; font-size:12px;
  border:2px solid rgba(0,0,0,0.2); box-shadow:0 2px 10px rgba(0,0,0,0.25)
}
.station-label{
  position:absolute; top:-18px; white-space:nowrap;
  background:color-mix(in oklab, var(--panel) 70%, transparent);
  color:var(--text); padding:2px 6px; border-radius:6px; font-size:11px;
  border:1px solid var(--border); backdrop-filter:var(--backdrop)
}
.countdown-pill{
  position:absolute; top:22px; white-space:nowrap;
  background:color-mix(in oklab, var(--panel) 70%, transparent);
  color:var(--text); padding:2px 6px; border-radius:6px; font-size:11px;
  border:1px solid var(--border); backdrop-filter:var(--backdrop)
}
.epi-dot{
  width:18px; height:18px; border-radius:999px; background:#ff6b6b;
  border:2px solid #d74f4f; box-shadow:0 2px 10px rgba(0,0,0,0.25)
}

/* Search highlight for station markers */
.highlight{
  outline:3px solid color-mix(in oklab, var(--accent) 60%, #fff);
  outline-offset:2px; border-radius:10px;
}

/* --------------------------
   Overlay / Alert dialog
--------------------------- */
#overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:5000 }
#obg{ position:absolute; inset:0; background:linear-gradient(180deg,rgba(0,0,0,0.55),rgba(0,0,0,0.85)); backdrop-filter:blur(2px) }
#op{
  position:relative; z-index:2;
  background:linear-gradient(180deg,color-mix(in oklab, var(--panel) 90%, #000), var(--panel));
  padding:20px; border-radius:12px; border:1px solid var(--border);
  width:min(820px,94vw); color:var(--text); box-shadow:var(--shadow)
}
#op h3{ margin:0 0 8px 0; color:var(--accent-warm) }

/* --------------------------
   Modals (Settings / Help / Spec)
--------------------------- */
.modal[hidden]{ display:none }
.modal{
  position:fixed; inset:0; z-index:5200; display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,0.45); backdrop-filter:blur(2px)
}
.modal-body{
  width:min(720px,94vw);
  background:color-mix(in oklab, var(--panel) 96%, #000);
  border:1px solid var(--border);
  border-radius:12px; padding:18px; box-shadow:var(--shadow)
}
.modal-body h3{ margin:0 0 10px; color:var(--accent) }

/* Settings form blocks */
.set-row{ display:block; margin:12px 0 }
.set-row label{ margin-bottom:6px }
.set-box{
  border:1px dashed var(--border);
  border-radius:10px;
  padding:10px 12px;
  background:color-mix(in oklab, var(--panel) 60%, transparent);
}

/* --------------------------
   Timeline & Logs
--------------------------- */
.timeline-p{ color:#5ab0ff; font-weight:700 }
.timeline-s{ color:#ff6b6b; font-weight:700 }
.timeline-t{ color:var(--accent-2); font-weight:700 }

.loglist{
  display:grid; gap:6px; max-height:240px; overflow:auto; padding-right:6px;
  border:1px dashed var(--border); border-radius:10px;
  background:color-mix(in oklab, var(--panel) 55%, transparent);
}
.loglist .item{ display:flex; gap:8px; align-items:center; font-size:12px; color:var(--text-weak) }
.loglist .tag{ font-weight:800; padding:2px 6px; border-radius:999px; border:1px solid var(--border) }
.loglist .tag.p{ background:rgba(90,176,255,0.12); color:#5ab0ff }
.loglist .tag.s{ background:rgba(255,107,107,0.12); color:#ff6b6b }
.loglist .tag.t{ background:rgba(97,255,214,0.12); color:var(--accent-2) }
.loglist .time{ opacity:0.75 }

/* --------------------------
   Leaflet tweaks (optional)
--------------------------- */
.leaflet-container{ background:transparent }
.leaflet-control-zoom{
  border:none !important;
  box-shadow:var(--shadow-soft) !important;
  overflow:hidden; border-radius:10px !important;
}
.leaflet-bar a, .leaflet-bar a:hover{
  background:color-mix(in oklab, var(--panel) 85%, transparent) !important;
  border-bottom:1px solid var(--border) !important;
  color:var(--text) !important;
}
.leaflet-bar a:hover{ filter:brightness(1.05) }

/* --------------------------
   Spec table styles (dynamic content)
--------------------------- */
#specContent table{
  width:100%; border-collapse:separate; border-spacing:0; font-size:14px
}
#specContent th, #specContent td{
  padding:10px 12px; border-top:1px solid var(--border)
}
#specContent th{
  text-align:left; color:var(--muted); width:38%;
}
#specContent tr:first-child th, #specContent tr:first-child td{ border-top:none }
#specContent tr:nth-child(odd) td{ background:color-mix(in oklab, var(--panel) 92%, transparent) }
#specContent tr td.bad{
  color:#ff6b6b; font-weight:700
}
#specContent tr td.good{
  color:var(--accent-2); font-weight:700
}

/* --------------------------
   Title ↔ App transitions
--------------------------- */
#title{ opacity:1; transition:opacity .25s ease }
#title[aria-hidden="true"], #title.hide{ opacity:0; pointer-events:none }

/* --------------------------
   Fine-tune buttons inside panels
--------------------------- */
.section .content button{ min-height:36px }
.section .content .ghost{ --tmp:1 }

/* --------------------------
   Tooltips (fallback)
--------------------------- */
[title]{ position:relative }
[title]::after{
  content:attr(title);
  position:absolute; left:50%; bottom:calc(100% + 8px);
  transform:translateX(-50%); white-space:nowrap;
  background:rgba(0,0,0,0.7); color:#fff; padding:4px 8px; border-radius:6px;
  font-size:11px; opacity:0; pointer-events:none; transition:opacity .12s;
}
[title]:hover::after{ opacity:1 }

/* --------------------------
   Animations (subtle)
--------------------------- */
@keyframes pulseDot{
  0%{ transform:scale(1) }
  50%{ transform:scale(1.06) }
  100%{ transform:scale(1) }
}
.station-dot{ animation:pulseDot 3.5s ease-in-out infinite }

/* --------------------------
   Print
--------------------------- */
@media print{
  #topbar, #panel, #floatToolbar, .hud, .badge, .version{ display:none !important }
  #map{ border-radius:0; box-shadow:none }
  body{ background:#fff; color:#000 }
}

</style>
</head>
<body>

  <!-- ===== Top Bar ===== -->
  <header id="topbar" role="banner" aria-label="アプリ上部バー">
    <div class="brand" aria-label="ブランド">
      <img id="brandLogo" alt="QuakeSimX ロゴ" src="https://dummyimage.com/40x40/57c7ff/05131a.png&text=Q" width="28" height="28" decoding="async" />
      <span class="title">QuakeSimX <b>vβ+</b></span>
    </div>
    <div class="top-actions" aria-label="トップバー操作">
      <button id="btnShot" class="ghost" type="button" title="スクリーンショット">スクリーンショット</button>
      <button id="btnHelp" class="ghost" type="button" title="ショートカット">ショートカット</button>
      <button id="btnSettings" class="ghost" type="button" title="設定">設定</button>
    </div>
  </header>

  <!-- ===== Title & Tutorial ===== -->
  <div id="title" role="dialog" aria-modal="true" aria-labelledby="appTitleHeading">
    <div id="titleCard">
      <div id="tLeft">
        <h1 id="appTitleHeading">QuakeSimX vβ+</h1>

        <div id="titleMap" aria-hidden="true">
          <svg viewBox="0 0 1600 1200" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-label="Intro Map">
            <rect width="100%" height="100%" fill="#ffffff"/>
            <path d="M980 140l40 40-20 60 40 60-10 60 50 50-30 70 60 40-30 80 40 70-60 20-50-20-40 30-70-10-40 30-60-10-60-50-70-10-50-40-40-60-30-80 20-70 40-60 60-40 90-20 80-30 70-10 60-10z" fill="#dfe8ef" stroke="#333" stroke-width="2"/>
            <text x="16" y="28" font-size="18" fill="#333">Japan (illustration)</text>
          </svg>
        </div>

        <div class="titleBtns">
          <button id="btnStart" class="primary" type="button">開始</button>
          <button id="btnTutorial" class="ghost" type="button">チュートリアル</button>
          <button id="btnAIMode" class="ghost" type="button">AI推論モード</button>
        </div>

        <div class="titleBtns">
          <button id="btnSpecMin" class="ghost" type="button">必要スペックを見る</button>
          <button id="btnSpecRec" class="ghost" type="button">推奨スペックを見る</button>
        </div>

        <small>スマホ：ダブルタップ=観測点、2本指=ズーム、1本指ドラッグ=パン（ビューモード推奨）。</small>
      </div>

      <div id="tRight" aria-label="チュートリアル">
        <div class="slide" data-s="0" aria-live="polite">
          <h3>1/3 はじめに</h3>
          <p class="small">ツール：震源（最大5）/観測点（青）を追加編集。ビュー：編集無効・ズーム/パンのみ。S到達で震度バッジ表示。</p>
          <div class="slideNav">
            <div class="small" id="slideIndex">スライド 1 / 3</div>
            <div>
              <button id="prevSlide" class="ghost" type="button" disabled>前へ</button>
              <button id="nextSlide" class="ghost" type="button">次へ</button>
            </div>
          </div>
        </div>

        <div class="slide" data-s="1" style="display:none" aria-live="polite">
          <h3>2/3 追加方法</h3>
          <p class="small">地図クリック=震源、<b>ダブルタップ/ダブルクリック=観測点</b>。名前はクリックで編集。</p>
          <div class="slideNav">
            <div class="small">スライド 2 / 3</div>
            <div>
              <button class="ghost" id="prev2" type="button">前へ</button>
              <button class="ghost" id="next2" type="button">次へ</button>
            </div>
          </div>
        </div>

        <div class="slide" data-s="2" style="display:none" aria-live="polite">
          <h3>3/3 地図と物理</h3>
          <p class="small">P/S速度や距離減衰 d を調整。地図透明度スライダで背景を薄くできます。</p>
          <div class="slideNav">
            <div class="small">スライド 3 / 3</div>
            <div>
              <button class="ghost" id="prev3" type="button">前へ</button>
              <button class="primary" id="startFromSlide" type="button">開始</button>
            </div>
          </div>
        </div>

        <small>AI推論は別チュートリアルに切替（外部API拡張ポイントあり）。</small>
      </div>
    </div>
  </div>

  <!-- ===== Main App ===== -->
  <div id="app" hidden>
    <div class="layout">
      <div id="mapWrap">
        <div id="map" aria-label="map" role="application"></div>

        <div class="hud" id="hud" aria-live="polite">ツール: クリック=震源 / ダブルタップ=観測点 / ドラッグ=移動</div>
        <div class="badge" id="modeBadge">Mode: TOOL</div>

        <div id="floatToolbar" role="group" aria-label="クイックコントロール">
          <button id="quickStart" class="primary" type="button" title="再生">▶</button>
          <button id="quickPause" class="ghost" type="button" title="一時停止/再開">⏸</button>
          <button id="quickStop" class="ghost" type="button" title="停止">■</button>
          <button id="quickFit" class="ghost" type="button" title="全体を表示">⤢</button>
        </div>
      </div>

      <aside id="panel" aria-label="コントロールパネル">
        <!-- シミュレーション / モード -->
        <details class="section" open>
          <summary>シミュレーション / モード</summary>
          <div class="content">
            <div class="twoCol">
              <button id="runStart" class="primary" type="button">Start</button>
              <div style="display:flex;gap:8px;flex-wrap:wrap">
                <button id="runPause" class="ghost" type="button" disabled>Pause</button>
                <button id="runResume" class="ghost" type="button" disabled>Resume</button>
                <button id="runStop" class="ghost" type="button" disabled>Stop</button>
              </div>
            </div>

            <div class="twoCol">
              <div>
                <label for="modeSel">モード</label>
                <select id="modeSel" aria-label="モード選択">
                  <option value="TOOL">ツール</option>
                  <option value="VIEW">ビュー</option>
                  <option value="AI">AI推論</option>
　　　　　　　　 <option value="EEW">(リアルタイムモード）EEW超低遅延</option>
                </select>
              </div>
              <div>
                <label for="speed">再生速度</label>
                <input id="speed" type="range" min="0.25" max="4" step="0.05" value="1" />
              </div>
            </div>

            <div class="twoCol">
              <div>
                <button id="fitAll" class="ghost" type="button" style="width:100%">全体を表示</button>
              </div>
              <div class="twoCol" style="grid-template-columns:repeat(4,1fr)">
                <button id="jumpBack5" class="ghost" type="button">-5s</button>
                <button id="jumpFwd5" class="ghost" type="button">+5s</button>
                <button id="jumpFwd10" class="ghost" type="button">+10s</button>
                <button id="jumpToEnd" class="ghost" type="button">End</button>
              </div>
            </div>

            <div class="twoCol" style="margin-top:6px">
              <div>
                <label for="perfMode">軽量モード</label>
                <select id="perfMode">
                  <option value="off" selected>オフ</option>
                  <option value="on">オン</option>
                </select>
              </div>
              <div>
                <label for="perfInterval">更新間隔 (ms)</label>
                <input id="perfInterval" type="number" min="100" step="50" value="250" />
                <small class="small">値を上げるほどCPU負荷↓（推奨 200〜400ms）</small>
              </div>
            </div>

            <small>開始時は自動でビューへ（編集無効／ズーム&パンのみ）。</small>
          </div>
        </details>

        <!-- サウンド / 読み上げ -->
        <details class="section">
          <summary>サウンド / 読み上げ</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="muteSel">ミュート</label>
                <select id="muteSel">
                  <option value="off">Off</option>
                  <option value="on">On</option>
                </select>
              </div>
              <div>
                <label for="vol">音量</label>
                <input id="vol" type="range" min="0" max="1" step="0.01" value="0.35" />
              </div>
            </div>
            <div class="twoCol">
              <div>
                <label for="ttsMode">TTS（予想震度の読み上げ）</label>
                <select id="ttsMode" aria-label="読み上げモード">
                  <!-- ★修正: 既定を「全て読み上げ」に変更 -->
                  <option value="off">オフ</option>
                  <option value="all" selected>全て読み上げ</option>
                  <option value="major">主要都市のみ</option>
                  <option value="jma5">5弱以上のみ</option>
                </select>
              </div>
              <div>
                <label for="ttsRate">話速</label>
                <input id="ttsRate" type="range" min="0.7" max="1.3" step="0.05" value="1.0" />
              </div>
            </div>
          </div>
        </details>

        <!-- 震源 -->
        <details class="section" open>
          <summary>震源（最大5）</summary>
          <div class="content">
            <div class="twoCol">
              <div><label for="inMag">M</label><input id="inMag" type="number" step="0.1" min="-2" max="12" value="6.5" /></div>
              <div><label for="inDepth">深さ(km)</label><input id="inDepth" type="number" step="0.1" min="0.1" max="750" value="30" /></div>
            </div>
            <button id="btnAddEpic" class="primary" type="button">地図中心に震源追加</button>
            <div id="epicList" class="small" style="color:var(--muted)">震源なし</div>
          </div>
<!-- 震源検索 UI -->
<div class="epi-search">
  <input id="epiSearch" type="search" placeholder="震源名で検索（例：岩手県沖, 東京湾, 日向灘）" list="epiRegions">
  <datalist id="epiRegions"></datalist>
  <button id="epiSearchBtn" type="button">追加</button>
</div>

        </details>

        <!-- 観測点 -->
        <details class="section" open>
          <summary>観測点（青丸）</summary>
          <div class="content">
            <div class="twoCol">
              <div><label for="stName">名前</label><input id="stName" type="text" placeholder="例: 東京" /></div>
              <div class="twoCol" style="grid-template-columns:1fr 1fr">
                <div><label for="stLat">緯度</label><input id="stLat" type="number" step="0.0001" placeholder="35.68" /></div>
                <div><label for="stLon">経度</label><input id="stLon" type="number" step="0.0001" placeholder="139.76" /></div>
              </div>
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btnAddStation" class="primary" type="button">地図中心に追加</button>
              <button id="btnClearStations" class="ghost" type="button">全削除</button>
            </div>

            <div class="twoCol" style="margin-top:4px">
              <div>
                <label for="stFilter">表示フィルタ</label>
                <select id="stFilter">
                  <option value="all" selected>すべて</option>
                  <option value="major">主要都市のみ</option>
                  <option value="custom">カスタム（手動）</option>
                </select>
              </div>
              <div>
                <label for="labelToggle">ラベル</label>
                <select id="labelToggle">
                  <option value="on" selected>表示</option>
                  <option value="off">非表示</option>
                </select>
              </div>
            </div>
            <div>
              <label for="stSearch">名称検索</label>
              <input id="stSearch" type="text" placeholder="部分一致でハイライト（オフライン）" />
            </div>

            <div id="stList" class="small" style="color:var(--muted)">観測点なし</div>
          </div>
        </details>

        <!-- 地図/表示 -->
        <details class="section">
          <summary>地図 / 表示</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="tileSel">ベースマップ</label>
                <select id="tileSel">
                  <option value="osm">OSM 標準</option>
                  <option value="bright">Carto Bright</option>
                  <option value="toner">Stamen Toner</option>
                </select>
              </div>
              <div>
                <label for="tileOpacity">地図透明度</label>
                <input id="tileOpacity" type="range" min="0.2" max="1" step="0.02" value="1" />
              </div>
            </div>
            <div class="twoCol">
              <div>
                <label for="ringVis">P/Sリング</label>
                <select id="ringVis">
                  <option value="on">表示</option>
                  <option value="off">非表示</option>
                </select>
              </div>
              <div>
                <label for="hudVis">HUD表示</label>
                <select id="hudVis">
                  <option value="on">表示</option>
                  <option value="off">非表示</option>
                </select>
              </div>
            </div>
          </div>
        </details>

        <!-- 物理スケール -->
        <details class="section">
          <summary>物理スケール / 推定</summary>
          <div class="content">
            <div class="twoCol">
              <div><label for="vp">P波速度 Vp (km/s)</label><input id="vp" type="number" step="0.1" value="6.0" /></div>
              <div><label for="vs">S波速度 Vs (km/s)</label><input id="vs" type="number" step="0.1" value="3.5" /></div>
            </div>
            <div class="twoCol">
              <div>
                <label for="att">距離減衰 d (1/km)</label>
                <input id="att" type="range" min="0" max="0.008" step="0.0001" value="0.002" />
                <small>log10PGA ≈ a+bM−c·log10R − d·R（R:斜距離km）</small>
              </div>
              <div>
                <label for="modelPreset">減衰プリセット</label>
                <select id="modelPreset">
                  <option value="dLight" selected>遠距離弱め（d=0.002）</option>
                  <option value="default">デフォルト（d=0.0035）</option>
                  <option value="dStrong">遠距離強め（d=0.005）</option>
                </select>
              </div>
            </div>
          </div>
        </details>

        <!-- 津波 -->
        <details class="section" open>
          <summary>津波（簡易・海域制約）</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="tsuMode">津波シミュレーション</label>
                <select id="tsuMode">
                  <option value="off" selected>オフ</option>
                  <option value="on">オン</option>
                </select>
              </div>
              <div>
                <label for="tsuRingVis">津波リング</label>
                <select id="tsuRingVis">
                  <option value="on">表示</option>
                  <option value="off" selected>非表示</option>
                </select>
              </div>
            </div>
            <div class="twoCol">
              <div>
                <label for="seaDepth">平均水深 h (m)</label>
                <input id="seaDepth" type="number" step="10" min="100" max="11000" value="4000" />
              </div>
              <div>
                <label for="tsuSpeed">津波速度 c (km/s)</label>
                <input id="tsuSpeed" type="number" step="0.001" min="0.05" max="0.40" value="0.198" />
                <small>c ≈ √(g·h)/1000（海域内伝播／内陸進入は制限）</small>
              </div>
            </div>
            <small>※海面・海域ネットワーク上での簡易伝播。内陸へは原則侵入しません（河川湾奥の特例は将来対応）。</small>
          </div>
        </details>

        <!-- 過去地震リプレイ -->
        <details class="section" open>
          <summary>過去地震リプレイ</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="replaySel">プリセット</label>
                <select id="replaySel">
                  <option value="none" selected>選択してください</option>
                  <option value="20110311">2011-03-11 東北地方太平洋沖（M9.0/24km）</option>
                  <option value="20160416">2016-04-16 熊本（M7.0/11km）</option>
                  <option value="20180906">2018-09-06 胆振東部（M6.7/37km）</option>
                  <option value="custom">カスタム（ファイル読込）</option>
                </select>
              </div>
              <div style="display:flex;gap:8px;align-items:flex-end">
                <button id="replayLoad" class="ghost" type="button">読み込み</button>
                <button id="replayPlay" class="primary" type="button">再生</button>
                <label class="ghost" style="padding:8px 12px;cursor:pointer">
                  JSON<input id="replayFile" type="file" accept="application/json" style="display:none" />
                </label>
              </div>
            </div>
            <small>プリセットを選んで「読み込み」→「再生」。カスタムは JSON で震源/観測点を読み込み可能。</small>
          </div>
        </details>

        <!-- 断層ライン -->
        <details class="section">
          <summary>断層ライン</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="faultMode">モード</label>
                <select id="faultMode">
                  <option value="off" selected>オフ</option>
                  <option value="draw">描画</option>
                  <option value="animate">アニメ再生</option>
                </select>
              </div>
              <div>
                <label for="faultSpeed">伝播速度 (km/s)</label>
                <input id="faultSpeed" type="number" step="0.1" min="0.1" max="5" value="1.5" />
              </div>
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="faultStart" class="ghost" type="button">描画開始</button>
              <button id="faultFinish" class="ghost" type="button">終了</button>
              <button id="faultClear" class="ghost" type="button">クリア</button>
            </div>
            <small>描画モード時は地図クリックで線分追加。ツールと競合しない専用入力モード。</small>
          </div>
        </details>

        <!-- プリセット / 保存・共有 -->
        <details class="section">
          <summary>プリセット / 保存・共有</summary>
          <div class="content">
            <div class="twoCol">
              <div>
                <label for="presetScenario">シナリオプリセット</label>
                <select id="presetScenario">
                  <option value="none" selected>選択してください</option>
                  <option value="nankai">南海トラフ（M8.2 / h=20km）</option>
                  <option value="sagami">相模トラフ（M7.6 / h=30km）</option>
                  <option value="japantrench">日本海溝（M8.5 / h=25km）</option>
                </select>
              </div>
              <div style="display:flex;gap:8px;align-items:flex-end">
                <button id="applyPreset" class="primary" type="button">適用</button>
                <button id="clearAll" class="ghost" type="button">全消去</button>
              </div>
            </div>

            <div class="twoCol">
              <div>
                <label>状態を保存（ブラウザ）</label>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button id="saveLocal" class="ghost" type="button">保存</button>
                  <button id="loadLocal" class="ghost" type="button">読込</button>
                  <button id="delLocal" class="ghost" type="button">削除</button>
                </div>
              </div>
              <div>
                <label>ファイル</label>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button id="exportJson" class="ghost" type="button">エクスポート</button>
                  <label class="ghost" style="padding:8px 12px;cursor:pointer">
                    インポート<input id="importJson" type="file" accept="application/json" style="display:none" />
                  </label>
                </div>
              </div>
            </div>

            <div class="twoCol">
              <div>
                <label>共有URL</label>
                <button id="copyPermalink" class="ghost" type="button">URLをコピー</button>
              </div>
              <div>
                <label for="heatToggle">ヒートマップ</label>
                <div style="display:flex;gap:8px;align-items:center">
                  <select id="heatToggle">
                    <option value="off" selected>オフ</option>
                    <option value="on">オン</option>
                  </select>
                  <input id="heatOpacity" type="range" min="0.1" max="1" step="0.05" value="0.5" />
                </div>
              </div>
            </div>
            <small>保存はブラウザ（localStorage）に「quakeSimState」として記録。共有URLは状態を埋め込みます（長くなることがあります）。</small>
          </div>
        </details>

<!-- ===== EEW ===== -->

<details class="section" open>
  <summary>EEW（超低遅延）</summary>
  <div class="content">
    <div class="twoCol">
      <div>
        <label for="eewTransport">トランスポート</label>
        <select id="eewTransport">
          <option value="ws" selected>WebSocket</option>
          <option value="poll">HTTP(ロング/ポーリング)</option>
          <option value="demo">デモ（疑似EEW）</option>
        </select>
      </div>
      <div>
        <label for="eewInterval">ポーリング間隔(ms)</label>
        <input id="eewInterval" type="number" min="500" step="500" value="2000" />
      </div>
    </div>

    <div>
      <label for="eewUrl">EEWフィードURL（WS か HTTP）</label>
      <input id="eewUrl" type="url" placeholder="例: wss://example.com/eew / https://example.com/eew.json" />
    </div>

    <div class="twoCol">
      <div>
        <label for="eewAutostart">初報で自動再生</label>
        <select id="eewAutostart">
          <option value="on" selected>オン</option>
          <option value="off">オフ</option>
        </select>
      </div>
      <div>
        <label for="eewHold">確定後の保持(s)</label>
        <input id="eewHold" type="number" min="0" max="600" value="45" />
      </div>
    </div>

    <div class="twoCol">
      <div>
        <label for="eewAlpha">位置/規模スムージング(α)</label>
        <input id="eewAlpha" type="range" min="0.05" max="0.9" step="0.05" value="0.35" />
        <small>更新時：new = α·観測 + (1-α)·現在</small>
      </div>
      <div>
        <label for="eewMax">同時案件の最大数</label>
        <input id="eewMax" type="number" min="1" max="20" value="6" />
      </div>
    </div>

    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="eewConnect" class="primary" type="button">接続</button>
      <button id="eewDisconnect" class="ghost" type="button" disabled>切断</button>
      <button id="eewDemo1" class="ghost" type="button">デモ（単一）</button>
      <button id="eewDemoStorm" class="ghost" type="button">デモ（連続）</button>
    </div>

    <small class="small">
      形式：1メッセージ=1JSON または 配列。フィールド名は柔軟に解釈します（id/eewId, serial/report, lat/latitude, lon/lng/longitude, depth/dep, mag/M, time/originTime, status/final/cancel など）。<br>
      CORS は配信側で許可を。キャンセルの際は status: "Cancel" でも可。
    </small>
  </div>
</details>

        <!-- 到達タイムライン -->
        <details class="section" open>
          <summary>到達タイムライン（予測）</summary>
          <div class="content" id="timeline">開始すると直近到達順に表示</div>
        </details>

        <!-- アラートログ -->
        <details class="section" open>
          <summary>アラートログ</summary>
          <div class="content">
            <div id="alertLog" class="loglist small" aria-live="polite">まだログがありません。</div>
            <div style="display:flex;gap:8px;justify-content:flex-end">
              <button id="clearLog" class="ghost" type="button">ログをクリア</button>
            </div>
          </div>
        </details>
      </aside>
    </div>
  </div>

  <!-- ===== Overlay / Toast ===== -->
  <div id="overlay" aria-hidden="true">
    <div id="obg"></div>
    <div id="op" role="alertdialog" aria-labelledby="ovTitle" aria-describedby="ovMsg">
      <h3 id="ovTitle">通知</h3>
      <p id="ovMsg">メッセージ</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="ovOk" class="primary" type="button">OK</button>
        <button id="ovClose" class="ghost" type="button">閉じる</button>
      </div>
    </div>
  </div>

  <!-- ===== Settings Modal ===== -->
  <div id="settingsModal" class="modal" hidden aria-hidden="true" aria-label="設定">
    <div class="modal-body" role="dialog" aria-modal="true">
      <h3>設定</h3>

      <section class="set-row">
        <label for="themeSel">テーマ</label>
        <select id="themeSel">
          <option value="auto" selected>自動</option>
          <option value="dark">ダーク</option>
          <option value="light">ライト</option>
        </select>
      </section>

      <section class="set-row">
        <div class="twoCol">
          <div>
            <label for="settingsVol">音量</label>
            <input id="settingsVol" type="range" min="0" max="1" step="0.01" value="0.35" />
          </div>
          <div>
            <label for="voiceSel">TTS音声</label>
            <select id="voiceSel" aria-label="音声選択">
              <option value="auto" selected>自動（推奨）</option>
              <option value="voiceA">音声A</option>
              <option value="voiceB">音声B</option>
            </select>
          </div>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="btnTtsTest" class="ghost" type="button" title="『テストです。』を読み上げ">TTSテスト</button>
        </div>
      </section>

      <section class="set-row">
        <label for="zoomSensitivity">キャンバス内ズーム感度</label>
        <input id="zoomSensitivity" type="range" min="0.5" max="2" step="0.05" value="1" />
      </section>

      <section class="set-row">
        <details>
          <summary>震度表示について</summary>
          <div class="set-box">
            <p class="small">震度はPGAの簡易推定からJMA風スケールにマッピング。物理スケールで減衰パラメータを調整可。</p>
          </div>
        </details>
        <details>
          <summary>出典等</summary>
          <div class="set-box">
            <ul class="small">
              <li>地図タイル：© OpenStreetMap / Carto / Stamen</li>
              <li>震央地名：気象庁「地震情報で用いる震央地名」・JMA Region ポリゴン</li>
            </ul>
          </div>
        </details>
      </section>

      <section class="set-row">
        <label>プラン</label>
        <div class="set-box">QuakeSimX - Free Plan</div>
      </section>

      <section class="set-row">
        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
          <button id="btnBackToTitle" class="ghost" type="button" title="タイトルへ戻る">タイトルに戻る</button>
          <button id="btnForceQuit" class="ghost" type="button" title="アプリを強制終了">サイトの強制終了</button>
          <button id="settingsClose" class="primary" type="button">閉じる</button>
        </div>
        <small class="small">※ ロゴ画像の変更はスクリプトによる差し替えのみ対応。設定画面からの変更はできません。</small>
      </section>
    </div>
  </div>

  <!-- ===== Help / Shortcuts ===== -->
  <div id="helpModal" class="modal" hidden aria-hidden="true">
    <div class="modal-body" role="dialog" aria-modal="true">
      <h3>ショートカット</h3>
      <ul class="small">
        <li><b>Space</b>: 再生/一時停止</li>
        <li><b>S</b>: 停止</li>
        <li><b>F</b>: 全体表示</li>
        <li><b>[ / ]</b>: -5s / +5s</li>
        <li><b>1/2</b>: 軽量モード OFF/ON</li>
        <li><b>T</b>: 津波リング表示切替</li>
        <li><b>Esc</b>: 設定を開く / 閉じる</li>
      </ul>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="helpClose" class="primary" type="button">OK</button>
      </div>
    </div>
  </div>

  <!-- ===== Spec Modals ===== -->
  <div id="specModal" class="modal" hidden aria-hidden="true">
    <div class="modal-body" role="dialog" aria-modal="true">
      <h3 id="specTitle">システム要件</h3>
      <div id="specContent" class="small"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="specClose" class="primary" type="button">OK</button>
      </div>
    </div>
  </div>

  <div class="version" aria-hidden="true">vβ+ 完全版</div>

<script>
/* =========================================================================
   QuakeSimX vβ+ — 巨大ワンファイル JavaScript
   - チュートリアル遷移修正
   - すべてのモードで軽量化（Canvas描画）有効
   - 震源：JMA震央地名（代表区分を多数内蔵／Tochigi北・南、オホーツク海等を明確化）
   - 津波：海域ベースン内のみ伝播（太平洋⇄日本海・オホーツク海の跨ぎを禁止／内陸抑制）
   - シミュ中の編集ロック（停止時のみ編集可能）
   - 断層描画：入力専用モードでツール競合解消
   - TTS：GitHub Pagesでも読み上げ安定（ユーザー操作後に初期化／voiceschanged対応）
   - 設定：Escで開閉／ロゴ変更はスクリプトAPIのみ（UIからは不可）
   - 主要都市に「那覇」を追加済み
   - 震源自動アナウンス（開始時）
   ======================================================================= */

(() => {
  'use strict';

  /* ------------------------------------------------------------
   * DOM Refs（HTMLに存在する要素のみ参照）
   * ---------------------------------------------------------- */
  const $ = (id) => document.getElementById(id);

  // Topbar
  const brandLogo = $('brandLogo');
  const btnShot = $('btnShot');
  const btnHelp = $('btnHelp');
  const btnSettings = $('btnSettings');

  // Title / Tutorial
  const title = $('title');
  const titleCard = $('titleCard');
  const app = $('app');
  const btnStart = $('btnStart');
  const btnTutorial = $('btnTutorial');
  const btnAIMode = $('btnAIMode');
  const btnSpecMin = $('btnSpecMin');
  const btnSpecRec = $('btnSpecRec');

  // Tutorial slides
  const slideEls = [...document.querySelectorAll('#tRight .slide')];
  const slideIndex = $('slideIndex');
  const prevSlide = $('prevSlide');
  const nextSlide = $('nextSlide');
  const prev2 = $('prev2');
  const next2 = $('next2');
  const prev3 = $('prev3');
  const startFromSlide = $('startFromSlide');

  // Map & Toolbar
  const mapEl = $('map');
  const quickStart = $('quickStart');
  const quickPause = $('quickPause');
  const quickStop = $('quickStop');
  const quickFit = $('quickFit');

  // Main controls
  const runStart = $('runStart');
  const runPause = $('runPause');
  const runResume = $('runResume');
  const runStop = $('runStop');
  const modeSel = $('modeSel');
  const speedIn = $('speed');
  const fitAllBtn = $('fitAll');
  const jumpBack5 = $('jumpBack5');
  const jumpFwd5 = $('jumpFwd5');
  const jumpFwd10 = $('jumpFwd10');
  const jumpToEnd = $('jumpToEnd');
  const perfModeSel = $('perfMode');
  const perfIntervalIn = $('perfInterval');

  // Sources / Stations
  const inMag = $('inMag');
  const inDepth = $('inDepth');
  const btnAddEpic = $('btnAddEpic');
  const epicList = $('epicList');
  const stName = $('stName');
  const stLat = $('stLat');
  const stLon = $('stLon');
  const btnAddStation = $('btnAddStation');
  const btnClearStations = $('btnClearStations');
  const stFilter = $('stFilter');
  const labelToggle = $('labelToggle');
  const stSearch = $('stSearch');
  const stList = $('stList');

  // Map display
  const tileSel = $('tileSel');
  const tileOpacity = $('tileOpacity');
  const ringVis = $('ringVis');
  const hudVis = $('hudVis');

  // Physics
  const vpIn = $('vp');
  const vsIn = $('vs');
  const attIn = $('att');
  const modelPreset = $('modelPreset');

  // Tsunami
  const tsuModeSel = $('tsuMode');
  const tsuRingVis = $('tsuRingVis');
  const seaDepthIn = $('seaDepth');
  const tsuSpeedIn = $('tsuSpeed');

  // Replay
  const replaySel = $('replaySel');
  const replayLoad = $('replayLoad');
  const replayPlay = $('replayPlay');
  const replayFile = $('replayFile');

  // Faults
  const faultMode = $('faultMode');
  const faultSpeed = $('faultSpeed');
  const faultStart = $('faultStart');
  const faultFinish = $('faultFinish');
  const faultClear = $('faultClear');

  // Preset/save/share
  const presetScenario = $('presetScenario');
  const applyPreset = $('applyPreset');
  const clearAll = $('clearAll');
  const saveLocal = $('saveLocal');
  const loadLocal = $('loadLocal');
  const delLocal = $('delLocal');
  const exportJson = $('exportJson');
  const importJson = $('importJson');
  const copyPermalink = $('copyPermalink');
  const heatToggle = $('heatToggle');
  const heatOpacity = $('heatOpacity');

  // HUD / overlay / timeline
  const hud = $('hud');
  const modeBadge = $('modeBadge');
  const timeline = $('timeline');
  const overlay = $('overlay');
  const ovTitle = $('ovTitle');
  const ovMsg = $('ovMsg');
  const ovOk = $('ovOk');
  const ovClose = $('ovClose');

  // Audio / TTS
  const muteSel = $('muteSel');
  const volIn = $('vol');
  const ttsModeSel = $('ttsMode');
  const ttsRate = $('ttsRate');

  // Settings modal
  const settingsModal = $('settingsModal');
  const themeSel = $('themeSel');
  const settingsVol = $('settingsVol');
  const voiceSel = $('voiceSel');
  const btnTtsTest = $('btnTtsTest');
  const zoomSensitivity = $('zoomSensitivity');
  const btnBackToTitle = $('btnBackToTitle');
  const btnForceQuit = $('btnForceQuit');
  const settingsClose = $('settingsClose');

  // Help modal
  const helpModal = $('helpModal');
  const helpClose = $('helpClose');

  // Spec modal
  const specModal = $('specModal');
  const specTitle = $('specTitle');
  const specContent = $('specContent');
  const specClose = $('specClose');

  // Version
  const versionEl = document.querySelector('.version');

  /* ------------------------------------------------------------
   * Overlay Helper
   * ---------------------------------------------------------- */
  function showOverlay(title, message, onOk) {
    ovTitle.textContent = title;
    ovMsg.textContent = message;
    overlay.style.display = 'flex';
    ovOk.onclick = () => {
      if (onOk) try { onOk(); } catch (_) {}
      hideOverlay();
    };
    ovClose.onclick = hideOverlay;
  }
  function hideOverlay() { overlay.style.display = 'none'; }

  /* ------------------------------------------------------------
   * Global State
   * ---------------------------------------------------------- */
  let map, tiles = null;
  let epicenters = []; // {id,lat,lng,M,depth,marker,pCircle,sCircle,tCircle,_moved,region}
  let stations = [];   // {id,lat,lng,name,marker,nameMarker,countdownMarker,pA,sA,tA,pred,isMajor,spoken,_moved,_lastBadge,_lastCountLabel,visible}
  let running = false, t0 = null, tOffset = 0, speed = 1;
  let vp = 6.0, vs = 3.5, dAtt = 0.0041; // 既定d=0.0041（遠距離弱め）
  let ringsOn = true;

  // Tsunami
  let tsunamiOn = false, tsuRingsOn = false;
  let cT = 0.198; // km/s

  // Heat
  let heatLayer = L.layerGroup();

  // Faults
  let faultDrawing = false;
  let faultLineLatLngs = [];
  let faultPolyline = null;
  let faultRunner = null;
  let faultAnim = null; // {running,start,distKm,segCum,points,speed}

  // Perf
  let perfLite = false;
  let perfInterval = 250;
  let timelineInterval = 500;
  let lastFrame = 0, lastTimelineUpdate = 0;

  // Canvas overlay for stations
  let overlayCanvas = null, overlayCtx = null, canvasEnabled = false, canvasDirty = true;
  const AUTO_CANVAS_THRESHOLD = 120;
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

  // Theme
  const THEME_KEY = 'quakeSimTheme';

  // Audio/TTS
  let audioCtx = null, masterGain = null;
  let userActivated = false; // GitHub Pages等の自動再生制限対策
  let ttsVoices = [];
  let selectedVoiceName = 'auto';

  // Logo (script-only)
  function setBrandLogo(src) {
    if (!brandLogo) return;
    if (typeof src === 'string' && src.trim()) brandLogo.src = src.trim();
  }

  // Public API（UIからは変更不可、スクリプトのみ）
  window.QuakeSimX = Object.freeze({
    setLogo: setBrandLogo
  });

  /* ------------------------------------------------------------
   * Tutorial Slides — 修正：確実に遷移
   * ---------------------------------------------------------- */
  let sIdx = 0;
  function showSlide(i) {
    sIdx = Math.max(0, Math.min(2, i | 0));
    slideEls.forEach((el, idx) => el.style.display = (idx === sIdx) ? 'block' : 'none');
    if (slideIndex) slideIndex.textContent = `スライド ${sIdx + 1} / 3`;
    if (prevSlide) prevSlide.disabled = (sIdx === 0);
    if (nextSlide) nextSlide.disabled = (sIdx === 2);
  }

  prevSlide?.addEventListener('click', () => showSlide(sIdx - 1));
  nextSlide?.addEventListener('click', () => showSlide(sIdx + 1));
  prev2?.addEventListener('click', () => showSlide(0));
  next2?.addEventListener('click', () => showSlide(2));
  prev3?.addEventListener('click', () => showSlide(1));
  startFromSlide?.addEventListener('click', startApp);
  showSlide(0);

  btnStart?.addEventListener('click', startApp);
  btnTutorial?.addEventListener('click', () => showOverlay('チュートリアル', '右側の「前へ／次へ」で1/3→3/3を移動できます。'));
  btnAIMode?.addEventListener('click', () => showOverlay('AI推論モード', '右パネル「AI推論」でAPIを設定して取得できます。'));

  /* ------------------------------------------------------------
   * Settings Modal（Escで開閉）
   * ---------------------------------------------------------- */
  function openSettings() { settingsModal.hidden = false; settingsModal.setAttribute('aria-hidden', 'false'); }
  function closeSettings() { settingsModal.hidden = true; settingsModal.setAttribute('aria-hidden', 'true'); }

  btnSettings?.addEventListener('click', openSettings);
  settingsClose?.addEventListener('click', closeSettings);
  btnBackToTitle?.addEventListener('click', () => {
    // タイトルへ戻る（軽いフェード）
    app.setAttribute('hidden', '');
    title.classList.remove('hide');
    title.setAttribute('aria-hidden', 'false');
    title.style.display = 'flex';
    closeSettings();
  });
  btnForceQuit?.addEventListener('click', () => {
    // 強制終了：シミュ停止＋UIロック
    stopSim(true);
    document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font:16px system-ui">QuakeSimX を終了しました。ページを再読み込みしてください。</div>';
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (settingsModal.hidden) openSettings(); else closeSettings();
    }
  });

  // Help modal
  btnHelp?.addEventListener('click', () => { helpModal.hidden = false; helpModal.setAttribute('aria-hidden', 'false'); });
  helpClose?.addEventListener('click', () => { helpModal.hidden = true; helpModal.setAttribute('aria-hidden', 'true'); });
  helpModal?.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.hidden = true; });

  // Specs modal
  const SPEC_MIN = {
    title: '必要スペック',
    rows: [
      ['OS', 'Windows 10 / macOS 11 / iOS 16 / Android 11'],
      ['CPU', 'デュアルコア 2GHz 以上'],
      ['RAM', '8GB 以上'],
      ['GPU', '内蔵でも可（WebGL1有効）'],
      ['ブラウザ', 'Chrome/Edge/Firefox/Safari（直近2版）'],
      ['ネット', '常時接続（地図タイル取得）']
    ]
  };
  const SPEC_REC = {
    title: '推奨スペック',
    rows: [
      ['OS', 'Windows 11 / macOS 13+ / iOS 18+ / Android 13+'],
      ['CPU', '4コア 3GHz 級'],
      ['RAM', '16GB 以上'],
      ['GPU', 'ミドルクラス（WebGL2対応）'],
      ['ブラウザ', '最新安定版（ハードウェアアクセラレータON）'],
      ['ネット', '光回線相当']
    ]
  };
  function fillSpec(modal, spec) {
    specTitle.textContent = spec.title;
    specContent.innerHTML = `<table>${spec.rows.map(r => `<tr><th>${r[0]}</th><td>${r[1]}</td></tr>`).join('')}</table>`;
  }
  btnSpecMin?.addEventListener('click', () => { fillSpec(specModal, SPEC_MIN); specModal.hidden = false; });
  btnSpecRec?.addEventListener('click', () => { fillSpec(specModal, SPEC_REC); specModal.hidden = false; });
  specClose?.addEventListener('click', () => { specModal.hidden = true; });

  /* ------------------------------------------------------------
   * Theme
   * ---------------------------------------------------------- */
  function applyTheme(v) {
    document.body.setAttribute('data-theme', v || 'auto');
    localStorage.setItem(THEME_KEY, v || 'auto');
  }
  (function initTheme() {
    const saved = localStorage.getItem(THEME_KEY) || 'auto';
    document.body.setAttribute('data-theme', saved);
    if (themeSel) themeSel.value = saved;
  })();
  themeSel?.addEventListener('change', () => applyTheme(themeSel.value));

/* ------------------------------------------------------------
 * Audio / TTS — 固定版 v2（userActivated非依存・再ウォーム・安全flush）
 *   - TTSは userActivated に依存しません（WebAudioだけ依存）
 *   - cancel() は flush 時のみ＆1フレ待つ
 *   - 初回＆復帰時ウォーム、ボリューム下限 0.05（TTSのみ）
 *   - addLog('TTS', ...) があればログにも出力
 * ---------------------------------------------------------- */
function ensureAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(volIn?.value || settingsVol?.value || 0.35);
  masterGain.connect(audioCtx.destination);
}
function setVolume(v){ if (masterGain) masterGain.gain.value = v; }

let voicesReady = false;
function loadVoices(){
  try{
    const vs = window.speechSynthesis?.getVoices() || [];
    if (vs.length > 0) {
      ttsVoices = vs;
      voicesReady = true;
    }
  }catch{}
}
async function waitVoices(maxWaitMs=1800, intervalMs=80){
  const start = performance.now();
  while (performance.now() - start < maxWaitMs) {
    loadVoices();
    if (voicesReady) return true;
    await new Promise(r=>setTimeout(r, intervalMs));
  }
  return true; // 0件でも既定音声で話せる環境あり
}

function unlockByUserGesture(){
  if (userActivated) return;
  userActivated = true;
  try{ ensureAudio(); audioCtx.resume?.(); }catch{}
  loadVoices();
  if ('speechSynthesis' in window) {
    window.speechSynthesis.onvoiceschanged = () => {
      ttsVoices = window.speechSynthesis.getVoices();
      voicesReady = ttsVoices.length > 0;
    };
  }
}
window.addEventListener('pointerdown', unlockByUserGesture, { once:false, passive:true });
window.addEventListener('keydown',     unlockByUserGesture, { once:false });

voiceSel?.addEventListener('change', ()=>{ selectedVoiceName = voiceSel.value; });

function pickJapaneseVoice(){
  const vs = ttsVoices;
  if (!vs || vs.length===0) return null;
  if (selectedVoiceName && selectedVoiceName !== 'auto') {
    const byName = vs.find(v => v.name === selectedVoiceName);
    if (byName) return byName;
  }
  const ja = vs.filter(v => (v.lang || '').toLowerCase().startsWith('ja'));
  const pref = ['Google 日本語','Kyoko','Otoya','Microsoft','Siri'];
  for (const p of pref) {
    const m = ja.find(v => (v.name||'').includes(p));
    if (m) return m;
  }
  return ja[0] || vs[0] || null;
}

function isMuted(){ return muteSel?.value === 'on'; }
function ttsEnabled(){ return ttsModeSel?.value !== 'off' && 'speechSynthesis' in window; }

volIn?.addEventListener('input',      ()=> setVolume(parseFloat(volIn.value      || '0.35')));
settingsVol?.addEventListener('input',()=> setVolume(parseFloat(settingsVol.value|| '0.35')));

function logTTS(msg){ try{ addLog?.('TTS', msg); }catch{ console.log('[TTS]', msg); } }

let ttsWarmed=false, ttsQueue=[], ttsRunning=false;
function getTtsVolume(){
  // TTSは完全無音事故を避けるため 0.05 を下限（ミュートON時は黙る）
  const v = parseFloat(volIn?.value || settingsVol?.value || 0.35);
  return Math.max(0.05, Math.min(1, isFinite(v) ? v : 0.35));
}

// 初回/復帰ウォーム（空白1文字）
async function ttsWarmOnce(){
  if (ttsWarmed) return;
  await waitVoices(1800, 80);
  try{ window.speechSynthesis.resume?.(); }catch{}
  const u = new SpeechSynthesisUtterance(' ');
  u.lang = 'ja-JP';
  u.volume = getTtsVolume();
  const v = pickJapaneseVoice(); if (v) u.voice = v;
  await new Promise(res => { u.onend=res; u.onerror=res; window.speechSynthesis.speak(u); });
  ttsWarmed = true;
  logTTS('warmed');
}

// タブ復帰やWS接続・シム開始で再ウォーム
['visibilitychange','focus','pageshow'].forEach(ev=>{
  window.addEventListener(ev, ()=>{ if (!document.hidden) ttsWarmOnce(); });
});
document.addEventListener?.('EEW_WS_OPEN',  ()=> ttsWarmOnce());
document.addEventListener?.('quakeSimStart',()=> ttsWarmOnce());

// キュー実行ループ
async function runTtsQueue(){
  if (ttsRunning) return;
  ttsRunning = true;
  try{
    await ttsWarmOnce();
    while (ttsQueue.length){
      const item = ttsQueue.shift();
      const u = new SpeechSynthesisUtterance(item.text);
      u.lang   = 'ja-JP';
      u.rate   = Math.max(0.7, Math.min(1.3, parseFloat(ttsRate?.value || 1.0)));
      u.volume = getTtsVolume();
      const v  = pickJapaneseVoice(); if (v) u.voice = v;

      // flush時だけ cancel → 1フレ待って speak（巻き添え回避）
      if (item.flush) { try{ window.speechSynthesis.cancel(); }catch{} await new Promise(r=>setTimeout(r,0)); }

      await new Promise(res=>{
        u.onend = res;
        u.onerror = (e)=>{ logTTS('speak error: '+(e?.error||'unknown')); res(); };
        try{ window.speechSynthesis.speak(u); }catch(err){ logTTS('speak threw: '+err); res(); }
      });
    }
  } finally { ttsRunning = false; }
}

// 公開API：TTS（※ userActivated は見ません。ミュートONは黙る）
function speakJP(text, opts={}){
  if (!ttsEnabled()) { logTTS('disabled (mode off or APIなし)'); return; }
  if (isMuted())     { logTTS('muted, skip'); return; }
  const s = String(text||'').trim();
  if (!s) return;
  ttsQueue.push({ text:s, flush:!!opts.flush });
  runTtsQueue();
}

// テストボタン（あれば）
btnTtsTest?.addEventListener('click', ()=> {
  speakJP('これはテストです。', { flush:true });
});

// おまけ：TTS健康診断
window.TTS_DEBUG = async function(){
  logTTS(`health: voices=${ttsVoices?.length||0}, vol=${getTtsVolume()}, muted=${isMuted()}`);
  await ttsWarmOnce();
  speakJP('テストです', { flush:true });
};

/* ------------------------------------------------------------
 * 簡易SFX（WebAudio依存：クリック等で解放が必要）
 * ---------------------------------------------------------- */
function sfxTone(freq=880, ms=140, type='sine', gain=0.22){
  if (!audioCtx) ensureAudio();
  if (isMuted()) return;
  const osc = audioCtx.createOscillator();
  const g   = audioCtx.createGain();
  osc.type='sine'; osc.frequency.value=freq;
  const now = audioCtx.currentTime, dur=Math.max(0.03, ms/1000);
  const startGain = Math.max(0.0001, (masterGain?.gain?.value || 0.25) * gain);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.linearRampToValueAtTime(startGain, now + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
  osc.type = type;
  osc.connect(g); g.connect(masterGain || audioCtx.destination);
  osc.start(now);
  osc.stop(now + dur + 0.02);
}
const SFX = {
  play(tag='tick'){
    if (isMuted()) return;
    switch(tag){
      case 'p':     sfxTone(880, 120, 'sine',     0.25); break;
      case 's':     sfxTone(440, 220, 'square',   0.28); break;
      case 'alert': sfxTone(660, 160, 'sawtooth', 0.35);
                    setTimeout(()=>sfxTone(520, 180, 'sawtooth', 0.35), 120); break;
      case 'ok':    sfxTone(980, 100, 'triangle', 0.22); break;
      default:      sfxTone(740, 90,  'sine',     0.18);
    }
  }
};
window.SFX = SFX;

// 追加の確実な解放（WebAudioのみ。TTSは不要）
(function attachExtraUnlocks(){
  const onceUnlock = () => { unlockByUserGesture(); };
  [document, window, mapEl, btnStart, runStart, quickStart].forEach(el=>{
    el?.addEventListener('pointerdown', onceUnlock, { once:true, capture:true });
    el?.addEventListener('keydown',     onceUnlock, { once:true, capture:true });
  });
})();


  /* ------------------------------------------------------------
   * Map Initialize（Leaflet）
   * ---------------------------------------------------------- */
  function startApp() {
    title.classList.add('hide');
    title.setAttribute('aria-hidden', 'true');
    setTimeout(() => {
      title.style.display = 'none';
      app.removeAttribute('hidden');
      initMap();
    }, 260);
  }

  function setTiles(kind) {
    if (tiles) map.removeLayer(tiles);
    if (kind === 'bright') {
      tiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '©OpenStreetMap ©Carto', maxZoom: 19 });
    } else if (kind === 'toner') {
      tiles = L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', { attribution: 'Map tiles by Stamen, ©OpenStreetMap', maxZoom: 20 });
    } else {
      tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '©OpenStreetMap contributors', maxZoom: 19 });
    }
    tiles.addTo(map);
    tiles.setOpacity(parseFloat(tileOpacity?.value || '1'));
  }

  function initMap() {
    map = L.map('map', {
      zoomControl: true,
      minZoom: 4,
      maxZoom: 12,
      preferCanvas: true,
      doubleClickZoom: false,
      wheelDebounceTime: 35
    });
    setTiles(tileSel?.value || 'osm');

    // 初期ビュー
    map.setView([36.2048, 138.2529], 5);

    // ズーム感度調整（疑似：Wheel delta倍率）
    let wheelCoef = parseFloat(zoomSensitivity?.value || '1') || 1;
    zoomSensitivity?.addEventListener('input', () => {
      wheelCoef = parseFloat(zoomSensitivity.value || '1') || 1;
    });
    mapEl.addEventListener('wheel', (e) => {
      if (!map) return;
      const delta = (e.deltaY < 0 ? 1 : -1) * wheelCoef;
      const z = map.getZoom();
      const next = Math.max(map.getMinZoom(), Math.min(map.getMaxZoom(), z + delta * 0.2));
      if (next !== z) {
        map.setZoomAround(map.mouseEventToLatLng(e), next);
        e.preventDefault();
      }
    }, { passive: false });

    // クリック系（断層描画時は専用モードでツール競合なし）
    map.on('click', (e) => {
      if (faultDrawing) { addFaultPoint(e.latlng); return; }
      if (running) return; // ロック：シミュ中は編集不可
      if (getMode() !== 'TOOL') return;
      addEpicAt(e.latlng.lat, e.latlng.lng);
    });
    map.on('dblclick', (e) => {
      if (faultDrawing) { addFaultPoint(e.latlng); return; }
      if (running) return; // ロック
      if (getMode() !== 'TOOL') return;
      addStationAt(e.latlng.lat, e.latlng.lng, stName?.value?.trim() || `観測点${stations.length + 1}`, true, false);
    });

    heatLayer.addTo(map);
    preloadStations(); // 主要都市＋那覇

addNamedCSV(JP_STATIONS_CSV, { minDistKm: 4, label: true });

    updateHud();
    setPerfMode(perfModeSel?.value === 'on');
    updateCanvasAutoToggle();
  }

  tileSel?.addEventListener('change', () => setTiles(tileSel.value));
  tileOpacity?.addEventListener('input', () => { if (tiles) tiles.setOpacity(parseFloat(tileOpacity.value || '1')); });

  /* ------------------------------------------------------------
   * HUD / Mode
   * ---------------------------------------------------------- */
  function getMode() { return modeSel?.value || 'TOOL'; }
  function baseHudText() {
    if (faultDrawing) return '断層描画: 地図をクリックして線分を追加（終了ボタンで確定）';
    return getMode() === 'TOOL'
      ? 'ツール: クリック=震源 / ダブルタップ=観測点 / ドラッグ=移動'
      : (getMode() === 'VIEW' ? 'ビュー: 編集無効（ズーム/パンのみ）' : 'AI: API取得で自動設定（右パネル）');
  }
  function updateHud() {
    hud.textContent = `${baseHudText()} | Speed x${(parseFloat(speedIn?.value || '1')).toFixed(2)}${perfLite ? ' | 軽量ON' : ''}${canvasEnabled ? ' | Canvas描画' : ''}`;
  }
  function setModeUI() {
    const m = getMode();
    modeBadge.textContent = `Mode: ${m}`;
    updateHud();

    // シミュ中は編集不可（停止時のみ可）
    const disable = running && (m === 'VIEW' || m === 'TOOL' || m === 'AI');
    const editors = [inMag, inDepth, btnAddEpic, btnAddStation, btnClearStations, stName, stLat, stLon];
    editors.forEach(el => { if (el) el.disabled = disable; });

    // マーカーのドラッグ可否
    stations.forEach(s => s.marker?.dragging?.[disable ? 'disable' : 'enable']());
    epicenters.forEach(e => e.marker?.dragging?.[disable ? 'disable' : 'enable']());
  }
  modeSel?.addEventListener('change', () => {
    setModeUI();
    updateCanvasAutoToggle();
    if (getMode() === 'AI') showOverlay('AI推論モード', '右パネル「AI推論」でAPIを設定して取得できます。');
  });
  hudVis?.addEventListener('change', () => {
    const on = (hudVis.value === 'on');
    document.querySelectorAll('.hud,.badge').forEach(el => el.style.display = on ? 'block' : 'none');
  });

  /* ------------------------------------------------------------
   * Logs
   * ---------------------------------------------------------- */
  const alertLog = $('alertLog');
  const clearLog = $('clearLog');
  function addLog(tag, message) {
    const now = new Date();
    const hh = String(now.getHours()).padStart(2, '0');
    const mm = String(now.getMinutes()).padStart(2, '0');
    const ss = String(now.getSeconds()).padStart(2, '0');
    const time = `${hh}:${mm}:${ss}`;

    const wrap = document.createElement('div');
    wrap.className = 'item';
    const tagEl = document.createElement('span');
    tagEl.className = 'tag ' + (tag === 'P' ? 'p' : tag === 'S' ? 's' : tag === 'T' ? 't' : '');
    tagEl.textContent = tag;
    const msgEl = document.createElement('span');
    msgEl.textContent = message;
    const timeEl = document.createElement('span');
    timeEl.className = 'time mono';
    timeEl.textContent = time;

    wrap.appendChild(tagEl); wrap.appendChild(msgEl); wrap.appendChild(timeEl);

    if (alertLog.textContent.includes('まだログがありません')) alertLog.textContent = '';
    alertLog.appendChild(wrap); alertLog.scrollTop = alertLog.scrollHeight;
  }
  clearLog?.addEventListener('click', () => { alertLog.textContent = 'まだログがありません。'; });

  /* ------------------------------------------------------------
 * Station Canvas Overlay（軽量化：再生中 or 軽量モードのみ Canvas）
 * ---------------------------------------------------------- */
function ensureCanvasOverlay() {
  if (overlayCanvas) return;
  overlayCanvas = document.createElement('canvas');
  overlayCanvas.id = 'stationsCanvas';
  Object.assign(overlayCanvas.style, {
    position: 'absolute', left: '0', top: '0', width: '100%', height: '100%',
    pointerEvents: 'none', zIndex: 1099
  });
  const wrap = document.getElementById('mapWrap') || document.body;
  wrap.appendChild(overlayCanvas);
  overlayCtx = overlayCanvas.getContext('2d', { alpha: true, desynchronized: true });
  resizeCanvas();
  map.on('move zoom moveend zoomend', () => { canvasDirty = true; });
  window.addEventListener('resize', resizeCanvas);
}

function resizeCanvas() {
  if (!overlayCanvas || !map) return;
  const size = map.getSize();
  overlayCanvas.width = Math.floor(size.x * DPR);
  overlayCanvas.height = Math.floor(size.y * DPR);
  overlayCtx.setTransform(DPR, 0, 0, DPR, 0, 0);
  canvasDirty = true;
}

function enableCanvasStations(enable) {
  if (enable === canvasEnabled) return; // 余計な切替を回避

  if (enable) {
    ensureCanvasOverlay();
    stations.forEach(s => {
      if (s.visible) {
        if (map.hasLayer(s.marker)) map.removeLayer(s.marker);
        if (s.countdownMarker && map.hasLayer(s.countdownMarker)) map.removeLayer(s.countdownMarker);
        if (s.nameMarker && map.hasLayer(s.nameMarker)) map.removeLayer(s.nameMarker);
      }
    });
    canvasEnabled = true;
    canvasDirty = true;
  } else {
    stations.forEach(s => {
      if (s.visible) {
        if (!map.hasLayer(s.marker)) map.addLayer(s.marker);
        if (s.countdownMarker && !map.hasLayer(s.countdownMarker)) map.addLayer(s.countdownMarker);
        if (s.nameMarker && labelToggle?.value === 'on' && !map.hasLayer(s.nameMarker)) map.addLayer(s.nameMarker);
      }
    });
    canvasEnabled = false;
    if (overlayCanvas) { overlayCanvas.remove(); overlayCanvas = null; overlayCtx = null; }
  }
  canvasDirty = true;
  updateHud?.();
}

// ★ここだけ変更：観測点数では切り替えず、再生中 or 軽量モードでのみ Canvas
function updateCanvasAutoToggle() {
  const shouldCanvas = perfLite || running;
  enableCanvasStations(shouldCanvas);
}

function drawStationsCanvas() {
  if (!canvasEnabled || !overlayCtx || !map) return;
  if (!canvasDirty) return;
  canvasDirty = false;

  const ctx = overlayCtx;
  const size = map.getSize();
  ctx.clearRect(0, 0, size.x, size.y);

  const zoom = map.getZoom();
  const showText = zoom >= 6;
  const showLabelMajorOnly = true;
  const nowT = running ? getElapsed() : tOffset;

// ==== 観測点の自動追加をしない EEW 観測反映・軽量ブリップ表示 ====

// 設定
const EEW_NEAR_KM = 25;       // 既存観測点に紐づける距離
const EEW_FALLBACK_VIS = true; // 近傍が無い時はキャンバスだけで臨時表示する
const JMA_ORDER = ['0','1','2','3','4','5弱','5強','6弱','6強','7'];
function jmaIdx(label){ const i = JMA_ORDER.indexOf(label); return i < 0 ? 0 : i; }

// 既存の観測点から最寄りを探す（EEW_NEAR_KM 以内）
function findNearestStation(lat, lng, maxKm = EEW_NEAR_KM){
  let best = null, bd = 1e9;
  for(const s of stations || []){
    if(!s.visible) continue;
    const d = hav(lat,lng,s.lat,s.lng)/1000;
    if(d < bd && d <= maxKm){ bd = d; best = s; }
  }
  return best;
}

// ---- キャンバス用の臨時ブリップ（軽量・数秒で自動消滅） ----
let eewBlips = []; // {lat,lng,label,color,t0,ttl}
function pushEewBlip(lat,lng,label){
  const color = (typeof colorForIdx === 'function') ? colorForIdx(jmaIdx(label)) : '#ff5a5a';
  eewBlips.push({ lat, lng, label, color, t0: performance.now(), ttl: 8000 });
  if (typeof enableCanvasStations === 'function') enableCanvasStations(true); // 確実にCanvas
  canvasDirty = true;
}

// ★ これを drawStationsCanvas() の最後で呼ぶ（1行追加）
function drawEewBlips(ctx, size){
  if(!map || !ctx) return;
  const now = performance.now();
  eewBlips = eewBlips.filter(b => now - b.t0 < b.ttl);
  for(const b of eewBlips){
    const p = map.latLngToContainerPoint([b.lat, b.lng]);
    if (p.x < -30 || p.y < -30 || p.x > size.x+30 || p.y > size.y+30) continue;

    const prog = (now - b.t0) / b.ttl;                // 0 → 1
    const r = 10 + 32 * prog;                         // 拡がるリング
    ctx.save();
    ctx.globalAlpha = 1 - prog;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.lineWidth = 2; ctx.strokeStyle = b.color; ctx.stroke();
    ctx.globalAlpha = 1;

    // 中心点
    ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
    ctx.fillStyle = b.color; ctx.fill();

    // ラベル（震度）
    const txt = '震度 ' + b.label;
    ctx.font = 'bold 11px ui-sans-serif, system-ui';
    const w = ctx.measureText(txt).width + 8;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.fillRect(p.x - w/2, p.y - 26, w, 16);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(txt, p.x, p.y - 18);
    ctx.restore();
  }
}

// ---- 観測震度の反映：最寄り観測点へ上書き。無ければブリップだけ ----
function applyObservedIntensityOrBlip(lat, lng, label, name){
  try { enableCanvasStations?.(true); } catch {}
  updateCanvasAutoToggle?.();

  const st = findNearestStation(lat, lng, EEW_NEAR_KM);
  if (st){
    // 観測で上書き（予測→観測へ）
    st.obs = { label, at: Date.now() };
    st._lastBadge = label;                 // バッジに反映
    st.pred = st.pred || {};
    st.pred.color = (typeof colorForIdx === 'function') ? colorForIdx(jmaIdx(label)) : '#ff5a5a';
    st.pA = true; st.sA = true;            // 表示上は到達扱いに
    canvasDirty = true; drawStationsCanvas?.();
    addLog?.('I', `${st.name || '観測点'} 観測震度 ${label}`);
    if (typeof speakJP === 'function') speakJP(`観測震度、${st.name || '各地'}、震度 ${label}`);
  } else {
    // 近傍観測点が無い → DOMを増やさずキャンバスだけで臨時表示
    if (EEW_FALLBACK_VIS){
      pushEewBlip(lat, lng, label);
      addLog?.('I', `観測震度 ${label} @ ${lat.toFixed(2)},${lng.toFixed(2)}（臨時表示）`);
      if (typeof speakJP === 'function') speakJP(`観測震度、一部地域で、震度 ${label}`);
    } else {
      addLog?.('I', `観測震度 ${label} @ ${lat.toFixed(2)},${lng.toFixed(2)}（近傍観測点なし）`);
    }
  }
}

  stations.forEach(s => {
    if (!s.visible) return;
    const p = map.latLngToContainerPoint([s.lat, s.lng]);
    if (p.x < -40 || p.y < -40 || p.x > size.x + 40 || p.y > size.y + 40) return;

    const fill = s._obsColor || (s.sA && s.pred ? (s.pred.color || '#ff5a5f') : '#57c7ff');

    ctx.beginPath(); ctx.arc(p.x, p.y, 9, 0, Math.PI * 2);
    ctx.fillStyle = fill; ctx.fill();

    if (s._lastBadge) {
      ctx.fillStyle = '#061015';
      ctx.font = '700 11px ui-sans-serif, system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(s._lastBadge, p.x, p.y + 0.5);
    }

    if (showText && (s.isMajor || !showLabelMajorOnly) && s.pred) {
      let tag = '', left = Infinity;
      if (!s.pA) { tag = 'P'; left = s.pred.arrP - nowT; }
      else if (!s.sA) { tag = 'S'; left = s.pred.arrS - nowT; }
      else if (tsunamiOn && !s.tA && isFinite(s.pred.arrT)) { tag = 'T'; left = s.pred.arrT - nowT; }

      if (isFinite(left) && left > 0) {
        const sec = perfLite ? Math.round(left) : Math.max(0, left).toFixed(1);
        const txt = `${tag} ${sec}s`;
        ctx.font = '11px ui-sans-serif, system-ui';
        const w = ctx.measureText(txt).width + 10;
        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(p.x - w / 2, p.y + 14, w, 16);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(txt, p.x, p.y + 15);
      }
    }

    if (showText && (s.isMajor || !showLabelMajorOnly) && s.name) {
      const nm = s.name;
      ctx.font = '11px ui-sans-serif, system-ui';
      const w = ctx.measureText(nm).width + 10;
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(p.x - w / 2, p.y - 30, w, 16);
      ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      ctx.fillText(nm, p.x, p.y - 29);
    }
  });
}


/* ------------------------------------------------------------
 * Physics / Prediction（深発対応・異常震域・後方互換）
 * ---------------------------------------------------------- */
function clampMag(x) { return Math.max(-2, Math.min(12, isNaN(x) ? 6.5 : x)); }
function clampDepth(x) { return Math.max(0.1, Math.min(750, isNaN(x) ? 30 : x)); }

function stationIconHTML(text = '') { return `<div class="station-dot">${text || ''}</div>`; }
function makeNameIconHTML(name) { return `<div class="station-label">${name}</div>`; }
function makeCountdownHTML(txt) { return `<div class="countdown-pill">${txt}</div>`; }

function hav(lat1, lng1, lat2, lng2) {
  const R = 6371e3; const toRad = Math.PI / 180;
  const dLat = (lat2 - lat1) * toRad, dLng = (lng2 - lng1) * toRad;
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.sin(dLng / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(a));
}

/* ---------- 震度換算（遠方の有感を拾いやすく） ---------- */
function pgaToJMA(pga) {
  if (pga > 1.0) return { sh: '7',   idx: 8 };
  if (pga > 0.75) return { sh: '6強', idx: 7 };
  if (pga > 0.45) return { sh: '6弱', idx: 6 };
  if (pga > 0.15) return { sh: '5強', idx: 5 };
  if (pga > 0.06) return { sh: '5弱', idx: 4 };
  if (pga > 0.02) return { sh: '4',   idx: 3 };
  if (pga > 0.01) return { sh: '3',   idx: 2 };
  if (pga > 0.003) return { sh: '2',  idx: 1 };
  if (pga > 0.0005) return { sh: '1', idx: 0 }; // ← 0.001 → 0.0005 に緩和
  return { sh: '', idx: 0 };
}

function colorForIdx(i) {
  const pal = ['#9ebed6', '#7fc9c9', '#6de0a8', '#f7e86b', '#ffd27a', '#ffb06b', '#ff8a5f', '#ff5a5a', '#c83b3b', '#C0C0C0'];
  return pal[Math.max(0, Math.min(pal.length - 1, i))];
}

/* ---------- 距離キャッシュ ---------- */
const H_CACHE = new Map(); // key:`e.id:s.id` -> km
function getHkmCached(e, s) {
  const key = `${e.id}:${s.id}`;
  if (!e._moved && !s._moved && H_CACHE.has(key)) return H_CACHE.get(key);
  const h = hav(e.lat, e.lng, s.lat, s.lng) / 1000;
  H_CACHE.set(key, h);
  return h;
}
function markAllUnmoved() { epicenters.forEach(e => e._moved = false); stations.forEach(s => s._moved = false); }

/* ---------- 直近コンテキスト（後方互換のため） ---------- */
let __LAST_ARR_CTX = null;

/* ---------- P/S到達時刻 ---------- */
function arrivals(epi, st) {
  const Hkm = getHkmCached(epi, st);
  const R = Math.sqrt(Hkm * Hkm + epi.depth * epi.depth);
  // 後方互換: 直近の震源・観測点情報を保持（estimatePGA が2引数でも深さ/方位を参照できる）
  __LAST_ARR_CTX = {
    dep: epi.depth, epiLat: epi.lat, epiLng: epi.lng, stLat: st.lat, stLng: st.lng, Rkm: R
  };
  return { tP: R / vp, tS: R / vs, Rkm: R, Hkm };
}

/* ---------- 方位（度） ---------- */
function bearingDeg(lat1, lon1, lat2, lon2) {
  const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
  const φ1 = lat1 * toRad, φ2 = lat2 * toRad, dλ = (lon2 - lon1) * toRad;
  const y = Math.sin(dλ) * Math.cos(φ2);
  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(dλ);
  return (Math.atan2(y, x) * toDeg + 360) % 360;
}

/* ---------- 異常震域ブースト（深発強化版） ---------- */
function abnormalIntensityBoost(depthKm, epiLat, epiLng, stLat, stLng, Rkm) {
  const d = clampDepth(depthKm);

  // 深いほどリング中心を外側へ：R0 ≈ 50 + 0.9*depth
  // 例) depth=670km → R0 ≈ 653+50 ≈ 703km
  const R0   = 50 + 0.9 * d;
  const sigR = 260;   // リング幅を広めに
  const A    = 1.10;  // リング増幅（最大 +110%）
  const sNear = 120;  // 近距離抑制の広がりを小さめに
  const D     = 0.25; // 近距離抑制度合い
  const ring  = 1 + A * Math.exp(-0.5 * ((Rkm - R0) / sigR) ** 2)
                  - D * Math.exp(-0.5 * (Rkm / sNear) ** 2);

  // 方位ローブ：本州方向をやや広く（±50°）
  const HONSHU = { lat: 37.5, lng: 138.5 };
  const azGuide = bearingDeg(epiLat, epiLng, HONSHU.lat, HONSHU.lng);
  const azToSta = bearingDeg(epiLat, epiLng, stLat, stLng);
  const dAz   = (Math.abs(azToSta - azGuide) + 540) % 360 - 180;
  const sigAz = 50;
  const C     = 0.35;
  const lobe  = 1 + C * Math.exp(-0.5 * (dAz / sigAz) ** 2);

  // 日本列島～本州弧の「波導」っぽい利得（遠距離域で底上げ）
  // だいたい 300–1200kmに広く効かせ、中心は ~750km
  const G = 1 + 0.50 * Math.exp(-0.5 * ((Rkm - 750) / 300) ** 2);

  // 駆動域：日本の緯度経度帯に入っていたら、わずかに底上げ（地盤/盆地の平均化）
  const inJapanArc = (stLat >= 31 && stLat <= 44 && stLng >= 130 && stLng <= 145) ? 1.10 : 1.00;

  // 係数の上下限をやや広めに（全土で広く揺れる事例を再現）
  return Math.max(0.7, Math.min(3.0, ring * lobe * G * inJapanArc));
}

/* ---------- PGA推定（深発対応・異常震域・εフロア強化） ---------- */
function estimatePGA(M, Rkm, depthKm = null, epiLat = null, epiLng = null, stLat = null, stLng = null) {
  const ctx = __LAST_ARR_CTX || {};
  const dep  = clampDepth(depthKm != null ? depthKm : (ctx.dep != null ? ctx.dep : 30));
  const rkm  = Math.max(1, isFinite(Rkm) ? Rkm : (ctx.Rkm || 50));
  const eLat = (epiLat != null ? epiLat : ctx.epiLat);
  const eLng = (epiLng != null ? epiLng : ctx.epiLng);
  const sLat = (stLat != null ? stLat : ctx.stLat);
  const sLng = (stLng != null ? stLng : ctx.stLng);

  // 深さでタイプを分ける
  const type = (dep >= 60) ? 'slab' : (dep >= 20 ? 'interface' : 'crust');

  // 減衰パラメタ（深発はさらに緩く & 深さ項強め）
  const baseD = Math.max(0, dAtt);
  const params = {
    crust:     { a: -1.10, b: 0.45, c: 1.10, h: 10, d: baseD * 1.00, kDepth: -0.0004 },
    interface: { a: -1.30, b: 0.43, c: 1.15, h: 16, d: baseD * 0.85, kDepth: -0.0001 },
    slab:      { a: -1.50, b: 0.44, c: 0.95, h: 45, d: Math.max(0.0004, baseD * 0.45), kDepth: +0.0016 }
    // ↑ slab: 減衰(d)をかなり緩く、深さ係数を強め、hも大きめ
  };
  const p = params[type];

  // 有効距離（浅部ハードニング）
  const Reff = Math.sqrt(rkm * rkm + p.h * p.h);

  // 対数モデル（g）
  let lg  = p.a + p.b * M - p.c * Math.log10(Reff) - p.d * Reff + p.kDepth * dep;
  let PGA = Math.pow(10, lg);

  // 深発・超深発での広域利得
  if (dep >= 250 && isFinite(eLat) && isFinite(eLng) && isFinite(sLat) && isFinite(sLng)) {
    PGA *= abnormalIntensityBoost(dep, eLat, eLng, sLat, sLng, rkm);
  }

  // 過度な 0 落ち回避（遠距離の有感を拾う）
  const EPS = 3e-6; // 0.000003 g（従来 1e-6 より高め）
  return Math.max(EPS, PGA);
}


  /* ------------------------------------------------------------
   * 海域ベースン（津波）＆ JMA 震央地名（簡易ポリゴン/BB）
   * - ベースン：太平洋、日本海、オホーツク海、東シナ海（簡易）
   * - 津波は「同一ベースン」内でのみ到達（内陸は原則除外）
   * - 震央地名：多数の代表区分＋都道府県北部/南部などBBで判定
   *   （栃木県北部/南部、福島県沖、三陸沖、オホーツク海 等を明示）
   * ---------------------------------------------------------- */

  // Point in Polygon (ray-casting)
  function pointInPolygon(lat, lng, poly) {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi > lng) !== (yj > lng)) && (lat < (xj - xi) * (lng - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // 簡易ベースン（かなり粗め／陸域を極力除外する帯状多角形）
  const BASINS = [
    {
      name: '太平洋',
      poly: [
        // 大まかに本州太平洋側沖〜小笠原〜千島の外洋（陸側を狭く含む）
        [20, 122], [26, 130], [31, 137], [35, 144], [41, 149], [46, 152], [49, 150],
        [47, 145], [44, 143], [40, 143], [36, 142], [33, 139.5], [30, 138],
        [26, 136], [22, 132], [20, 127], [20, 122]
      ],
      // 陸側の細帯を除くため、内陸は原則対象外扱いにする
      coastalOnly: true
    },
    {
      name: '日本海',
      poly: [
        [33, 127], [35.5, 130], [37.5, 134], [39.5, 137], [41.5, 139.5], [44, 141],
        [47, 140], [47, 136], [45, 133], [42, 131], [39, 129], [36, 128], [33, 127]
      ],
      coastalOnly: true
    },
    {
      name: 'オホーツク海',
      poly: [
        [43.5, 142], [45, 145], [47, 147], [51, 150], [55, 149], [55, 144],
        [50, 141], [46, 142], [44, 142], [43.5, 142]
      ],
      coastalOnly: true
    },
    {
      name: '東シナ海',
      poly: [
        [24, 122], [26, 124], [28, 126], [30, 127], [31.5, 127], [33, 126],
        [32, 125], [30, 124], [28, 123], [26, 122.5], [24, 122]
      ],
      coastalOnly: true
    }
  ];

  function whichBasin(lat, lng) {
    for (const b of BASINS) {
      if (pointInPolygon(lat, lng, b.poly)) return b.name;
    }
    return null;
  }

  // 「海岸帯」判定の簡易版：海ベースンのポリゴン境界に近い領域を陸側に少しだけ含めているため、
  // 地点がベースン内に入っていれば「沿岸」とみなす（広域内陸はそもそもポリ内に入っていない）
  function tsunamiArrivable(epi, st) {
    const bE = whichBasin(epi.lat, epi.lng);
    if (!bE) return false;
    const bS = whichBasin(st.lat, st.lng);
    if (!bS) return false;
    return bE === bS; // ベースンが同一のときのみ可
  }

  // ---- JMA 震央地名（代表区分） ----
  // ※ 完全データではなく、高頻度・代表域＋指摘の強かった地域を重点収録。
  //   - 都道府県内「北部/南部」「東部/西部」などは簡易BB（緯度/経度で2分割）で近似
  //   - 沖（○○沖/○○方）などは沖側ベースン＋沿岸BBで判定
  // 必要に応じて追加可能：JMA_REGIONS.push({ name, poly:[ [lat,lng], ... ] }) or bbox:{lat1,lat2,lng1,lng2}
  const JMA_REGIONS = [
  // ====== 海域（優先評価。basin一致が必須のため陸点はヒットしない） ======

  // --- 太平洋（北海道〜東北〜関東） ---
  { name: '根室半島南東沖', basin: '太平洋', bbox: { lat1: 43.10, lat2: 43.80, lng1: 145.50, lng2: 146.80 } },
  { name: '釧路沖',       basin: '太平洋', bbox: { lat1: 42.50, lat2: 43.30, lng1: 144.00, lng2: 145.50 } },
  { name: '十勝沖',       basin: '太平洋', bbox: { lat1: 42.20, lat2: 42.95, lng1: 143.20, lng2: 144.50 } },
  { name: '北海道東方沖', basin: '太平洋', bbox: { lat1: 42.50, lat2: 45.50, lng1: 145.50, lng2: 149.50 } },
  { name: '三陸沖',       basin: '太平洋', bbox: { lat1: 38.00, lat2: 41.60, lng1: 142.00, lng2: 145.60 } },
  { name: '岩手県沖',     basin: '太平洋', bbox: { lat1: 39.30, lat2: 40.60, lng1: 142.00, lng2: 143.60 } },
  { name: '宮城県沖',     basin: '太平洋', bbox: { lat1: 37.80, lat2: 39.00, lng1: 141.80, lng2: 144.00 } },
  { name: '福島県沖',     basin: '太平洋', bbox: { lat1: 36.80, lat2: 38.05, lng1: 141.40, lng2: 144.00 } },
  // ★内陸誤判定対策：茨城内陸は海を拾わないよう縮小、代わりに沖を西へ拡張
  { name: '茨城県沖',     basin: '太平洋', bbox: { lat1: 35.70, lat2: 36.95, lng1: 140.45, lng2: 142.80 } },
  { name: '常磐沖',       basin: '太平洋', bbox: { lat1: 36.60, lat2: 37.90, lng1: 141.50, lng2: 143.00 } },
  { name: '房総沖',       basin: '太平洋', bbox: { lat1: 34.80, lat2: 35.95, lng1: 140.60, lng2: 142.40 } },
  { name: '千葉県東方沖', basin: '太平洋', bbox: { lat1: 35.00, lat2: 36.20, lng1: 140.80, lng2: 142.80 } },
  { name: '相模湾',       basin: '太平洋', bbox: { lat1: 34.90, lat2: 35.42, lng1: 139.00, lng2: 140.00 } },
  { name: '相模灘',       basin: '太平洋', bbox: { lat1: 35.00, lat2: 35.40, lng1: 139.00, lng2: 139.80 } },
  { name: '東京湾北部',   basin: '太平洋', bbox: { lat1: 35.45, lat2: 35.72, lng1: 139.75, lng2: 140.05 } },
  { name: '東京湾',       basin: '太平洋', bbox: { lat1: 35.12, lat2: 35.62, lng1: 139.70, lng2: 140.10 } },
  { name: '伊豆大島近海', basin: '太平洋', bbox: { lat1: 33.80, lat2: 34.90, lng1: 138.60, lng2: 140.10 } },
  { name: '伊豆半島東方沖', basin: '太平洋', bbox: { lat1: 34.80, lat2: 35.20, lng1: 139.20, lng2: 140.30 } },
  { name: '伊豆半島南方沖', basin: '太平洋', bbox: { lat1: 33.50, lat2: 34.50, lng1: 138.50, lng2: 139.70 } },

  // --- 太平洋（中部〜近畿〜四国・九州） ---
  { name: '駿河湾',       basin: '太平洋', bbox: { lat1: 34.50, lat2: 35.05, lng1: 138.30, lng2: 138.92 } },
  { name: '遠州灘',       basin: '太平洋', bbox: { lat1: 34.20, lat2: 34.85, lng1: 137.80, lng2: 138.85 } },
  { name: '熊野灘',       basin: '太平洋', bbox: { lat1: 33.50, lat2: 34.30, lng1: 135.60, lng2: 136.90 } },
  { name: '紀伊半島南方沖', basin: '太平洋', bbox: { lat1: 32.80, lat2: 33.85, lng1: 135.00, lng2: 137.20 } },
  { name: '土佐湾',       basin: '太平洋', bbox: { lat1: 33.10, lat2: 33.55, lng1: 133.30, lng2: 134.30 } },
  { name: '四国沖',       basin: '太平洋', bbox: { lat1: 32.00, lat2: 33.70, lng1: 132.00, lng2: 135.50 } },
  { name: '紀伊水道',     basin: '太平洋', bbox: { lat1: 33.70, lat2: 34.50, lng1: 134.80, lng2: 135.60 } },
  { name: '豊後水道',     basin: '太平洋', bbox: { lat1: 32.70, lat2: 33.60, lng1: 132.50, lng2: 133.60 } },
  { name: '日向灘',       basin: '太平洋', bbox: { lat1: 31.00, lat2: 32.30, lng1: 131.60, lng2: 132.50 } },

  // --- 太平洋（伊豆小笠原〜鳥島） ---
  { name: '八丈島近海',     basin: '太平洋', bbox: { lat1: 32.80, lat2: 33.50, lng1: 139.50, lng2: 140.90 } },
  { name: '八丈島東方沖',   basin: '太平洋', bbox: { lat1: 32.50, lat2: 33.50, lng1: 140.90, lng2: 142.50 } },
  { name: '鳥島近海',       basin: '太平洋', bbox: { lat1: 29.50, lat2: 31.50, lng1: 139.00, lng2: 141.50 } },
  { name: '鳥島東方沖',     basin: '太平洋', bbox: { lat1: 29.00, lat2: 31.00, lng1: 141.50, lng2: 144.00 } },
  { name: '小笠原諸島近海', basin: '太平洋', bbox: { lat1: 26.50, lat2: 28.50, lng1: 140.80, lng2: 142.50 } },
  { name: '小笠原諸島西方沖', basin: '太平洋', bbox: { lat1: 26.00, lat2: 28.50, lng1: 138.50, lng2: 140.80 } },
  { name: '小笠原諸島東方沖', basin: '太平洋', bbox: { lat1: 26.00, lat2: 28.50, lng1: 142.50, lng2: 145.00 } },
  { name: '父島近海',       basin: '太平洋', bbox: { lat1: 27.30, lat2: 27.90, lng1: 141.80, lng2: 142.30 } },
  { name: '母島近海',       basin: '太平洋', bbox: { lat1: 26.50, lat2: 27.20, lng1: 142.00, lng2: 142.60 } },

  // --- 日本海系 ---
  { name: '北海道西方沖',     basin: '日本海', bbox: { lat1: 41.90, lat2: 45.00, lng1: 138.50, lng2: 141.00 } },
  { name: '北海道南西沖',     basin: '日本海', bbox: { lat1: 41.20, lat2: 42.50, lng1: 139.00, lng2: 141.50 } },
  { name: '青森県西方沖',     basin: '日本海', bbox: { lat1: 40.80, lat2: 41.60, lng1: 139.50, lng2: 140.80 } },
  { name: '秋田県沖',         basin: '日本海', bbox: { lat1: 39.30, lat2: 40.60, lng1: 139.50, lng2: 140.50 } },
  { name: '山形県沖',         basin: '日本海', bbox: { lat1: 38.40, lat2: 39.30, lng1: 138.60, lng2: 139.80 } },
  { name: '新潟県沖',         basin: '日本海', bbox: { lat1: 37.50, lat2: 38.60, lng1: 137.60, lng2: 139.40 } },
  { name: '津軽海峡',         basin: '日本海', bbox: { lat1: 41.20, lat2: 41.65, lng1: 140.50, lng2: 141.50 } },
  { name: '富山湾',           basin: '日本海', bbox: { lat1: 36.70, lat2: 37.10, lng1: 136.70, lng2: 137.50 } },
  { name: '能登半島沖',       basin: '日本海', bbox: { lat1: 37.20, lat2: 38.20, lng1: 136.50, lng2: 137.80 } },
  { name: '若狭湾',           basin: '日本海', bbox: { lat1: 35.40, lat2: 35.85, lng1: 135.50, lng2: 136.40 } },
  { name: '山陰沖',           basin: '日本海', bbox: { lat1: 34.80, lat2: 36.00, lng1: 132.00, lng2: 135.00 } },
  { name: '玄界灘',           basin: '日本海', bbox: { lat1: 33.60, lat2: 34.30, lng1: 129.20, lng2: 130.50 } },
  { name: '対馬近海',         basin: '日本海', bbox: { lat1: 34.00, lat2: 35.50, lng1: 128.50, lng2: 130.00 } },
  { name: '佐渡付近',         basin: '日本海', bbox: { lat1: 37.70, lat2: 38.40, lng1: 138.30, lng2: 138.80 } },
  { name: '日本海北部',       basin: '日本海', bbox: { lat1: 41.50, lat2: 45.50, lng1: 135.00, lng2: 140.00 } },
  { name: '日本海中部',       basin: '日本海', bbox: { lat1: 38.00, lat2: 41.50, lng1: 134.00, lng2: 138.50 } },
  { name: '日本海南部',       basin: '日本海', bbox: { lat1: 35.00, lat2: 38.00, lng1: 131.50, lng2: 136.00 } },

  // --- オホーツク海・千島 ---
  { name: 'オホーツク海',       basin: 'オホーツク海' },
  { name: 'オホーツク海南部',   basin: 'オホーツク海', bbox: { lat1: 44.00, lat2: 47.00, lng1: 142.00, lng2: 149.00 } },
  { name: 'サハリン西方沖',     basin: 'オホーツク海', bbox: { lat1: 47.00, lat2: 50.00, lng1: 140.00, lng2: 141.80 } },
  { name: '千島列島',           basin: '太平洋',       bbox: { lat1: 43.00, lat2: 49.00, lng1: 146.00, lng2: 154.00 } },
  { name: '千島列島南部',       basin: '太平洋',       bbox: { lat1: 43.00, lat2: 46.00, lng1: 147.00, lng2: 151.00 } },

  // --- 東シナ海・沖縄周辺 ---
  { name: '奄美近海',           basin: '東シナ海', bbox: { lat1: 26.00, lat2: 28.90, lng1: 128.00, lng2: 130.50 } },
  { name: '九州西方沖',         basin: '東シナ海', bbox: { lat1: 31.00, lat2: 33.00, lng1: 127.00, lng2: 129.00 } },
  { name: '甑島近海',           basin: '東シナ海', bbox: { lat1: 31.70, lat2: 32.20, lng1: 129.80, lng2: 130.30 } },
  { name: '沖縄本島近海',       basin: '東シナ海', bbox: { lat1: 26.00, lat2: 27.20, lng1: 127.00, lng2: 128.20 } },
  { name: '沖縄本島北西沖',     basin: '東シナ海', bbox: { lat1: 26.50, lat2: 27.50, lng1: 126.00, lng2: 127.20 } },
  { name: '沖縄本島南方沖',     basin: '東シナ海', bbox: { lat1: 25.00, lat2: 26.00, lng1: 127.00, lng2: 128.50 } },
  { name: '慶良間諸島近海',     basin: '東シナ海', bbox: { lat1: 26.00, lat2: 26.50, lng1: 127.00, lng2: 127.80 } },
  { name: '久米島近海',         basin: '東シナ海', bbox: { lat1: 26.00, lat2: 26.60, lng1: 126.90, lng2: 127.60 } },
  { name: '宮古島近海',         basin: '東シナ海', bbox: { lat1: 24.50, lat2: 25.20, lng1: 125.00, lng2: 126.00 } },
  { name: '宮古島北西沖',       basin: '東シナ海', bbox: { lat1: 25.00, lat2: 25.80, lng1: 124.00, lng2: 125.10 } },
  { name: '石垣島近海',         basin: '東シナ海', bbox: { lat1: 24.10, lat2: 24.60, lng1: 124.00, lng2: 124.60 } },
  { name: '石垣島北西沖',       basin: '東シナ海', bbox: { lat1: 24.60, lat2: 25.30, lng1: 123.00, lng2: 124.20 } },
  { name: '西表島近海',         basin: '東シナ海', bbox: { lat1: 24.10, lat2: 24.60, lng1: 123.50, lng2: 124.10 } },
  { name: '与那国島近海',       basin: '東シナ海', bbox: { lat1: 24.30, lat2: 24.60, lng1: 122.90, lng2: 123.30 } },
  { name: '北大東島近海',       basin: '太平洋',   bbox: { lat1: 25.90, lat2: 26.40, lng1: 131.10, lng2: 131.60 } },
  { name: '南大東島近海',       basin: '太平洋',   bbox: { lat1: 25.50, lat2: 25.90, lng1: 131.10, lng2: 131.60 } },
  { name: '南大東島東方沖',     basin: '太平洋',   bbox: { lat1: 25.30, lat2: 25.80, lng1: 132.00, lng2: 133.50 } },

  // --- 広域トラフ・海溝 ---
  { name: '日本海溝',     basin: '太平洋', bbox: { lat1: 36.00, lat2: 41.50, lng1: 142.00, lng2: 146.00 } },
  { name: '相模トラフ',   basin: '太平洋', bbox: { lat1: 34.60, lat2: 35.30, lng1: 139.00, lng2: 140.00 } },
  { name: '駿河トラフ',   basin: '太平洋', bbox: { lat1: 34.40, lat2: 35.10, lng1: 138.30, lng2: 138.90 } },
  { name: '南海トラフ',   basin: '太平洋', bbox: { lat1: 32.00, lat2: 34.50, lng1: 135.00, lng2: 138.50 } },

  // ====== 内湾・瀬戸内（太平洋系として扱う） ======
  { name: '播磨灘',   basin: '太平洋', bbox: { lat1: 34.20, lat2: 34.60, lng1: 134.30, lng2: 134.90 } },
  { name: '備讃瀬戸', basin: '太平洋', bbox: { lat1: 34.20, lat2: 34.50, lng1: 133.80, lng2: 134.30 } },
  { name: '燧灘',     basin: '太平洋', bbox: { lat1: 33.90, lat2: 34.30, lng1: 132.80, lng2: 133.80 } },
  { name: '安芸灘',   basin: '太平洋', bbox: { lat1: 34.00, lat2: 34.40, lng1: 132.20, lng2: 132.80 } },
  { name: '周防灘',   basin: '太平洋', bbox: { lat1: 33.70, lat2: 34.02, lng1: 131.00, lng2: 131.90 } },
  { name: '伊予灘',   basin: '太平洋', bbox: { lat1: 33.70, lat2: 34.20, lng1: 132.20, lng2: 132.90 } },

  // ====== 内陸（より狭い順に） ======

  // --- 首都圏（重なり回避のため23区を先） ---
  { name: '東京都23区',    bbox: { lat1: 35.560, lat2: 35.820, lng1: 139.560, lng2: 139.920 } }, // 板橋区等を確実に包含
  { name: '東京都多摩東部', bbox: { lat1: 35.60,  lat2: 35.82,  lng1: 139.30,  lng2: 139.60 } },
  { name: '東京都多摩西部', bbox: { lat1: 35.35,  lat2: 35.80,  lng1: 138.90,  lng2: 139.30 } },
  // ★埼玉南部の下限を上げ、23区との重なりを解消
  { name: '埼玉県南部',    bbox: { lat1: 35.820, lat2: 36.000, lng1: 139.200, lng2: 139.900 } },
  { name: '埼玉県北部',    bbox: { lat1: 36.000, lat2: 36.320, lng1: 139.200, lng2: 139.700 } },

  // --- 茨城（内陸の東端を内側へ：海を拾わない） ---
  { name: '茨城県北部',    bbox: { lat1: 36.60,  lat2: 36.95,  lng1: 139.90,  lng2: 140.45 } },
  { name: '茨城県南部',    bbox: { lat1: 35.85,  lat2: 36.60,  lng1: 139.70,  lng2: 140.45 } },

  // --- 千葉・神奈川 ---
  { name: '千葉県北西部',  bbox: { lat1: 35.55,  lat2: 35.92,  lng1: 139.80,  lng2: 140.15 } }, // 東京湾沿いの海を含まない
  { name: '千葉県南部',    bbox: { lat1: 34.90,  lat2: 35.55,  lng1: 139.80,  lng2: 140.35 } },
  { name: '神奈川県東部',  bbox: { lat1: 35.28,  lat2: 35.63,  lng1: 139.50,  lng2: 139.82 } },
  { name: '神奈川県西部',  bbox: { lat1: 35.20,  lat2: 35.60,  lng1: 139.00,  lng2: 139.50 } },

  // --- 栃木・群馬・山梨・長野 ---
  { name: '栃木県北部',    bbox: { lat1: 36.70,  lat2: 37.30,  lng1: 139.30,  lng2: 140.40 } },
  { name: '栃木県南部',    bbox: { lat1: 36.20,  lat2: 36.70,  lng1: 139.30,  lng2: 140.40 } },
  { name: '群馬県北部',    bbox: { lat1: 36.65,  lat2: 36.95,  lng1: 138.60,  lng2: 139.40 } },
  { name: '群馬県南部',    bbox: { lat1: 36.20,  lat2: 36.65,  lng1: 138.60,  lng2: 139.60 } },
  { name: '山梨県中・西部', bbox: { lat1: 35.30,  lat2: 35.90,  lng1: 138.20,  lng2: 138.90 } },
  { name: '長野県北部',    bbox: { lat1: 36.50,  lat2: 37.00,  lng1: 137.60,  lng2: 138.60 } },
  { name: '長野県南部',    bbox: { lat1: 35.20,  lat2: 36.50,  lng1: 137.40,  lng2: 138.60 } },

  // --- 北海道・周辺（内陸系） ---
  { name: '北海道道北',    bbox: { lat1: 44.00,  lat2: 45.80,  lng1: 141.00,  lng2: 142.80 } },
  { name: '北海道道東',    bbox: { lat1: 43.00,  lat2: 45.80,  lng1: 143.00,  lng2: 146.50 } },
  { name: '北海道道央',    bbox: { lat1: 42.30,  lat2: 43.80,  lng1: 140.70,  lng2: 143.00 } },
  { name: '北海道道南',    bbox: { lat1: 41.20,  lat2: 42.40,  lng1: 140.20,  lng2: 141.60 } },
  { name: '石狩湾',        bbox: { lat1: 43.00,  lat2: 43.70,  lng1: 141.00,  lng2: 141.70 } },

  // --- 東北（内陸系） ---
  { name: '青森県北部',    bbox: { lat1: 40.90,  lat2: 41.50,  lng1: 140.60,  lng2: 141.40 } },
  { name: '青森県南部',    bbox: { lat1: 40.20,  lat2: 40.90,  lng1: 140.60,  lng2: 141.60 } },
  { name: '岩手県内陸北部', bbox:{ lat1: 39.70,  lat2: 40.40,  lng1: 141.00,  lng2: 141.90 } },
  { name: '岩手県内陸南部', bbox:{ lat1: 38.90,  lat2: 39.70,  lng1: 140.80,  lng2: 141.90 } },
  { name: '宮城県北部',    bbox: { lat1: 38.60,  lat2: 39.20,  lng1: 140.70,  lng2: 141.60 } },
  { name: '宮城県南部',    bbox: { lat1: 38.00,  lat2: 38.60,  lng1: 140.50,  lng2: 141.60 } },
  { name: '秋田県内陸北部', bbox:{ lat1: 39.90,  lat2: 40.60,  lng1: 140.10,  lng2: 140.80 } },
  { name: '秋田県内陸南部', bbox:{ lat1: 39.10,  lat2: 39.90,  lng1: 140.00,  lng2: 140.80 } },
  { name: '山形県村山',    bbox: { lat1: 38.20,  lat2: 38.70,  lng1: 140.10,  lng2: 140.60 } },
  { name: '山形県置賜',    bbox: { lat1: 37.80,  lat2: 38.30,  lng1: 139.90,  lng2: 140.60 } },
  { name: '福島県中通り',  bbox: { lat1: 37.10,  lat2: 37.90,  lng1: 139.40,  lng2: 140.70 } },
  { name: '福島県浜通り',  bbox: { lat1: 36.80,  lat2: 37.90,  lng1: 140.60,  lng2: 141.20 } },
  { name: '福島県会津',    bbox: { lat1: 37.10,  lat2: 37.90,  lng1: 139.20,  lng2: 139.90 } },

  // --- 東海・北陸・近畿（内陸系） ---
  { name: '静岡県中部',    bbox: { lat1: 34.80,  lat2: 35.10,  lng1: 138.20,  lng2: 138.50 } },
  { name: '静岡県東部',    bbox: { lat1: 34.80,  lat2: 35.20,  lng1: 138.70,  lng2: 139.20 } },
  { name: '静岡県西部',    bbox: { lat1: 34.60,  lat2: 34.90,  lng1: 137.60,  lng2: 138.20 } },
  { name: '愛知県西部',    bbox: { lat1: 34.70,  lat2: 35.30,  lng1: 136.70,  lng2: 137.20 } },
  { name: '愛知県東部',    bbox: { lat1: 34.80,  lat2: 35.20,  lng1: 137.20,  lng2: 137.80 } },
  { name: '三重県北部',    bbox: { lat1: 34.70,  lat2: 35.20,  lng1: 136.20,  lng2: 136.80 } },
  { name: '三重県中部',    bbox: { lat1: 34.40,  lat2: 34.90,  lng1: 136.30,  lng2: 136.80 } },
  { name: '三重県南部',    bbox: { lat1: 33.70,  lat2: 34.40,  lng1: 136.00,  lng2: 136.90 } },
  { name: '石川県能登',    bbox: { lat1: 37.10,  lat2: 37.60,  lng1: 136.70,  lng2: 137.50 } },
  { name: '石川県加賀',    bbox: { lat1: 36.10,  lat2: 36.60,  lng1: 136.30,  lng2: 136.80 } },
  { name: '富山県東部',    bbox: { lat1: 36.50,  lat2: 36.90,  lng1: 137.40,  lng2: 137.80 } },
  { name: '富山県西部',    bbox: { lat1: 36.50,  lat2: 36.90,  lng1: 136.90,  lng2: 137.40 } },
  { name: '新潟県上越',    bbox: { lat1: 36.70,  lat2: 37.40,  lng1: 137.80,  lng2: 138.70 } },
  { name: '新潟県中越',    bbox: { lat1: 37.10,  lat2: 37.60,  lng1: 138.50,  lng2: 139.30 } },
  { name: '新潟県下越',    bbox: { lat1: 37.60,  lat2: 38.20,  lng1: 139.20,  lng2: 139.70 } },
  { name: '福井県嶺北',    bbox: { lat1: 35.70,  lat2: 36.20,  lng1: 136.00,  lng2: 136.80 } },
  { name: '福井県嶺南',    bbox: { lat1: 35.30,  lat2: 35.70,  lng1: 135.60,  lng2: 136.30 } },
  { name: '滋賀県北部',    bbox: { lat1: 35.30,  lat2: 35.70,  lng1: 135.90,  lng2: 136.40 } },
  { name: '滋賀県南部',    bbox: { lat1: 34.90,  lat2: 35.30,  lng1: 135.80,  lng2: 136.30 } },
  { name: '京都府北部',    bbox: { lat1: 35.30,  lat2: 35.70,  lng1: 135.10,  lng2: 135.80 } },
  { name: '京都府南部',    bbox: { lat1: 34.80,  lat2: 35.20,  lng1: 135.50,  lng2: 136.10 } },
  { name: '大阪府北部',    bbox: { lat1: 34.70,  lat2: 34.92,  lng1: 135.40,  lng2: 135.70 } },
  { name: '大阪府南部',    bbox: { lat1: 34.30,  lat2: 34.72,  lng1: 135.45,  lng2: 135.70 } },
  { name: '大阪湾',        bbox: { lat1: 34.25,  lat2: 34.70,  lng1: 135.00,  lng2: 135.50 } },
  { name: '兵庫県北部',    bbox: { lat1: 35.10,  lat2: 35.70,  lng1: 134.60,  lng2: 135.20 } },
  { name: '兵庫県南東部',  bbox: { lat1: 34.60,  lat2: 34.90,  lng1: 135.00,  lng2: 135.40 } },
  { name: '兵庫県南西部',  bbox: { lat1: 34.60,  lat2: 35.00,  lng1: 134.60,  lng2: 135.00 } },
  { name: '奈良県北部',    bbox: { lat1: 34.50,  lat2: 34.80,  lng1: 135.60,  lng2: 136.10 } },
  { name: '奈良県南部',    bbox: { lat1: 33.90,  lat2: 34.50,  lng1: 135.60,  lng2: 136.20 } },
  { name: '和歌山県北部',  bbox: { lat1: 34.10,  lat2: 34.40,  lng1: 135.10,  lng2: 135.60 } },
  { name: '和歌山県南部',  bbox: { lat1: 33.50,  lat2: 34.10,  lng1: 135.40,  lng2: 135.90 } },

  // --- 中国・四国・九州（内陸系） ---
  { name: '鳥取県東部',    bbox: { lat1: 35.30,  lat2: 35.60,  lng1: 134.10,  lng2: 134.45 } },
  { name: '鳥取県中部',    bbox: { lat1: 35.30,  lat2: 35.60,  lng1: 133.80,  lng2: 134.10 } },
  { name: '鳥取県西部',    bbox: { lat1: 35.30,  lat2: 35.60,  lng1: 133.20,  lng2: 133.80 } },
  { name: '島根県東部',    bbox: { lat1: 35.20,  lat2: 35.50,  lng1: 132.60,  lng2: 133.20 } },
  { name: '島根県西部',    bbox: { lat1: 34.90,  lat2: 35.40,  lng1: 131.50,  lng2: 132.60 } },
  { name: '隠岐',          bbox: { lat1: 36.00,  lat2: 36.40,  lng1: 133.00,  lng2: 133.40 } },
  { name: '岡山県南部',    bbox: { lat1: 34.40,  lat2: 34.90,  lng1: 133.60,  lng2: 134.20 } },
  { name: '岡山県北部',    bbox: { lat1: 35.00,  lat2: 35.40,  lng1: 133.50,  lng2: 134.30 } },
  { name: '広島県南東部',  bbox: { lat1: 34.20,  lat2: 34.60,  lng1: 132.40,  lng2: 133.20 } },
  { name: '広島県南西部',  bbox: { lat1: 34.20,  lat2: 34.60,  lng1: 131.70,  lng2: 132.40 } },
  { name: '山口県東部',    bbox: { lat1: 34.00,  lat2: 34.40,  lng1: 131.60,  lng2: 132.10 } },
  { name: '山口県中部',    bbox: { lat1: 34.00,  lat2: 34.40,  lng1: 131.10,  lng2: 131.60 } },
  { name: '山口県西部',    bbox: { lat1: 34.00,  lat2: 34.40,  lng1: 130.50,  lng2: 131.10 } },
  { name: '徳島県北部',    bbox: { lat1: 33.90,  lat2: 34.20,  lng1: 134.10,  lng2: 134.60 } },
  { name: '徳島県南部',    bbox: { lat1: 33.50,  lat2: 33.90,  lng1: 134.10,  lng2: 134.70 } },
  { name: '香川県',        bbox: { lat1: 34.00,  lat2: 34.40,  lng1: 133.60,  lng2: 134.40 } },
  { name: '香川県東部',    bbox: { lat1: 34.10,  lat2: 34.40,  lng1: 134.10,  lng2: 134.40 } },
  { name: '香川県西部',    bbox: { lat1: 34.00,  lat2: 34.30,  lng1: 133.60,  lng2: 134.10 } },
  { name: '愛媛県東予',    bbox: { lat1: 33.80,  lat2: 34.10,  lng1: 133.00,  lng2: 133.60 } },
  { name: '愛媛県中予',    bbox: { lat1: 33.70,  lat2: 33.95,  lng1: 132.50,  lng2: 132.90 } },
  { name: '愛媛県南予',    bbox: { lat1: 32.80,  lat2: 33.60,  lng1: 132.30,  lng2: 132.90 } },
  { name: '高知県東部',    bbox: { lat1: 33.30,  lat2: 33.60,  lng1: 134.00,  lng2: 134.40 } },
  { name: '高知県中部',    bbox: { lat1: 33.30,  lat2: 33.70,  lng1: 133.40,  lng2: 134.00 } },
  { name: '高知県西部',    bbox: { lat1: 32.90,  lat2: 33.40,  lng1: 132.70,  lng2: 133.50 } },
  { name: '福岡県',        bbox: { lat1: 33.30,  lat2: 33.90,  lng1: 130.20,  lng2: 130.70 } },
  { name: '福岡県北九州',  bbox: { lat1: 33.70,  lat2: 33.95,  lng1: 130.85,  lng2: 131.10 } },
  { name: '佐賀県',        bbox: { lat1: 33.00,  lat2: 33.50,  lng1: 129.80,  lng2: 130.40 } },
  { name: '長崎県北部',    bbox: { lat1: 33.00,  lat2: 33.40,  lng1: 129.50,  lng2: 130.20 } },
  { name: '長崎県南西部',  bbox: { lat1: 32.50,  lat2: 33.10,  lng1: 129.50,  lng2: 129.90 } },
  { name: '熊本県熊本地方', bbox:{ lat1: 32.60,  lat2: 33.00,  lng1: 130.50,  lng2: 130.90 } },
  { name: '熊本県天草・芦北', bbox:{ lat1: 32.20, lat2: 32.70,  lng1: 130.00,  lng2: 130.70 } },
  { name: '熊本県球磨',    bbox: { lat1: 32.10,  lat2: 32.40,  lng1: 130.60,  lng2: 131.10 } },
  { name: '大分県北部',    bbox: { lat1: 33.30,  lat2: 33.70,  lng1: 131.10,  lng2: 131.70 } },
  { name: '大分県中部',    bbox: { lat1: 33.00,  lat2: 33.40,  lng1: 131.40,  lng2: 131.80 } },
  { name: '大分県南部',    bbox: { lat1: 32.90,  lat2: 33.30,  lng1: 131.40,  lng2: 131.90 } },
  { name: '宮崎県北部平野部', bbox:{ lat1: 32.10, lat2: 32.60, lng1: 131.40, lng2: 131.70 } },
  { name: '宮崎県北部山沿い', bbox:{ lat1: 32.40, lat2: 32.90, lng1: 131.00, lng2: 131.60 } },
  { name: '宮崎県南部平野部', bbox:{ lat1: 31.60, lat2: 32.10, lng1: 131.30, lng2: 131.60 } },
  { name: '宮崎県南部山沿い', bbox:{ lat1: 31.60, lat2: 32.30, lng1: 130.90, lng2: 131.50 } },
  { name: '鹿児島県薩摩',  bbox: { lat1: 31.10,  lat2: 31.90,  lng1: 130.20,  lng2: 130.90 } },
  { name: '鹿児島県大隅',  bbox: { lat1: 30.90,  lat2: 31.60,  lng1: 130.90,  lng2: 131.50 } },
  { name: '鹿児島湾',      bbox: { lat1: 31.20,  lat2: 31.62,  lng1: 130.50,  lng2: 130.80 } },
  { name: '種子島近海',    bbox: { lat1: 30.10,  lat2: 30.80,  lng1: 130.50,  lng2: 131.20 } },
  { name: '屋久島近海',    bbox: { lat1: 30.10,  lat2: 30.60,  lng1: 130.90,  lng2: 131.60 } },
  { name: '奄美大島近海',  bbox: { lat1: 27.50,  lat2: 28.80,  lng1: 128.30,  lng2: 130.00 } },
  { name: 'トカラ列島近海',    bbox: { lat1: 28.00,  lat2: 28.50,  lng1: 129.60,  lng2: 130.00 } },
  { name: '徳之島近海',    bbox: { lat1: 27.60,  lat2: 28.10,  lng1: 128.80,  lng2: 129.30 } },
  { name: '沖永良部島近海', bbox:{ lat1: 27.20,  lat2: 27.60,  lng1: 128.50,  lng2: 129.00 } },
  { name: '与論島近海',    bbox: { lat1: 27.00,  lat2: 27.20,  lng1: 128.90,  lng2: 129.20 } },

  // ====== 東アジア外縁（図の外枠相当） ======
  { name: '台湾付近',         bbox: { lat1: 22.50, lat2: 25.50, lng1: 120.50, lng2: 122.50 } },
  { name: '黄海',             basin: '東シナ海', bbox: { lat1: 33.00, lat2: 37.00, lng1: 123.00, lng2: 126.00 } },
  { name: '朝鮮半島南部',     bbox: { lat1: 34.00, lat2: 37.00, lng1: 126.00, lng2: 129.00 } },
  { name: '朝鮮半島北部',     bbox: { lat1: 38.00, lat2: 41.00, lng1: 125.00, lng2: 130.00 } },
  { name: '中国東北部',       bbox: { lat1: 41.00, lat2: 46.00, lng1: 122.00, lng2: 127.00 } },
  { name: 'ウラジオストク付近', bbox:{ lat1: 42.00, lat2: 44.00, lng1: 130.50, lng2: 133.00 } },
  { name: 'シベリア南部',     bbox: { lat1: 47.00, lat2: 53.00, lng1: 125.00, lng2: 140.00 } },
  { name: 'フィリピン海北部',  basin: '太平洋', bbox: { lat1: 19.50, lat2: 23.50, lng1: 130.00, lng2: 142.00 } },
  { name: 'マリアナ諸島',     basin: '太平洋', bbox: { lat1: 12.00, lat2: 20.00, lng1: 140.00, lng2: 147.00 } },
];

  function inBBox(lat, lng, bb) {
    return lat >= bb.lat1 && lat <= bb.lat2 && lng >= bb.lng1 && lng <= bb.lng2;
  }

  function nameEpicentralRegion(lat, lng) {
    // 1) BBOX/ポリゴン一致
    for (const r of JMA_REGIONS) {
      if (r.poly && pointInPolygon(lat, lng, r.poly)) return r.name;
      if (r.bbox && inBBox(lat, lng, r.bbox)) return r.name;
      if (r.basin) {
        const b = whichBasin(lat, lng);
        if (b && b === r.basin) {
          if (!r.bbox) return r.name;
          if (inBBox(lat, lng, r.bbox)) return r.name;
        }
      }
    }
    // 2) 近い地域（粗い推定）：重心から最近
    let best = null, bestD = Infinity;
    for (const r of JMA_REGIONS) {
      let c;
      if (r.bbox) {
        c = [(r.bbox.lat1 + r.bbox.lat2) / 2, (r.bbox.lng1 + r.bbox.lng2) / 2];
      } else if (r.poly && r.poly.length) {
        let la = 0, lo = 0;
        r.poly.forEach(p => { la += p[0]; lo += p[1]; });
        c = [la / r.poly.length, lo / r.poly.length];
      } else continue;
      const d = hav(lat, lng, c[0], c[1]);
      if (d < bestD) { bestD = d; best = r.name; }
    }
    return best || '不明';
  }


/* ------------------------------------------------------------
 * Add epicenters / stations （丸ごと置き換え）
 * ---------------------------------------------------------- */
function addEpicAt(lat, lng) {
  if (epicenters.length >= 5) { showOverlay('上限', '震源は最大5つまで。'); return; }
  const M = clampMag(parseFloat(inMag?.value));
  const depth = clampDepth(parseFloat(inDepth?.value));
  const el = document.createElement('div'); el.className = 'epi-dot';
  const marker = L.marker([lat, lng], { draggable: !running, icon: L.divIcon({ html: el, className: '', iconSize: [18, 18] }) }).addTo(map);
  const region = nameEpicentralRegion(lat, lng);
  marker.bindTooltip(`M${M.toFixed(1)} / ${depth.toFixed(1)}km\n${region}`, { direction: 'top', offset: [0, -16] });

  const epi = { id: 'e' + Date.now() + Math.random(), lat, lng, M, depth, marker, pCircle: null, sCircle: null, tCircle: null, _moved: true, region };
  marker.on('dragend', () => {
    if (running) { marker.setLatLng([epi.lat, epi.lng]); return; }
    const ll = marker.getLatLng();
    epi.lat = ll.lat; epi.lng = ll.lng; epi._moved = true;
    epi.region = nameEpicentralRegion(epi.lat, epi.lng);
    marker.closeTooltip(); marker.bindTooltip(`M${epi.M.toFixed(1)} / ${epi.depth.toFixed(1)}km\n${epi.region}`);
    computePredictions();
  });
  marker.on('click', () => {
    if (running || getMode() !== 'TOOL') return;
    const nm = parseFloat(prompt('M?', epi.M));
    const dp = parseFloat(prompt('深さ(km)?', epi.depth));
    if (!isNaN(nm)) epi.M = clampMag(nm);
    if (!isNaN(dp)) epi.depth = clampDepth(dp);
    epi.region = nameEpicentralRegion(epi.lat, epi.lng);
    marker.closeTooltip(); marker.bindTooltip(`M${epi.M.toFixed(1)} / ${epi.depth.toFixed(1)}km\n${epi.region}`);
    computePredictions();
  });

  epicenters.push(epi);
  refreshEpicList();
  computePredictions();
}

function addStationAt(lat, lng, name, showLabel = true, isMajor = false) {
  // 置換版 makeStationHTML（色を渡せるように）
function makeStationHTML(label, countdown, small = false, fillColor = null) {
  const sizeClass = small ? 'station-dot-small' : 'station-dot';
  const style = fillColor ? ` style="background:${fillColor}"` : '';
  return `
    <div class="station-wrap">
      <div class="${sizeClass}"${style}></div>
      ${countdown ? `<div class="countdown-pill">${countdown}</div>` : ''}
      ${label ? `<div class="station-label">${label}</div>` : ''}
    </div>
  `;
}

  const icon = L.divIcon({
  html: makeStationHTML(showLabel && name ? name : '', '', false, null /* 初期色は未設定 */),
  className: '',
  iconSize: [40, 40]
});


  const marker = L.marker([lat, lng], { draggable: !running, icon }).addTo(map);

  const st = {
    id: 's' + Date.now() + Math.random(),
    lat, lng, name,
    marker,
    isMajor,
    spoken: false,
    _moved: true,
    visible: true,
    countdown: '',
    smallMode: false
  };

  marker.on('drag', () => {
    if (running) { marker.setLatLng([st.lat, st.lng]); return; }
    const ll = marker.getLatLng();
    st.lat = ll.lat;
    st.lng = ll.lng;
    st._moved = true;
    canvasDirty = true;
  });
  marker.on('dragend', () => computePredictions());

  marker.on('click', () => {
    if (running || getMode() !== 'TOOL') return;
    const nm = prompt('観測点名', st.name || '');
    if (nm === null) return;
    st.name = nm.trim();
    marker.setIcon(L.divIcon({
      html: makeStationHTML(st.name || '', st.countdown, st.smallMode),
      className: '',
      iconSize: [40, 40]
    }));
    refreshStList();
    canvasDirty = true;
  });

  stations.push(st);
  refreshStList();
  updateCanvasAutoToggle?.();

　st.rt = null; // { sh: '4'|'5弱'|..., idx:0-8, color:'#ff...', ts:number, src:string }

  document.addEventListener('quakeSimStart', () => {
    st.smallMode = true;
    marker.setIcon(L.divIcon({
  html: makeStationHTML(st.name || '', st.countdown, st.smallMode, st.rt?.color || null),
  className: '',
  iconSize: st.smallMode ? [20, 20] : [40, 40]
}));
  });
  document.addEventListener('quakeSimStop', () => {
    st.smallMode = false;
    marker.setIcon(L.divIcon({
      html: makeStationHTML(st.name || '', st.countdown, false),
      className: '',
      iconSize: [40, 40]
    }));
  });
}

/* ---------- ここから追加：重複回避・大量配置ユーティリティ ---------- */

// 近傍重複チェック（km）
function existsNear(lat, lng, km = 5) {
  for (const s of stations) {
    if (!s.visible) continue;
    const d = hav(lat, lng, s.lat, s.lng) / 1000;
    if (d <= km) return true;
  }
  return false;
}

// 陸地フィルタ（isLand が未実装なら常に true）
function passLand(lat, lng) {
  try { return typeof isLand === 'function' ? !!isLand(lat, lng) : true; } catch { return true; }
}

// 追加用ヘルパ：重複せず陸上なら add
function addIfNewLand(lat, lng, name = '', labeled = false, major = false, minDistKm = 5) {
  if (!passLand(lat, lng)) return false;
  if (existsNear(lat, lng, minDistKm)) return false;
  addStationAt(lat, lng, name, labeled && !!name, major);
  return true;
}

/* ---------- 基本セット：主要都市（重複は existsNear で回避） ---------- */
const CORE_MAJOR = [
  { name: '札幌', lat: 43.0618, lng: 141.3545 },
  { name: '仙台', lat: 38.2688, lng: 140.8721 },
  { name: '東京', lat: 35.6812, lng: 139.7671 },
  { name: '横浜', lat: 35.4437, lng: 139.6380 },
  { name: '千葉', lat: 35.6073, lng: 140.1063 },
  { name: 'さいたま', lat: 35.8617, lng: 139.6455 },
  { name: '川崎', lat: 35.5300, lng: 139.7036 },
  { name: '静岡', lat: 34.9769, lng: 138.3831 },
  { name: '名古屋', lat: 35.1815, lng: 136.9066 },
  { name: '京都', lat: 35.0116, lng: 135.7681 },
  { name: '大阪', lat: 34.6937, lng: 135.5023 },
  { name: '神戸', lat: 34.6901, lng: 135.1955 },
  { name: '広島', lat: 34.3853, lng: 132.4553 },
  { name: '岡山', lat: 34.6551, lng: 133.9195 },
  { name: '福岡', lat: 33.5902, lng: 130.4017 },
  { name: '北九州', lat: 33.8830, lng: 130.8753 },
  { name: '熊本', lat: 32.8031, lng: 130.7079 },
  { name: '那覇', lat: 26.2125, lng: 127.6811 }
];

/* ---------- 47都道府県庁所在地（東京は都庁＝新宿区で記載） ---------- */
const PREF_CAPS = [
  { name: '札幌', lat: 43.06417, lng: 141.34694 },
  { name: '青森', lat: 40.82444, lng: 140.74000 },
  { name: '盛岡', lat: 39.70361, lng: 141.15250 },
  { name: '仙台', lat: 38.26889, lng: 140.87194 },
  { name: '秋田', lat: 39.71861, lng: 140.10250 },
  { name: '山形', lat: 38.24056, lng: 140.36333 },
  { name: '福島', lat: 37.75000, lng: 140.46778 },
  { name: '水戸', lat: 36.34139, lng: 140.44667 },
  { name: '宇都宮', lat: 36.56583, lng: 139.88361 },
  { name: '前橋', lat: 36.39111, lng: 139.06083 },
  { name: 'さいたま', lat: 35.85694, lng: 139.64889 },
  { name: '千葉', lat: 35.60472, lng: 140.12333 },
  { name: '新宿区', lat: 35.68944, lng: 139.69167 }, // 東京都庁
  { name: '横浜', lat: 35.44778, lng: 139.64250 },
  { name: '新潟', lat: 37.90222, lng: 139.02361 },
  { name: '富山', lat: 36.69528, lng: 137.21139 },
  { name: '金沢', lat: 36.56111, lng: 136.65639 },
  { name: '福井', lat: 36.06528, lng: 136.22194 },
  { name: '甲府', lat: 35.66389, lng: 138.56833 },
  { name: '長野', lat: 36.65139, lng: 138.18111 },
  { name: '岐阜', lat: 35.39111, lng: 136.72222 },
  { name: '静岡', lat: 34.97694, lng: 138.38306 },
  { name: '名古屋', lat: 35.18147, lng: 136.90641 },
  { name: '津', lat: 34.73028, lng: 136.50861 },
  { name: '大津', lat: 35.00444, lng: 135.86833 },
  { name: '京都', lat: 35.02139, lng: 135.75556 },
  { name: '大阪', lat: 34.68639, lng: 135.52000 },
  { name: '神戸', lat: 34.69139, lng: 135.18306 },
  { name: '奈良', lat: 34.68528, lng: 135.83278 },
  { name: '和歌山', lat: 34.22611, lng: 135.16750 },
  { name: '鳥取', lat: 35.50361, lng: 134.23833 },
  { name: '松江', lat: 35.46806, lng: 133.04861 },
  { name: '岡山', lat: 34.66167, lng: 133.93500 },
  { name: '広島', lat: 34.39639, lng: 132.45944 },
  { name: '山口', lat: 34.18583, lng: 131.47139 },
  { name: '徳島', lat: 34.06583, lng: 134.55944 },
  { name: '高松', lat: 34.34028, lng: 134.04333 },
  { name: '松山', lat: 33.84167, lng: 132.76611 },
  { name: '高知', lat: 33.55972, lng: 133.53111 },
  { name: '福岡', lat: 33.59028, lng: 130.40194 },
  { name: '佐賀', lat: 33.24944, lng: 130.29889 },
  { name: '長崎', lat: 32.74472, lng: 129.87361 },
  { name: '熊本', lat: 32.78972, lng: 130.74167 },
  { name: '大分', lat: 33.23806, lng: 131.61250 },
  { name: '宮崎', lat: 31.91111, lng: 131.42389 },
  { name: '鹿児島', lat: 31.56028, lng: 130.55806 },
  { name: '那覇', lat: 26.21250, lng: 127.68111 }
];

/* ---------- 主要都市の追加セット（抜粋） ---------- */
const EXTRA_CITIES = [
  // 北海道・東北
  { name: '旭川', lat: 43.7687, lng: 142.3650 }, { name: '函館', lat: 41.7687, lng: 140.7288 },
  { name: '釧路', lat: 42.9849, lng: 144.3814 }, { name: '帯広', lat: 42.9236, lng: 143.1969 },
  { name: '苫小牧', lat: 42.6341, lng: 141.6050 }, { name: '小樽', lat: 43.1907, lng: 140.9947 },
  { name: '室蘭', lat: 42.3152, lng: 140.9737 }, { name: '北見', lat: 43.8031, lng: 143.8950 },
  { name: '青森市東', lat: 40.8399, lng: 140.8035 }, { name: '八戸', lat: 40.5123, lng: 141.4886 },
  { name: '弘前', lat: 40.6031, lng: 140.4649 }, { name: '石巻', lat: 38.4345, lng: 141.3027 },
  { name: '郡山', lat: 37.3983, lng: 140.3845 }, { name: 'いわき', lat: 37.0504, lng: 140.8877 },
  // 関東周辺
  { name: '高崎', lat: 36.3219, lng: 139.0033 }, { name: '川越', lat: 35.9081, lng: 139.4856 },
  { name: '所沢', lat: 35.7921, lng: 139.4690 }, { name: '熊谷', lat: 36.1473, lng: 139.3880 },
  { name: '柏', lat: 35.8679, lng: 139.9756 }, { name: '船橋', lat: 35.6940, lng: 139.9826 },
  { name: '市川', lat: 35.7289, lng: 139.9312 }, { name: '松戸', lat: 35.7830, lng: 139.8970 },
  { name: '八王子', lat: 35.6550, lng: 139.3380 }, { name: '立川', lat: 35.7138, lng: 139.4070 },
  { name: '町田', lat: 35.5469, lng: 139.4380 }, { name: '横須賀', lat: 35.2810, lng: 139.6722 },
  { name: '藤沢', lat: 35.3396, lng: 139.4917 }, { name: '平塚', lat: 35.3273, lng: 139.3497 },
  { name: '相模原', lat: 35.5714, lng: 139.3730 },
  // 中部
  { name: '浜松', lat: 34.7108, lng: 137.7261 }, { name: '豊橋', lat: 34.7692, lng: 137.3916 },
  { name: '岡崎', lat: 34.9546, lng: 137.1706 }, { name: '豊田', lat: 35.0844, lng: 137.1563 },
  { name: '一宮', lat: 35.3039, lng: 136.8031 }, { name: '長岡', lat: 37.4460, lng: 138.8512 },
  { name: '甲府南', lat: 35.6200, lng: 138.5680 },
  // 近畿
  { name: '堺', lat: 34.5733, lng: 135.4828 }, { name: '東大阪', lat: 34.6794, lng: 135.6000 },
  { name: '枚方', lat: 34.8143, lng: 135.6500 }, { name: '西宮', lat: 34.7376, lng: 135.3416 },
  { name: '尼崎', lat: 34.7335, lng: 135.4170 }, { name: '姫路', lat: 34.8151, lng: 134.6853 },
  { name: '和歌山市北', lat: 34.2650, lng: 135.1800 },
  // 中国・四国
  { name: '倉敷', lat: 34.5850, lng: 133.7719 }, { name: '福山', lat: 34.4859, lng: 133.3623 },
  { name: '呉', lat: 34.2464, lng: 132.5650 }, { name: '下関', lat: 33.9578, lng: 130.9411 },
  { name: '今治', lat: 34.0667, lng: 132.9978 }, { name: '新居浜', lat: 33.9603, lng: 133.2830 },
  { name: '丸亀', lat: 34.2902, lng: 133.7984 }, { name: '鳴門', lat: 34.1727, lng: 134.6097 },
  // 九州・沖縄
  { name: '久留米', lat: 33.3193, lng: 130.5080 }, { name: '佐世保', lat: 33.1591, lng: 129.7227 },
  { name: '八代', lat: 32.5074, lng: 130.6010 }, { name: '延岡', lat: 32.5821, lng: 131.6657 },
  { name: '都城', lat: 31.7196, lng: 131.0615 }, { name: '霧島', lat: 31.7419, lng: 130.7636 },
  { name: '浦添', lat: 26.2456, lng: 127.7224 }, { name: '沖縄市', lat: 26.3344, lng: 127.8056 }
];

/* ---------- 無名ポイントを全国に散布（約300点） ---------- */
function seedExtraStations(count = 300, minDistKm = 6) {
  const BB = [
    {lat1:41.2, lat2:45.8, lng1:139.2, lng2:146.0}, // 北海道
    {lat1:38.0, lat2:40.9, lng1:139.0, lng2:142.2}, // 東北北
    {lat1:35.0, lat2:38.0, lng1:136.0, lng2:141.5}, // 東北南+関東北
    {lat1:34.5, lat2:36.8, lng1:138.0, lng2:141.2}, // 関東
    {lat1:34.0, lat2:37.2, lng1:136.0, lng2:138.8}, // 中部
    {lat1:34.0, lat2:36.2, lng1:131.0, lng2:135.8}, // 中国
    {lat1:33.1, lat2:34.8, lng1:133.0, lng2:134.9}, // 四国
    {lat1:31.0, lat2:33.6, lng1:130.0, lng2:132.2}, // 九州北
    {lat1:30.0, lat2:32.4, lng1:129.0, lng2:131.2}, // 九州南
    {lat1:24.0, lat2:27.2, lng1:123.0, lng2:128.6}, // 南西諸島
  ];
  let added = 0, guard = 0;
  while (added < count && guard < count * 40) {
    guard++;
    const r = BB[(Math.random() * BB.length) | 0];
    const lat = r.lat1 + Math.random() * (r.lat2 - r.lat1);
    const lng = r.lng1 + Math.random() * (r.lng2 - r.lng1);
    if (!passLand(lat, lng)) continue;
    if (existsNear(lat, lng, minDistKm)) continue;
    addStationAt(lat, lng, '', false, false);
    added++;
  }
}

/* =========================  全国 名前付きステーション — 完全版  =========================
   貼り付け位置：観測点ユーティリティ（existsNear / addIfNewLand など）より後、
                 preloadStations() より前。
   使い方：preloadStations() の末尾で
           addNamedCSV(JP_STATIONS_CSV, { minDistKm: 4, label: true });
           // 既存の seedExtraStations(300,6) はオフ推奨（重くなるため）
======================================================================================== */

/* 1) CSVローダ */
function addNamedCSV(csv, opts = {}) {
  const minDistKm = isFinite(opts.minDistKm) ? opts.minDistKm : 4;
  const label = opts.label !== false;
  let added = 0, skipped = 0;

  const lines = csv.trim().split(/\r?\n/);
  for (const line of lines) {
    if (!line || line.startsWith('#') || line.startsWith('pref,')) continue;
    const cols = line.split(',').map(s => s.trim());
    if (cols.length < 4) continue;
    const [pref, name, la, lo] = cols;
    const lat = parseFloat(la), lng = parseFloat(lo);
    if (!isFinite(lat) || !isFinite(lng)) { skipped++; continue; }
    // 県名はラベルに含めない（見た目をスッキリ）。必要なら `${pref}・${name}`
    if (addIfNewLand(lat, lng, name, label, false, minDistKm)) added++;
    else skipped++;
  }
  console.log(`[JP_STATIONS] added=${added} skipped=${skipped}`);
}

/* 2) 全国CSV（pref,name,lat,lng）— 1県 10～15件目安。特指：伊豆半島/諸島・能登半島・トカラ等 充実。 */
const JP_STATIONS_CSV = `
pref,name,lat,lng
# ==== 北海道・東北 =========================================================
北海道,札幌,43.061,141.354
北海道,小樽,43.190,140.995
北海道,旭川,43.768,142.365
北海道,函館,41.768,140.728
北海道,帯広,42.923,143.196
北海道,釧路,42.984,144.381
北海道,北見,43.803,143.895
北海道,網走,44.020,144.273
北海道,室蘭,42.315,140.973
北海道,苫小牧,42.634,141.605
北海道,稚内,45.415,141.673
北海道,根室,43.330,145.585

青森県,青森,40.824,140.740
青森県,弘前,40.603,140.465
青森県,八戸,40.512,141.488
青森県,五所川原,40.807,140.444
青森県,十和田,40.612,141.213
青森県,むつ,41.292,141.216
青森県,三沢,40.683,141.368
青森県,黒石,40.645,140.594
青森県,つがる,40.807,140.383
青森県,野辺地,40.864,141.126

岩手県,盛岡,39.703,141.152
岩手県,花巻,39.387,141.116
岩手県,北上,39.286,141.114
岩手県,一関,38.934,141.126
岩手県,奥州,39.145,141.134
岩手県,久慈,40.190,141.764
岩手県,宮古,39.641,141.956
岩手県,大船渡,39.071,141.708
岩手県,釜石,39.275,141.885
岩手県,二戸,40.291,141.304

宮城県,仙台,38.268,140.872
宮城県,石巻,38.434,141.302
宮城県,気仙沼,38.909,141.566
宮城県,塩竈,38.322,141.022
宮城県,多賀城,38.296,141.002
宮城県,名取,38.171,140.891
宮城県,白石,38.003,140.622
宮城県,大崎(古川),38.571,140.955
宮城県,登米,38.688,141.190
宮城県,栗原,38.734,141.020

秋田県,秋田,39.718,140.102
秋田県,能代,40.210,140.024
秋田県,大館,40.270,140.566
秋田県,北秋田,40.224,140.371
秋田県,鹿角,40.214,140.788
秋田県,横手,39.313,140.557
秋田県,大仙,39.452,140.467
秋田県,由利本荘,39.390,140.047
秋田県,にかほ,39.208,139.908
秋田県,男鹿,39.889,139.845

山形県,山形,38.240,140.363
山形県,米沢,37.922,140.116
山形県,鶴岡,38.727,139.826
山形県,酒田,38.915,139.843
山形県,新庄,38.764,140.300
山形県,天童,38.353,140.374
山形県,寒河江,38.381,140.280
山形県,上山,38.151,140.273
山形県,長井,38.107,140.035
山形県,南陽,38.047,140.157

福島県,福島,37.750,140.467
福島県,郡山,37.400,140.383
福島県,いわき,37.050,140.887
福島県,会津若松,37.494,139.929
福島県,白河,37.125,140.211
福島県,須賀川,37.289,140.374
福島県,相馬,37.796,140.957
福島県,南相馬,37.642,140.957
福島県,二本松,37.586,140.428
福島県,喜多方,37.651,139.860

# ==== 関東 =================================================================
茨城県,水戸,36.341,140.447
茨城県,つくば,36.082,140.110
茨城県,日立,36.596,140.659
茨城県,土浦,36.072,140.203
茨城県,ひたちなか,36.391,140.534
茨城県,取手,35.897,140.060
茨城県,牛久,35.979,140.147
茨城県,古河,36.192,139.709
茨城県,鹿嶋,35.965,140.644
茨城県,常陸太田,36.540,140.531

栃木県,宇都宮,36.565,139.883
栃木県,小山,36.314,139.800
栃木県,栃木,36.375,139.733
栃木県,佐野,36.314,139.582
栃木県,足利,36.340,139.451
栃木県,那須塩原,36.961,140.047
栃木県,大田原,36.871,140.016
栃木県,真岡,36.441,140.013
栃木県,鹿沼,36.567,139.742
栃木県,日光,36.720,139.698

群馬県,前橋,36.391,139.061
群馬県,高崎,36.322,139.010
群馬県,伊勢崎,36.321,139.196
群馬県,太田,36.295,139.377
群馬県,桐生,36.405,139.334
群馬県,館林,36.245,139.536
群馬県,渋川,36.488,139.002
群馬県,藤岡,36.250,139.073
群馬県,富岡,36.258,138.891
群馬県,沼田,36.648,139.040

埼玉県,さいたま,35.856,139.648
埼玉県,川越,35.925,139.485
埼玉県,熊谷,36.147,139.388
埼玉県,所沢,35.799,139.467
埼玉県,越谷,35.892,139.789
埼玉県,川口,35.803,139.724
埼玉県,春日部,35.976,139.748
埼玉県,草加,35.825,139.804
埼玉県,八潮,35.822,139.839
埼玉県,朝霞,35.789,139.593

千葉県,千葉,35.604,140.123
千葉県,船橋,35.694,139.983
千葉県,市川,35.721,139.931
千葉県,松戸,35.784,139.900
千葉県,柏,35.868,139.975
千葉県,市原,35.489,140.108
千葉県,木更津,35.378,139.923
千葉県,成田,35.776,140.318
千葉県,佐倉,35.723,140.224
千葉県,銚子,35.734,140.826

東京都,新宿区(都庁),35.689,139.692
東京都,渋谷,35.659,139.700
東京都,品川,35.609,139.730
東京都,世田谷,35.646,139.653
東京都,練馬,35.735,139.651
東京都,立川,35.713,139.407
東京都,八王子,35.655,139.338
東京都,町田,35.546,139.438
東京都,調布,35.650,139.540
東京都,青梅,35.788,139.275
# 伊豆諸島・小笠原
東京都,大島(伊豆大島),34.750,139.360
東京都,新島,34.372,139.265
東京都,神津島,34.214,139.140
東京都,三宅島,34.078,139.533
東京都,御蔵島,33.900,139.600
東京都,八丈島,33.115,139.785
東京都,青ヶ島,32.467,139.767
東京都,父島(小笠原),27.094,142.191
東京都,母島(小笠原),26.630,142.170
東京都,奥多摩,35.809,139.096

神奈川県,横浜,35.447,139.642
神奈川県,川崎,35.530,139.703
神奈川県,相模原,35.571,139.373
神奈川県,鎌倉,35.319,139.550
神奈川県,藤沢,35.339,139.491
神奈川県,横須賀,35.281,139.672
神奈川県,平塚,35.327,139.349
神奈川県,小田原,35.264,139.153
神奈川県,茅ヶ崎,35.334,139.404
神奈川県,厚木,35.443,139.362

# ==== 甲信越・北陸・東海 ================================================
新潟県,新潟,37.902,139.023
新潟県,長岡,37.446,138.851
新潟県,三条,37.635,138.961
新潟県,柏崎,37.370,138.558
新潟県,上越,37.147,138.237
新潟県,糸魚川,37.043,137.861
新潟県,村上,38.224,139.479
新潟県,燕,37.649,138.883
新潟県,佐渡(両津),38.050,138.433
新潟県,南魚沼,37.065,138.877

富山県,富山,36.695,137.211
富山県,高岡,36.739,137.021
富山県,魚津,36.827,137.410
富山県,滑川,36.764,137.369
富山県,砺波,36.647,136.962
富山県,小矢部,36.673,136.868
富山県,氷見,36.855,136.986
富山県,黒部,36.871,137.449
富山県,射水,36.732,137.096
富山県,立山(上市),36.691,137.361

石川県,金沢,36.561,136.656
石川県,白山,36.517,136.566
石川県,小松,36.408,136.445
石川県,加賀,36.303,136.315
石川県,野々市,36.527,136.609
# 能登半島 充実
石川県,七尾,37.045,136.967
石川県,輪島,37.390,136.900
石川県,珠洲,37.434,137.266
石川県,穴水,37.228,136.900
石川県,志賀(富来),37.010,136.778
石川県,中能登,36.985,136.905
石川県,能登町(宇出津),37.307,137.144

福井県,福井,36.065,136.222
福井県,鯖江,35.956,136.184
福井県,越前市,35.903,136.169
福井県,敦賀,35.646,136.055
福井県,小浜,35.495,135.746
福井県,坂井,36.171,136.231
福井県,あわら,36.211,136.225
福井県,勝山,36.060,136.500
福井県,大野,35.980,136.487
福井県,永平寺,36.093,136.306

山梨県,甲府,35.664,138.568
山梨県,富士吉田,35.487,138.807
山梨県,都留,35.554,138.909
山梨県,大月,35.611,138.945
山梨県,山梨(山梨市),35.694,138.686
山梨県,笛吹,35.650,138.633
山梨県,北杜(小淵沢),35.866,138.298
山梨県,韮崎,35.706,138.443
山梨県,南アルプス,35.605,138.464
山梨県,甲斐,35.667,138.531

長野県,長野,36.651,138.181
長野県,松本,36.238,137.971
長野県,上田,36.401,138.249
長野県,佐久,36.246,138.476
長野県,諏訪(上諏訪),36.041,138.114
長野県,岡谷,36.056,138.044
長野県,飯田,35.514,137.822
長野県,伊那,35.826,137.953
長野県,大町,36.503,137.855
長野県,木曽福島,35.844,137.690

岐阜県,岐阜,35.391,136.722
岐阜県,大垣,35.359,136.612
岐阜県,各務原,35.398,136.848
岐阜県,多治見,35.332,137.132
岐阜県,可児,35.425,137.057
岐阜県,中津川,35.487,137.500
岐阜県,高山,36.146,137.251
岐阜県,飛騨古川,36.228,137.190
岐阜県,関,35.499,136.918
岐阜県,郡上八幡,35.740,136.962

静岡県,静岡,34.977,138.383
静岡県,浜松,34.710,137.727
静岡県,富士,35.161,138.676
静岡県,沼津,35.104,138.863
静岡県,三島,35.118,138.918
静岡県,焼津,34.872,138.327
静岡県,藤枝,34.868,138.257
# 伊豆半島 充実
静岡県,熱海,35.097,139.077
静岡県,伊東,34.965,139.083
静岡県,下田,34.681,138.946
静岡県,南伊豆(下賀茂),34.650,138.855
静岡県,松崎,34.751,138.778
静岡県,河津,34.747,138.992
静岡県,伊豆市(修善寺),34.983,138.940
静岡県,東伊豆(稲取),34.769,139.043
静岡県,西伊豆(土肥),34.897,138.773

愛知県,名古屋,35.181,136.906
愛知県,豊橋,34.769,137.391
愛知県,岡崎,34.954,137.170
愛知県,一宮,35.303,136.803
愛知県,春日井,35.247,136.972
愛知県,豊田,35.084,137.156
愛知県,安城,34.958,137.080
愛知県,刈谷,34.989,137.003
愛知県,西尾,34.867,137.061
愛知県,半田,34.891,136.926

三重県,津,34.730,136.508
三重県,四日市,34.965,136.624
三重県,松阪,34.578,136.527
三重県,桑名,35.069,136.684
三重県,鈴鹿,34.882,136.584
三重県,伊賀(上野),34.768,136.131
# 伊勢志摩 充実
三重県,伊勢,34.487,136.709
三重県,鳥羽,34.483,136.845
三重県,志摩(阿児),34.330,136.828
三重県,南伊勢,34.370,136.682
三重県,熊野,33.889,136.098

# ==== 近畿 =================================================================
滋賀県,大津,35.004,135.868
滋賀県,草津,35.019,135.962
滋賀県,長浜,35.377,136.269
滋賀県,彦根,35.275,136.259
滋賀県,近江八幡,35.128,136.098
滋賀県,守山,35.060,135.995
滋賀県,甲賀(水口),34.966,136.167
滋賀県,高島,35.349,136.034
滋賀県,東近江,35.112,136.194
滋賀県,米原,35.315,136.292

京都府,京都,35.021,135.755
京都府,宇治,34.884,135.803
京都府,亀岡,35.013,135.574
京都府,福知山,35.296,135.126
京都府,綾部,35.300,135.255
京都府,舞鶴,35.474,135.383
京都府,宮津,35.534,135.195
京都府,京田辺,34.814,135.768
京都府,長岡京,34.931,135.698
京都府,城陽,34.850,135.780

大阪府,大阪,34.686,135.520
大阪府,堺,34.573,135.483
大阪府,東大阪,34.679,135.600
大阪府,豊中,34.781,135.469
大阪府,吹田,34.761,135.516
大阪府,枚方,34.814,135.650
大阪府,高槻,34.852,135.617
大阪府,八尾,34.626,135.601
大阪府,岸和田,34.457,135.373
大阪府,茨木,34.816,135.568

兵庫県,神戸,34.691,135.183
兵庫県,姫路,34.815,134.686
兵庫県,西宮,34.737,135.342
兵庫県,尼崎,34.733,135.417
兵庫県,明石,34.650,134.997
兵庫県,伊丹,34.784,135.438
兵庫県,加古川,34.765,134.835
兵庫県,宝塚,34.803,135.356
兵庫県,洲本(淡路島),34.343,134.914
兵庫県,南あわじ,34.238,134.778
兵庫県,豊岡,35.544,134.820
兵庫県,丹波篠山,35.066,135.219

奈良県,奈良,34.685,135.833
奈良県,橿原,34.512,135.792
奈良県,生駒,34.692,135.700
奈良県,大和郡山,34.649,135.782
奈良県,天理,34.596,135.838
奈良県,御所,34.458,135.708
奈良県,五條,34.352,135.694
奈良県,桜井,34.518,135.848
奈良県,香芝,34.546,135.700
奈良県,大和高田,34.514,135.737

和歌山県,和歌山,34.226,135.168
和歌山県,海南,34.155,135.206
和歌山県,橋本,34.315,135.604
和歌山県,紀の川,34.269,135.358
和歌山県,有田,34.089,135.130
和歌山県,御坊,33.892,135.155
和歌山県,田辺,33.728,135.377
和歌山県,新宮,33.724,135.992
和歌山県,串本,33.472,135.783
和歌山県,白浜,33.678,135.346

# ==== 中国・四国 ==========================================================
鳥取県,鳥取,35.503,134.238
鳥取県,米子,35.428,133.331
鳥取県,境港,35.541,133.231
鳥取県,倉吉,35.432,133.822
鳥取県,岩美,35.576,134.332
鳥取県,八頭,35.397,134.237
鳥取県,琴浦,35.490,133.669
鳥取県,北栄,35.488,133.752
鳥取県,日吉津,35.434,133.305
鳥取県,大山,35.371,133.546

島根県,松江,35.468,133.049
島根県,出雲,35.368,132.754
島根県,浜田,34.899,132.079
島根県,益田,34.675,131.843
島根県,雲南,35.361,132.910
島根県,大田,35.192,132.500
島根県,江津,35.013,132.222
島根県,安来,35.429,133.254
島根県,隠岐(西郷),36.208,133.331
島根県,津和野,34.460,131.773

岡山県,岡山,34.662,133.935
岡山県,倉敷,34.585,133.772
岡山県,津山,35.068,134.004
岡山県,総社,34.675,133.746
岡山県,玉野,34.494,133.945
岡山県,笠岡,34.507,133.507
岡山県,備前,34.756,134.190
岡山県,真庭(久世),35.078,133.751
岡山県,浅口(鴨方),34.544,133.583
岡山県,赤磐,34.803,134.037

広島県,広島,34.396,132.459
広島県,福山,34.485,133.362
広島県,呉,34.246,132.565
広島県,東広島(西条),34.428,132.743
広島県,尾道,34.408,133.205
広島県,三原,34.396,133.083
広島県,竹原,34.341,132.907
広島県,廿日市,34.348,132.331
広島県,府中,34.572,133.235
広島県,庄原,34.857,133.015

山口県,山口,34.186,131.471
山口県,下関,33.957,130.941
山口県,宇部,33.951,131.246
山口県,山陽小野田,34.000,131.178
山口県,防府,34.051,131.564
山口県,周南(徳山),34.051,131.806
山口県,岩国,34.166,132.219
山口県,柳井,33.963,132.101
山口県,萩,34.408,131.399
山口県,長門,34.371,131.184

徳島県,徳島,34.065,134.559
徳島県,鳴門,34.172,134.610
徳島県,阿南,33.920,134.654
徳島県,吉野川,34.072,134.355
徳島県,小松島,34.000,134.590
徳島県,美馬,34.059,134.164
徳島県,三好(池田),34.026,133.807
徳島県,つるぎ,34.037,134.067
徳島県,海陽,33.574,134.277
徳島県,石井,34.073,134.452

香川県,高松,34.340,134.043
香川県,丸亀,34.291,133.798
香川県,坂出,34.322,133.860
香川県,善通寺,34.226,133.792
香川県,観音寺,34.124,133.661
香川県,三豊,34.041,133.652
香川県,さぬき,34.330,134.182
香川県,東かがわ,34.239,134.354
香川県,多度津,34.272,133.751
香川県,宇多津,34.310,133.821

愛媛県,松山,33.841,132.766
愛媛県,今治,34.066,132.998
愛媛県,新居浜,33.960,133.283
愛媛県,西条,33.917,133.181
愛媛県,四国中央,33.980,133.549
愛媛県,伊予,33.757,132.703
愛媛県,大洲,33.502,132.546
愛媛県,八幡浜,33.461,132.425
愛媛県,宇和島,33.223,132.560
愛媛県,内子,33.534,132.658

高知県,高知,33.559,133.531
高知県,南国,33.575,133.641
高知県,土佐,33.496,133.425
高知県,須崎,33.402,133.284
高知県,四万十(中村),32.989,132.933
高知県,宿毛,32.938,132.731
高知県,香南,33.563,133.702
高知県,香美,33.603,133.700
高知県,安芸,33.501,133.906
高知県,いの,33.551,133.428

# ==== 九州・沖縄 ==========================================================
福岡県,福岡,33.590,130.401
福岡県,北九州(小倉),33.883,130.875
福岡県,久留米,33.319,130.508
福岡県,飯塚,33.645,130.689
福岡県,田川,33.642,130.806
福岡県,直方,33.744,130.734
福岡県,筑紫野,33.495,130.523
福岡県,大牟田,33.030,130.446
福岡県,行橋,33.728,130.983
福岡県,宗像,33.797,130.540

佐賀県,佐賀,33.249,130.299
佐賀県,唐津,33.447,129.968
佐賀県,鳥栖,33.376,130.504
佐賀県,伊万里,33.264,129.880
佐賀県,武雄,33.196,130.021
佐賀県,鹿島,33.106,130.101
佐賀県,小城,33.288,130.196
佐賀県,嬉野,33.127,129.994
佐賀県,多久,33.287,130.105
佐賀県,基山,33.430,130.516

長崎県,長崎,32.744,129.874
長崎県,佐世保,33.159,129.723
長崎県,諫早,32.847,130.047
長崎県,大村,32.900,129.957
長崎県,島原,32.788,130.371
長崎県,雲仙(小浜),32.723,130.189
長崎県,平戸,33.371,129.553
長崎県,対馬(厳原),34.203,129.287
長崎県,壱岐(郷ノ浦),33.747,129.692
長崎県,五島(福江),32.695,128.841
長崎県,新上五島(有川),32.993,129.077
長崎県,松浦,33.345,129.714

熊本県,熊本,32.789,130.742
熊本県,八代,32.507,130.601
熊本県,人吉,32.216,130.758
熊本県,天草(本渡),32.455,130.197
熊本県,玉名,32.931,130.565
熊本県,山鹿,33.008,130.691
熊本県,宇土,32.682,130.667
熊本県,宇城,32.651,130.688
熊本県,阿蘇,32.954,131.123
熊本県,菊池,32.979,130.814

大分県,大分,33.238,131.613
大分県,別府,33.279,131.497
大分県,中津,33.598,131.188
大分県,日田,33.318,130.940
大分県,佐伯,32.960,131.901
大分県,臼杵,33.122,131.804
大分県,津久見,33.073,131.862
大分県,豊後高田,33.558,131.447
大分県,杵築,33.418,131.616
大分県,宇佐,33.531,131.357

宮崎県,宮崎,31.911,131.424
宮崎県,都城,31.719,131.062
宮崎県,延岡,32.582,131.666
宮崎県,日向,32.423,131.624
宮崎県,日南,31.602,131.364
宮崎県,小林,31.996,130.974
宮崎県,えびの,32.048,130.812
宮崎県,高鍋,32.127,131.499
宮崎県,串間,31.462,131.228
宮崎県,西都,32.108,131.401

鹿児島県,鹿児島,31.560,130.558
鹿児島県,霧島,31.741,130.764
鹿児島県,指宿,31.252,130.632
鹿児島県,薩摩川内,31.814,130.303
鹿児島県,出水,32.089,130.353
鹿児島県,阿久根,32.015,130.197
鹿児島県,枕崎,31.272,130.311
鹿児島県,加世田(南さつま),31.416,130.322
鹿児島県,志布志,31.493,131.099
鹿児島県,鹿屋,31.378,130.852
# トカラ列島・大隅/薩南諸島まで拡充
鹿児島県,口之島(トカラ),29.957,129.931
鹿児島県,中之島(トカラ),29.855,129.872
鹿児島県,臥蛇島(トカラ),29.834,129.590
鹿児島県,悪石島(トカラ),29.425,129.592
鹿児島県,小宝島(トカラ),29.140,129.322
鹿児島県,宝島(トカラ),29.130,129.212
鹿児島県,諏訪之瀬島(トカラ),29.638,129.717
鹿児島県,屋久島(宮之浦),30.336,130.526
鹿児島県,種子島(西之表),30.733,131.002
鹿児島県,奄美大島(名瀬),28.377,129.498

沖縄県,那覇,26.212,127.681
沖縄県,浦添,26.245,127.722
沖縄県,宜野湾,26.281,127.778
沖縄県,沖縄市,26.335,127.806
沖縄県,うるま,26.385,127.851
沖縄県,名護,26.592,127.977
沖縄県,糸満,26.124,127.668
沖縄県,豊見城,26.184,127.669
沖縄県,石垣島(石垣),24.340,124.157
沖縄県,宮古島(平良),24.806,125.281
沖縄県,多良間,24.661,124.704
沖縄県,与那国,24.468,123.004
沖縄県,西表島(大原),24.296,123.891
沖縄県,波照間,24.062,123.786
沖縄県,久米島,26.340,126.755
沖縄県,伊江島,26.715,127.804
沖縄県,伊是名島,26.928,127.950
沖縄県,伊平屋島,27.039,127.974
`;
/* ========================= ここまで：全国 名前付きステーション ========================= */

// ★ 呼び出し例（preloadStationsの末尾あたりに1行追加）
// addNamedCSV(JP_STATIONS_CSV, { minDistKm: 4, label: true });


/* ---------- 一括生成（主要都市＋庁所在地＋追加都市＋無名300） ---------- */
function preloadStations() {
  // 主要・庁所在地
  for (const c of CORE_MAJOR) addIfNewLand(c.lat, c.lng, c.name, true, true, 5);
  for (const c of PREF_CAPS)  addIfNewLand(c.lat, c.lng, c.name, true, true, 5);

  // 点数が多いのでキャンバス描画を確実にON
  if (typeof enableCanvasStations === 'function') enableCanvasStations(true);
  updateCanvasAutoToggle?.();
  if (typeof canvasDirty !== 'undefined') canvasDirty = true;
}
/* --------- 置き換えここまで --------- */

/*
使い方（initMap 内の流れ例）:
  heatLayer.addTo(map);
  preloadStations(); // ← 主要都市＋47都道府県庁所在地＋追加都市＋無名300
  updateHud();
*/

// ====== リアルタイム観測震度 反映ユーティリティ ======
function jmaStrToIdx(sh) {
  // 震度→インデックス（あなたの colorForIdx/palette に合わせて 0..8）
  const m = (sh + '').replace(/\s/g,'');
  const table = {
    '0':0,'１':1,'1':1,'２':2,'2':2,'３':3,'3':3,'４':4,'4':4,
    '５弱':'5-','5弱':'5-','５強':'5+','5強':'5+','６弱':'6-','6弱':'6-',
    '６強':'6+','6強':'6+','７':8,'7':8
  };
  if (table[m]===0) return 0;
  if (table[m]===1) return 1;
  if (table[m]===2) return 2;
  if (table[m]===3) return 3;
  if (table[m]===4) return 4;
  if (table[m]==='5-') return 5;
  if (table[m]==='5+') return 6;
  if (table[m]==='6-') return 7;
  if (table[m]==='6+') return 8;
  if (m.includes('5') && m.includes('弱')) return 5;
  if (m.includes('5') && m.includes('強')) return 6;
  if (m.includes('6') && m.includes('弱')) return 7;
  if (m.includes('6') && m.includes('強')) return 8;
  const n = Number(m);
  if (Number.isFinite(n)) return Math.max(0, Math.min(8, n));
  return 0;
}
function jmaStrToColor(sh) {
  return colorForIdx( jmaStrToIdx(sh) );
}

// 名前ゆる一致（全角・半角・空白と「市/区」等を無視）
function normName(s){
  return (s || '')
    .replace(/[ 　\t]/g,'')
    .replace(/[市区町村郡]|[‐\-ー−]/g,'')
    .toLowerCase();
}

// 観測点検索：code→name→最近傍（lat/lng有り）の順で探す
function findStationByKey({code, name, lat, lng}) {
  // 1) code 完全一致
  if (code) {
    const hit = stations.find(s => s.code && s.code === code);
    if (hit) return hit;
  }
  // 2) name ゆる一致
  if (name) {
    const nn = normName(name);
    let hit = stations.find(s => normName(s.name) === nn);
    if (hit) return hit;
    // 部分一致も一応
    hit = stations.find(s => normName(s.name).includes(nn) || nn.includes(normName(s.name)));
    if (hit) return hit;
  }
  // 3) 最近傍（15km以内）
  if (Number.isFinite(lat) && Number.isFinite(lng)) {
    let best = null, bestD = 1e9;
    for (const s of stations) {
      const d = hav(lat, lng, s.lat, s.lng) / 1000;
      if (d < bestD) { bestD = d; best = s; }
    }
    if (best && bestD <= 15) return best;
  }
  return null;
}

// 観測点へリアル震度を反映
function applyRealtimeIntensity(point) {
  // point: { code?, name?, lat?, lng?, shindo:'4'|'5弱'|..., ts? }
  const s = findStationByKey(point);
  if (!s) return false;

  const sh = point.shindo;
  const idx = jmaStrToIdx(sh);
  const color = jmaStrToColor(sh);

  s.rt = { sh, idx, color, ts: point.ts || Date.now(), src: 'WS' };
  s._lastBadge = sh;       // バッジに震度文字列（例 '5弱'）
  s.spoken = false;        // まだ読み上げていなければ喋らせるためのフラグ
  canvasDirty = true;

  // DOMアイコン（Canvas無効時）も色を更新
  if (!canvasEnabled && s.marker) {
    const small = !!s.smallMode;
    s.marker.setIcon(L.divIcon({
      html: makeStationHTML(s.name || '', s.countdown, small, color),
      className: '',
      iconSize: small ? [20,20] : [40,40]
    }));
  }

  // ログ＆タイムライン
  addLog('I', `${s.name || '観測点'} 震度 ${sh}`);
  try {
    const line = document.createElement('div');
    line.className = 'small';
    line.innerHTML = `<span class="timeline-s">実測</span> ${s.name || '(無名)'} / 震度<b>${sh}</b>`;
    timeline.prepend(line);
  } catch {}

  // TTS（ユーザー操作後・ミュートでない・モードがoff以外）
  if (typeof speakJP === 'function' && !isMuted() && ttsEnabled()) {
    if (!s.spoken) {
      s.spoken = true;
      speakJP(`${s.name || '観測点'}、しんど ${String(sh).replace('弱','じゃく').replace('強','きょう')}`);
    }
  }
  return true;
}


  /* Lists */
  function refreshEpicList() {
    epicList.innerHTML = '';
    if (epicenters.length === 0) { epicList.textContent = '震源なし'; return; }
    epicenters.forEach((e) => {
      const row = document.createElement('div'); row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;margin:4px 0';
      const left = document.createElement('div'); left.innerHTML = `<b>M${e.M.toFixed(1)}</b> / ${e.depth.toFixed(1)}km @ ${e.lat.toFixed(2)},${e.lng.toFixed(2)} <span class="small">[${e.region}]</span>`;
      const right = document.createElement('div');
      const del = document.createElement('button'); del.className = 'ghost'; del.textContent = '削除';
      del.onclick = () => {
        if (e.pCircle) map.removeLayer(e.pCircle);
        if (e.sCircle) map.removeLayer(e.sCircle);
        if (e.tCircle) map.removeLayer(e.tCircle);
        map.removeLayer(e.marker);
        epicenters = epicenters.filter(x => x.id !== e.id);
        computePredictions(); refreshEpicList(); canvasDirty = true;
      };
      right.appendChild(del); row.appendChild(left); row.appendChild(right); epicList.appendChild(row);
    });
  }
  function refreshStList() {
    stList.innerHTML = '';
    if (stations.length === 0) { stList.textContent = '観測点なし'; return; }
    stations.forEach((s) => {
      const nm = s.name && s.name.trim() ? s.name : '(名称なし)';
      const predText = s.pred ? ` <span class="small">/ 予測:${s.pred.jma.sh} P:${s.pred.arrP.toFixed(1)}s S:${s.pred.arrS.toFixed(1)}s${(isFinite(s.pred.arrT) ? ` T:${s.pred.arrT.toFixed(1)}s` : '')}</span>` : '';
      const row = document.createElement('div'); row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;margin:4px 0';
      const left = document.createElement('div'); left.innerHTML = `<b>${nm}</b> <span class="small">@${s.lat.toFixed(3)},${s.lng.toFixed(3)}</span>${predText}`;
      const right = document.createElement('div');
      const del = document.createElement('button'); del.className = 'ghost'; del.textContent = '削除';
      del.onclick = () => {
        if (s.marker) map.removeLayer(s.marker);
        if (s.nameMarker) map.removeLayer(s.nameMarker);
        if (s.countdownMarker) map.removeLayer(s.countdownMarker);
        stations = stations.filter(x => x.id !== s.id); refreshStList(); computePredictions(); canvasDirty = true; updateCanvasAutoToggle();
      };
      right.appendChild(del); row.appendChild(left); row.appendChild(right); stList.appendChild(row);
    });
  }

  /* UI bindings */
  ringVis?.addEventListener('change', () => { ringsOn = (ringVis.value === 'on'); updateRingVisibility(); canvasDirty = true; });
  muteSel?.addEventListener('change', () => { if (!isMuted()) ensureAudio(); });
  modelPreset?.addEventListener('change', () => {
    if (modelPreset.value === 'dStrong') attIn.value = 0.005;
    else if (modelPreset.value === 'default') attIn.value = 0.0035;
    else attIn.value = 0.002;
    dAtt = parseFloat(attIn.value) || 0.002; computePredictions(); canvasDirty = true;
  });
  vpIn?.addEventListener('change', () => { vp = parseFloat(vpIn.value) || 6.0; computePredictions(); canvasDirty = true; });
  vsIn?.addEventListener('change', () => { vs = parseFloat(vsIn.value) || 3.5; computePredictions(); canvasDirty = true; });
  attIn?.addEventListener('input', () => { dAtt = parseFloat(attIn.value) || 0.002; computePredictions(); canvasDirty = true; });

  /* ------------------------------------------------------------
   * Simulation control（シミュ中は編集禁止）
   * ---------------------------------------------------------- */
  function getElapsed() { if (!running) return tOffset; if (!t0) return tOffset; return tOffset + (performance.now() - t0) / 1000 * speed; }

  runStart?.addEventListener('click', () => {
    if (epicenters.length === 0) { showOverlay('震源未設定', '震源を追加してからStartボタンを押してください。'); return; }
    vp = parseFloat(vpIn?.value) || 6.0; vs = parseFloat(vsIn?.value) || 3.5; dAtt = parseFloat(attIn?.value) || 0.002;
    running = true; t0 = performance.now(); tOffset = 0; speed = parseFloat(speedIn?.value || '1');
    modeSel.value = 'VIEW'; setModeUI();
    setupCircles();
    runStart.disabled = true; runStop.disabled = false; runPause.disabled = false; runResume.disabled = true;
    addLog('SYS', 'シミュレーション開始');

 // 震源ログ
    epicenters.forEach((e,idx)=>{
      addLog('SYS', `震源${idx+1} 位置:${e.region||'不明'} / M${e.M.toFixed(1)} / 深さ${e.depth.toFixed(0)}km @ ${e.lat.toFixed(2)},${e.lng.toFixed(2)}`);
    });

    // 震源の自動アナウンス
    unlockByUserGesture();
    const epicMsg = epicenters.map((e, idx) => `震源${idx + 1}、${e.region}、マグニチュード${e.M.toFixed(1)}、深さ${e.depth.toFixed(0)}キロ`).join('。');
    if (epicMsg) speakJP(epicMsg);

    updateCanvasAutoToggle();
  });
  runPause?.addEventListener('click', () => {
    if (!running) return;
    tOffset = getElapsed(); running = false;
    runPause.disabled = true; runResume.disabled = false; addLog('SYS', '一時停止');
  });
  runResume?.addEventListener('click', () => {
    if (running) return;
    t0 = performance.now(); running = true;
    runPause.disabled = false; runResume.disabled = true; addLog('SYS', '再開');
  });
  function stopSim(force = false) {
    running = false; t0 = null; tOffset = 0;
    epicenters.forEach(e => {
      if (e.pCircle) map.removeLayer(e.pCircle);
      if (e.sCircle) map.removeLayer(e.sCircle);
      if (e.tCircle) map.removeLayer(e.tCircle);
      e.pCircle = null; e.sCircle = null; e.tCircle = null;
    });
    stations.forEach(s => {
      s.pA = false; s.sA = false; s.tA = false; s.spoken = false;
      updateStationBadge(s, ''); updateCountdown(s, ''); s._lastBadge = ''; s._lastCountLabel = '';
    });
    if (!force) timeline.innerHTML = '停止中。Startで再開できます。';
    runStart.disabled = false; runStop.disabled = true; runPause.disabled = true; runResume.disabled = true;
    setModeUI();
    updateCanvasAutoToggle(); canvasDirty = true;
  }
  runStop?.addEventListener('click', () => stopSim());

  // Quick toolbar
  quickStart?.addEventListener('click', () => runStart.click());
  quickPause?.addEventListener('click', () => (running ? runPause : runResume).click());
  quickStop?.addEventListener('click', () => runStop.click());
  quickFit?.addEventListener('click', () => fitToAll());

  // Speed & jumps
  speedIn?.addEventListener('input', () => { speed = parseFloat(speedIn.value) || 1; updateHud(); canvasDirty = true; });
  function jumpBy(sec) {
    if (sec === 0) return;
    if (running) {
      const cur = getElapsed() + sec;
      tOffset = Math.max(0, cur);
      t0 = performance.now();
    } else {
      tOffset = Math.max(0, tOffset + sec);
    }
    updateTimeline(); canvasDirty = true;
  }
  jumpBack5?.addEventListener('click', () => jumpBy(-5));
  jumpFwd5?.addEventListener('click', () => jumpBy(+5));
  jumpFwd10?.addEventListener('click', () => jumpBy(+10));
  jumpToEnd?.addEventListener('click', () => {
    let maxT = 0;
    stations.forEach(s => {
      if (!s.pred) return;
      maxT = Math.max(maxT, s.pred.arrS || 0, (tsunamiOn && isFinite(s.pred.arrT)) ? s.pred.arrT : 0);
    });
    if (maxT <= 0) return;
    if (running) { tOffset = maxT + 0.5; t0 = performance.now(); } else { tOffset = maxT + 0.5; }
    updateTimeline(); canvasDirty = true;
  });

  /* ------------------------------------------------------------
   * Predictions compute（津波はベースン内のみ）
   * ---------------------------------------------------------- */
  function computePredictions() {
    stations.forEach(s => {
      let best = null;
      epicenters.forEach(e => {
        const at = arrivals(e, s);
        const pga = estimatePGA(
   e.M,
   Math.max(0.5, at.Rkm),
   e.depth,
   e.lat, e.lng,
   s.lat, s.lng
 );
        const jma = pgaToJMA(pga);
        const pred = { arrP: at.tP, arrS: at.tS, pga, jma, color: colorForIdx(jma.idx) };
        if (!best || pred.jma.idx > best.jma.idx) best = pred;
      });
      if (best) {
        // 津波：同一ベースン内のみ到達可
        let minH = Infinity, any = false;
        epicenters.forEach(e => {
          if (!tsunamiOn) return;
          if (!tsunamiArrivable(e, s)) return;
          any = true;
          const h = getHkmCached(e, s);
          if (h < minH) minH = h;
        });
        best.arrT = (tsunamiOn && any && isFinite(minH) && cT > 0) ? (minH / cT) : Infinity;
      }
      s.pred = best; s.pA = false; s.sA = false; s.tA = false; s.spoken = false; s._lastBadge = ''; s._lastCountLabel = '';
      updateStationBadge(s, ''); updateCountdown(s, '');
    });
    updateHeatLayer();
    updateTimeline();
    markAllUnmoved();
    canvasDirty = true;
  }

  /* Rings */
  function setupCircles() {
    epicenters.forEach(e => {
      if (e.pCircle) map.removeLayer(e.pCircle);
      if (e.sCircle) map.removeLayer(e.sCircle);
      if (e.tCircle) map.removeLayer(e.tCircle);
    });
    epicenters.forEach(e => {
      e.pCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(80,170,255,0.5)', weight: 2, fill: false });
      e.sCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(255,100,100,0.4)', weight: 2, fill: false });
      e.tCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(80,255,200,0.75)', weight: 3, dashArray: '8 6', fill: false }).bringToFront();
      if (ringsOn) { e.pCircle.addTo(map); e.sCircle.addTo(map); }
      if (tsuRingsOn && tsunamiOn) e.tCircle.addTo(map);
    });
  }
  function updateRingVisibility() {
    epicenters.forEach(e => {
      if (e.pCircle) { if (ringsOn) e.pCircle.addTo(map); else map.removeLayer(e.pCircle); }
      if (e.sCircle) { if (ringsOn) e.sCircle.addTo(map); else map.removeLayer(e.sCircle); }
      if (e.tCircle) { if (tsuRingsOn && tsunamiOn) e.tCircle.addTo(map); else map.removeLayer(e.tCircle); }
    });
    canvasDirty = true;
  }

  /* Station UI */
 /* Station UI 軽量化版 */

// 震度バッジ更新（既存要素の中身だけ変更）
function updateStationBadge(st, text) {
  if (!st._badgeEl) {
    // 初回は参照を保存
    const iconEl = st.marker.getElement();
    if (iconEl) {
      st._badgeEl = iconEl.querySelector('.station-dot');
    }
  }
  if (st._badgeEl) {
    st._badgeEl.innerHTML = text || '';
  }
}

// カウントダウン更新（既存要素の中身だけ変更）
function updateCountdown(st, txt) {
  if (!st.countdownMarker) return;
  if (!st._countEl) {
    const cdEl = st.countdownMarker.getElement();
    if (cdEl) {
      st._countEl = cdEl.querySelector('.countdown-pill');
    }
  }
  if (st._countEl) {
    st._countEl.innerHTML = txt || '';
  }
}


  /* Timeline */
  function updateTimeline() {
    if (!running) { timeline.innerHTML = '停止中。Startで再開できます。'; return; }
    const t = getElapsed();
    const rows = [];
    stations.forEach(s => {
      if (!s.pred) return;
      if (!s.pA) rows.push({ name: s.name || '(無名)', type: 'P', in: Math.max(0, s.pred.arrP - t) });
      if (!s.sA) rows.push({ name: s.name || '(無名)', type: 'S', in: Math.max(0, s.pred.arrS - t) });
      if (tsunamiOn && !s.tA && isFinite(s.pred.arrT)) rows.push({ name: s.name || '(無名)', type: 'T', in: Math.max(0, s.pred.arrT - t) });
    });
    rows.sort((a, b) => a.in - b.in);
    const html = rows.slice(0, 16).map(r => {
      const cls = r.type === 'P' ? 'timeline-p' : (r.type === 'S' ? 'timeline-s' : 'timeline-t');
      const sec = perfLite ? Math.round(r.in) : r.in.toFixed(1);
      return `<div>${sec}s → <b class="${cls}">${r.type}</b> @ ${r.name}</div>`;
    }).join('') || '全て到達済み';
    timeline.innerHTML = html;
  }

  /* Loop with throttling */
  function loop() {
    const now = performance.now();
    const shouldUpdate = (now - lastFrame) >= perfInterval;

    if (running && shouldUpdate) {
      lastFrame = now;
      const t = getElapsed();

      epicenters.forEach(e => {
        const rP = t * vp * 1000, rS = t * vs * 1000, rT = t * cT * 1000;
        if (e.pCircle) e.pCircle.setRadius(rP > 0 ? rP : 0);
        if (e.sCircle) e.sCircle.setRadius(rS > 0 ? rS : 0);
        if (e.tCircle) e.tCircle.setRadius(rT > 0 ? rT : 0);
      });

      stations.forEach(s => {
        if (!s.pred) return;
        // P 到達
        if (!s.pA) {
          const left = s.pred.arrP - t;
          const label = left > 0 ? `P ${(perfLite ? Math.ceil(left) : left.toFixed(1))}s` : '';
          if (s._lastCountLabel !== label) { updateCountdown(s, label); s._lastCountLabel = label; }
          if (left <= 0) { s.pA = true; addLog('P', `${s.name || '観測点'} P到達`); canvasDirty = true; }
        }
        // S 到達
        else if (!s.sA) {
          const left = s.pred.arrS - t;
          const label = left > 0 ? `S ${(perfLite ? Math.ceil(left) : left.toFixed(1))}s` : '';
          if (s._lastCountLabel !== label) { updateCountdown(s, label); s._lastCountLabel = label; }
          if (left <= 0) {
            s.sA = true;
            if (s._lastCountLabel !== '') { updateCountdown(s, ''); s._lastCountLabel = ''; }
            const newBadge = s.pred.jma.sh;
            if (s._lastBadge !== newBadge) { updateStationBadge(s, newBadge); s._lastBadge = newBadge; }
            addLog('S', `${s.name || '観測点'} 予想震度 ${s.pred.jma.sh}`);
            // 読み上げ設定
            const mode = ttsModeSel?.value || 'off';
            const idx = s.pred.jma.idx;
            const needSpeak = (mode === 'all') || (mode === 'major' && s.isMajor) || (mode === 'jma5' && idx >= 4);
            if (needSpeak && !s.spoken) {
              const nm = s.name && s.name.trim() ? s.name : '観測点';
              speakJP(`${nm}、予想震度、${s.pred.jma.sh}`);
              s.spoken = true;
            }
            canvasDirty = true;
          }
        }
        // 津波 到達
        if (tsunamiOn && !s.tA && isFinite(s.pred.arrT)) {
          const leftT = s.pred.arrT - t;
          if (leftT <= 0) {
            s.tA = true;
            if (!s.sA && s._lastBadge !== '🌊') { updateStationBadge(s, '🌊'); s._lastBadge = '🌊'; }
            addLog('T', `${s.name || '観測点'} 津波到達`);
            canvasDirty = true;
          }
        }

        // 最小残り表示
        const leftP = s.pA ? Infinity : (s.pred.arrP - t);
        const leftS = s.sA ? Infinity : (s.pred.arrS - t);
        const leftT = (!tsunamiOn || s.tA || !isFinite(s.pred.arrT)) ? Infinity : (s.pred.arrT - t);
        const minLeft = Math.min(leftP, leftS, leftT);
        if (isFinite(minLeft)) {
          const tag = (minLeft === leftP) ? 'P' : (minLeft === leftS) ? 'S' : 'T';
          const seconds = Math.max(0, minLeft);
          const coarse = perfLite ? Math.round(seconds).toString() : seconds.toFixed(1);
          const label = `${tag} ${coarse}s`;
          if (s._lastCountLabel !== label) { updateCountdown(s, label); s._lastCountLabel = label; }
        } else {
          if (s._lastCountLabel !== '') { updateCountdown(s, ''); s._lastCountLabel = ''; }
        }
      });

      if (now - lastTimelineUpdate > timelineInterval) {
        updateTimeline(); lastTimelineUpdate = now;
      }
    }

    if (canvasEnabled) drawStationsCanvas(); // Canvas描画
    updateFaultAnimation(); // Fault animation runner
    requestAnimationFrame(loop);
  }
  loop();

  /* Perf mode */
  function setPerfMode(on) {
    perfLite = !!on;
    const base = parseInt(perfIntervalIn?.value || '250', 10);
    perfInterval = Math.max(150, base);
    timelineInterval = perfLite ? Math.max(600, perfInterval * 3) : Math.max(250, Math.floor(perfInterval * 1.2));
    if (perfLite) {
      if (heatToggle && heatToggle.value !== 'off') { heatToggle.value = 'off'; updateHeatLayer(); }
      if (tsuRingVis && tsuRingVis.value !== 'off') { tsuRingVis.value = 'off'; tsuRingsOn = false; updateRingVisibility(); }
    }
    updateHud();
    updateCanvasAutoToggle();
    canvasDirty = true;
  }
  perfModeSel?.addEventListener('change', () => setPerfMode(perfModeSel.value === 'on'));
  perfIntervalIn?.addEventListener('change', () => setPerfMode(perfModeSel?.value === 'on'));

  /* Buttons (Add/Clear) */
  btnAddEpic?.addEventListener('click', () => {
    if (running) { showOverlay('編集中止', 'シミュレーション停止後に追加できます。'); return; }
    const c = map.getCenter(); addEpicAt(c.lat, c.lng);
  });
  btnAddStation?.addEventListener('click', () => {
    if (running) { showOverlay('編集中止', 'シミュレーション停止後に追加できます。'); return; }
    let name = stName?.value?.trim();
    let lat = parseFloat(stLat?.value), lng = parseFloat(stLon?.value);
    if (!isFinite(lat) || !isFinite(lng)) { const c = map.getCenter(); lat = c.lat; lng = c.lng; }
    addStationAt(lat, lng, name || `観測点${stations.length + 1}`, true, false);
    if (name) stName.value = '';
  });
  btnClearStations?.addEventListener('click', () => {
    if (running) { showOverlay('編集中止', 'シミュレーション停止後に削除できます。'); return; }
    stations.forEach(s => {
      if (s.marker) map.removeLayer(s.marker);
      if (s.nameMarker) map.removeLayer(s.nameMarker);
      if (s.countdownMarker) map.removeLayer(s.countdownMarker);
    });
    stations = []; refreshStList(); timeline.innerHTML = '観測点を全削除しました。'; computePredictions(); updateCanvasAutoToggle();
  });

  /* Filters / labels / search */
  stFilter?.addEventListener('change', applyStationFilter);
  function applyStationFilter() {
    const mode = stFilter.value; // 'all' | 'major' | 'custom'
    stations.forEach(s => {
      let vis = true;
      if (mode === 'major') vis = !!s.isMajor;
      if (vis && !s.visible) {
        s.visible = true;
        if (!canvasEnabled) {
          map.addLayer(s.marker); map.addLayer(s.countdownMarker);
          if (s.nameMarker && labelToggle.value === 'on') map.addLayer(s.nameMarker);
        }
      } else if (!vis && s.visible) {
        s.visible = false;
        if (map.hasLayer(s.marker)) map.removeLayer(s.marker);
        if (s.countdownMarker && map.hasLayer(s.countdownMarker)) map.removeLayer(s.countdownMarker);
        if (s.nameMarker && map.hasLayer(s.nameMarker)) map.removeLayer(s.nameMarker);
      }
    });
    updateCanvasAutoToggle();
    canvasDirty = true;
  }
  labelToggle?.addEventListener('change', () => {
    const on = (labelToggle.value === 'on');
    if (canvasEnabled) { canvasDirty = true; return; }
    stations.forEach(s => {
      if (!s.nameMarker) return;
      if (on && s.visible) map.addLayer(s.nameMarker);
      else map.removeLayer(s.nameMarker);
    });
  });
  stSearch?.addEventListener('input', () => {
    const q = (stSearch.value || '').trim().toLowerCase();
    stations.forEach(s => {
      const el = s.marker.getElement(); if (!el) return;
      const name = (s.name || '').toLowerCase();
      if (q && name.includes(q)) el.classList.add('highlight');
      else el.classList.remove('highlight');
    });
    canvasDirty = true;
  });

  /* Tsunami */
  function depthToSpeedKmPerS(h_m) { return Math.sqrt(9.81 * Math.max(100, h_m)) / 1000; }
  function ensureTsunamiCircles() {
    epicenters.forEach(e => {
      if (!e.tCircle) {
        e.tCircle = L.circle([e.lat, e.lng], { radius: 0, color: 'rgba(80,255,200,0.75)', weight: 3, dashArray: '8 6', fill: false }).bringToFront();
        if (tsuRingsOn && tsunamiOn) e.tCircle.addTo(map);
      }
    });
  }
  tsuModeSel?.addEventListener('change', () => {
    tsunamiOn = (tsuModeSel.value === 'on');
    if (tsunamiOn) { cT = parseFloat(tsuSpeedIn.value) || cT; ensureTsunamiCircles(); }
    updateRingVisibility(); computePredictions(); updateTimeline(); canvasDirty = true;
  });
  tsuRingVis?.addEventListener('change', () => { tsuRingsOn = (tsuRingVis.value === 'on'); if (tsuRingsOn && tsunamiOn) ensureTsunamiCircles(); updateRingVisibility(); canvasDirty = true; });
  seaDepthIn?.addEventListener('change', () => {
    const h = Math.max(100, parseFloat(seaDepthIn.value) || 4000);
    cT = depthToSpeedKmPerS(h); tsuSpeedIn.value = cT.toFixed(3); computePredictions(); canvasDirty = true;
  });
  tsuSpeedIn?.addEventListener('change', () => {
    const v = parseFloat(tsuSpeedIn.value);
    if (isFinite(v) && v > 0) { cT = Math.max(0.05, Math.min(0.8, v)); computePredictions(); canvasDirty = true; }
  });

  /* Heat layer */
  function updateHeatLayer() {
    heatLayer.clearLayers();
    if (!heatToggle || heatToggle.value !== 'on') return;
    const opacity = parseFloat(heatOpacity?.value || '0.5');
    stations.forEach(s => {
      if (!s.pred || !s.visible) return;
      const idx = s.pred.jma.idx;
      const r = 12000 + idx * 6000;
      const col = s.pred.color || '#ff5a5a';
      const c = L.circle([s.lat, s.lng], { radius: r, color: col, weight: 1, fill: true, fillOpacity: opacity * 0.35, opacity: opacity * 0.85 });
      heatLayer.addLayer(c);
    });
  }
  heatToggle?.addEventListener('change', updateHeatLayer);
  heatOpacity?.addEventListener('input', updateHeatLayer);

  /* Fit to all */
  function fitToAll() {
    const pts = [];
    epicenters.forEach(e => pts.push([e.lat, e.lng]));
    stations.forEach(s => s.visible && pts.push([s.lat, s.lng]));
    if (pts.length) { const b = L.latLngBounds(pts); map.fitBounds(b.pad(0.2)); }
  }
  fitAllBtn?.addEventListener('click', fitToAll);

  /* Save / load / share */
  const LS_KEY = 'quakeSimState';
  function serializeState() {
    return {
      params: {
        vp: parseFloat(vpIn?.value) || 6, vs: parseFloat(vsIn?.value) || 3.5, att: parseFloat(attIn?.value) || 0.002,
        tsunamiOn, tsuRingsOn, cT, sea: parseFloat(seaDepthIn?.value) || 4000, theme: themeSel?.value || 'auto'
      },
      epicenters: epicenters.map(e => ({ lat: e.lat, lng: e.lng, M: e.M, depth: e.depth })),
      stations: stations.map(s => ({ lat: s.lat, lng: s.lng, name: s.name || '', isMajor: !!s.isMajor }))
    };
  }
  function restoreState(obj) {
    epicenters.forEach(e => { if (e.marker) map.removeLayer(e.marker); if (e.pCircle) map.removeLayer(e.pCircle); if (e.sCircle) map.removeLayer(e.sCircle); if (e.tCircle) map.removeLayer(e.tCircle); });
    epicenters = []; refreshEpicList();
    stations.forEach(s => { if (s.marker) map.removeLayer(s.marker); if (s.nameMarker) map.removeLayer(s.nameMarker); if (s.countdownMarker) map.removeLayer(s.countdownMarker); });
    stations = []; refreshStList();

    if (obj?.params) {
      vpIn.value = obj.params.vp ?? 6; vsIn.value = obj.params.vs ?? 3.5; attIn.value = obj.params.att ?? 0.002;
      seaDepthIn.value = obj.params.sea ?? 4000; cT = obj.params.cT ?? depthToSpeedKmPerS(parseFloat(seaDepthIn.value));
      tsuModeSel.value = obj.params.tsunamiOn ? 'on' : 'off';
      tsuRingVis.value = obj.params.tsuRingsOn ? 'on' : 'off';
      tsunamiOn = !!obj.params.tsunamiOn; tsuRingsOn = !!obj.params.tsuRingsOn;
      if (obj.params.theme) applyTheme(obj.params.theme), (themeSel.value = obj.params.theme);
    }
    (obj?.epicenters || []).forEach(e => { inMag.value = e.M; inDepth.value = e.depth; addEpicAt(e.lat, e.lng); });
    (obj?.stations || []).forEach(s => addStationAt(s.lat, s.lng, s.name || '', true, !!s.isMajor));
    fitToAll();
    computePredictions();
    updateCanvasAutoToggle();
  }
  saveLocal?.addEventListener('click', () => { try { localStorage.setItem(LS_KEY, JSON.stringify(serializeState())); showOverlay('保存', 'ブラウザに保存しました。'); } catch (e) { showOverlay('保存失敗', String(e?.message || e)); } });
  loadLocal?.addEventListener('click', () => { try { const raw = localStorage.getItem(LS_KEY); if (!raw) return showOverlay('読込', '保存データがありません。'); restoreState(JSON.parse(raw)); showOverlay('読込', '保存データを読み込みました。'); } catch (e) { showOverlay('読込失敗', String(e?.message || e)); } });
  delLocal?.addEventListener('click', () => { localStorage.removeItem(LS_KEY); showOverlay('削除', '保存データを削除しました。'); });

  exportJson?.addEventListener('click', () => {
    const data = JSON.stringify(serializeState(), null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'quakeSimState.json'; a.click();
    URL.revokeObjectURL(url);
  });
  importJson?.addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0]; if (!f) return;
    try {
      const text = await f.text();
      const obj = JSON.parse(text);
      restoreState(obj);
      showOverlay('インポート', 'ファイルを読み込みました。');
    } catch (e) { showOverlay('インポート失敗', String(e?.message || e)); }
    importJson.value = '';
  });
  copyPermalink?.addEventListener('click', async () => {
    try {
      const payload = encodeURIComponent(JSON.stringify(serializeState()));
      const url = location.origin + location.pathname + '#state=' + payload;
      await navigator.clipboard.writeText(url);
      showOverlay('共有URL', 'クリップボードにコピーしました。');
    } catch (e) { showOverlay('コピー失敗', String(e?.message || e)); }
  });
  window.addEventListener('load', () => {
    const m = location.hash.match(/#state=(.+)$/);
    if (m) { try { const obj = JSON.parse(decodeURIComponent(m[1])); setTimeout(() => restoreState(obj), 400); } catch { } }
  });

  /* ------------------------------------------------------------
   * Replay (簡易)
   * ---------------------------------------------------------- */
  const REPLAYS = {
    '20110311': { epicenters: [{ lat: 38.1, lng: 142.9, M: 9.0, depth: 24 }], stations: [] },
    '20160416': { epicenters: [{ lat: 32.754, lng: 130.763, M: 7.0, depth: 11 }], stations: [] },
    '20180906': { epicenters: [{ lat: 42.694, lng: 142.006, M: 6.7, depth: 37 }], stations: [] }
  };
  replayLoad?.addEventListener('click', () => {
    const v = replaySel.value;
    if (v === 'none') { showOverlay('リプレイ', 'プリセットを選択してください。'); return; }
    if (v !== 'custom') {
      applyAI(REPLAYS[v]);
      showOverlay('読み込み', 'プリセットを読み込みました。');
    } else {
      replayFile.click();
    }
  });
  replayFile?.addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0]; if (!f) return;
    try {
      const text = await f.text(); const obj = JSON.parse(text);
      applyAI(obj); showOverlay('読み込み', 'カスタムJSONを読み込みました。');
    } catch (e) { showOverlay('読み込み失敗', String(e?.message || e)); }
    replayFile.value = '';
  });
  replayPlay?.addEventListener('click', () => {
    if (epicenters.length === 0) { showOverlay('震源未設定', 'まず読み込みを行ってください。'); return; }
    runStart.click();
  });

  function applyAI(data) {
    try {
      let addedE = 0, addedS = 0;
      if (Array.isArray(data.epicenters)) {
        data.epicenters.forEach(ep => {
          if (!isFinite(ep.lat) || !isFinite(ep.lng)) return;
          addEpicAt(ep.lat, ep.lng);
          const e = epicenters[epicenters.length - 1];
          if (e) {
            if (isFinite(ep.M)) e.M = clampMag(parseFloat(ep.M));
            if (isFinite(ep.depth)) e.depth = clampDepth(parseFloat(ep.depth));
            e.region = nameEpicentralRegion(e.lat, e.lng);
            e.marker.closeTooltip(); e.marker.bindTooltip(`M${e.M.toFixed(1)} / ${e.depth.toFixed(1)}km\n${e.region}`);
            e.ai = true; addedE++;
          }
        });
      }
      if (Array.isArray(data.stations)) {
        data.stations.forEach(st => {
          if (!isFinite(st.lat) || !isFinite(st.lng)) return;
          addStationAt(st.lat, st.lng, st.name || '', true, !!st.isMajor);
          const s = stations[stations.length - 1];
          if (s) { s.ai = true; addedS++; }
        });
      }
      computePredictions(); fitToAll();
      showOverlay('AI適用', `震源${addedE}件・観測点${addedS}件を反映しました。`);
      updateCanvasAutoToggle();
    } catch (err) {
      showOverlay('AI適用エラー', String(err?.message || err || 'unknown'));
    }
  }

  /* ------------------------------------------------------------
   * Fault drawing & animation（専用モード）
   * ---------------------------------------------------------- */
  faultStart?.addEventListener('click', () => {
    faultDrawing = true; faultLineLatLngs = []; updateHud();
    if (faultPolyline) { map.removeLayer(faultPolyline); faultPolyline = null; }
    if (faultRunner) { map.removeLayer(faultRunner); faultRunner = null; }
    showOverlay('断層描画', '地図をクリックして頂点を追加。完了したら「終了」。');
  });
  faultFinish?.addEventListener('click', () => {
    faultDrawing = false; updateHud();
    if (faultLineLatLngs.length < 2) { showOverlay('断層ライン', '2点以上必要です。'); return; }
    if (faultPolyline) map.removeLayer(faultPolyline);
    faultPolyline = L.polyline(faultLineLatLngs, { color: '#ffcc66', weight: 4, opacity: 0.9 }).addTo(map).bringToFront();
    if (faultMode.value === 'animate') startFaultAnimation();
  });
  faultClear?.addEventListener('click', () => {
    faultDrawing = false; faultLineLatLngs = [];
    if (faultPolyline) { map.removeLayer(faultPolyline); faultPolyline = null; }
    if (faultRunner) { map.removeLayer(faultRunner); faultRunner = null; }
    faultAnim = null; canvasDirty = true;
  });
  function addFaultPoint(latlng) {
    faultLineLatLngs.push(latlng);
    if (faultPolyline) map.removeLayer(faultPolyline);
    faultPolyline = L.polyline(faultLineLatLngs, { color: '#ffcc66', weight: 3, opacity: 0.7, dashArray: '6 6' }).addTo(map).bringToFront();
    canvasDirty = true;
  }
  function startFaultAnimation() {
    if (faultLineLatLngs.length < 2) return;
    const pts = faultLineLatLngs.slice();
    const segCum = [0]; let total = 0;
    for (let i = 1; i < pts.length; i++) {
      total += hav(pts[i - 1].lat, pts[i - 1].lng, pts[i].lat, pts[i].lng) / 1000;
      segCum.push(total);
    }
    if (faultRunner) map.removeLayer(faultRunner);
    faultRunner = L.circle(pts[0], { radius: 25000, color: 'rgba(255,204,102,0.9)', weight: 2, fill: true, fillOpacity: 0.25 }).addTo(map).bringToFront();
    faultAnim = { running: true, start: performance.now(), distKm: 0, segCum, points: pts, speed: Math.max(0.1, Math.min(5, parseFloat(faultSpeed?.value) || 1.5)) };
  }
  function updateFaultAnimation() {
    if (!faultAnim || !faultAnim.running) return;
    const elapsed = (performance.now() - faultAnim.start) / 1000;
    const dist = elapsed * faultAnim.speed;
    const pts = faultAnim.points, seg = faultAnim.segCum;
    const total = seg[seg.length - 1];
    let d = Math.min(dist, total);
    let i = 1; while (i < seg.length && seg[i] < d) i++;
    const d1 = seg[i - 1], d2 = seg[i], frac = (d - d1) / Math.max(1e-6, (d2 - d1));
    const A = pts[i - 1], B = pts[i];
    const lat = A.lat + (B.lat - A.lat) * frac;
    const lng = A.lng + (B.lng - A.lng) * frac;
    if (faultRunner) faultRunner.setLatLng([lat, lng]);
    if (d >= total) { faultAnim.running = false; }
  }

  /* ------------------------------------------------------------
   * Screenshot（SVG化）
   * ---------------------------------------------------------- */
  btnShot?.addEventListener('click', exportSVG);
  function exportSVG() {
    if (!map) return;
    const size = map.getSize(); const W = size.x, H = size.y;
    const viewBox = `0 0 ${W} ${H}`;

    function pt(ll) { const p = map.latLngToContainerPoint(ll); return { x: p.x, y: p.y }; }
    function destPoint(lat, lng, dist, bearing) {
      const R = 6371e3, br = bearing * Math.PI / 180;
      const φ1 = lat * Math.PI / 180, λ1 = lng * Math.PI / 180, δ = dist / R;
      const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(br));
      const λ2 = λ1 + Math.atan2(Math.sin(br) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
      return { lat: φ2 * 180 / Math.PI, lng: ((λ2 * 180 / Math.PI + 540) % 360) - 180 };
    }
    function radiusPx(centerLatLng, meters) {
      const c = pt(centerLatLng);
      const east = destPoint(centerLatLng.lat, centerLatLng.lng, meters, 90);
      const e = pt(east);
      return Math.hypot(e.x - c.x, e.y - c.y);
    }

    const svg = [`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="${viewBox}" style="background:#000">`];
    svg.push(`<text x="12" y="22" fill="#9fb0b8" font-size="14">Overlay Snapshot (tiles省略)</text>`);

    if (faultPolyline) {
      const latlngs = faultLineLatLngs.map(pt);
      if (latlngs.length > 1) {
        const d = 'M ' + latlngs.map(p => `${p.x.toFixed(1)} ${p.y.toFixed(1)}`).join(' L ');
        svg.push(`<path d="${d}" stroke="#ffcc66" stroke-width="3" fill="none" />`);
      }
    }

    epicenters.forEach(e => {
      const cpt = pt([e.lat, e.lng]);
      svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="6" fill="#ff6b6b" stroke="#d74f4f" stroke-width="2"/>`);
      if (e.pCircle && ringsOn) {
        const r = e.pCircle.getRadius(); if (r > 0) { const R = radiusPx({ lat: e.lat, lng: e.lng }, r); svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="${R.toFixed(1)}" fill="none" stroke="rgba(80,170,255,0.6)" stroke-width="2"/>`); }
      }
      if (e.sCircle && ringsOn) {
        const r = e.sCircle.getRadius(); if (r > 0) { const R = radiusPx({ lat: e.lat, lng: e.lng }, r); svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="${R.toFixed(1)}" fill="none" stroke="rgba(255,100,100,0.5)" stroke-width="2"/>`); }
      }
      if (e.tCircle && tsunamiOn && tsuRingsOn) {
        const r = e.tCircle.getRadius(); if (r > 0) { const R = radiusPx({ lat: e.lat, lng: e.lng }, r); svg.push(`<circle cx="${cpt.x.toFixed(1)}" cy="${cpt.y.toFixed(1)}" r="${R.toFixed(1)}" fill="none" stroke="rgba(80,255,200,0.8)" stroke-width="3" stroke-dasharray="8 6"/>`); }
      }
    });

    stations.forEach(s => {
      if (!s.visible) return;
      const p = pt([s.lat, s.lng]);
      svg.push(`<g transform="translate(${p.x.toFixed(1)},${p.y.toFixed(1)})">`);
      svg.push(`<circle r="16" fill="#57c7ff" stroke="rgba(0,0,0,0.2)" stroke-width="2"/>`);
      if (s._lastBadge) svg.push(`<text text-anchor="middle" y="4" font-size="12" font-weight="700" fill="#061015">${escapeXML(s._lastBadge)}</text>`);
      const nm = (s.name || '').trim();
      if (nm && labelToggle?.value === 'on') {
        const w = nm.length * 6 + 6;
        svg.push(`<rect x="-${w / 2}" y="-32" rx="6" ry="6" width="${w}" height="16" fill="rgba(0,0,0,0.6)"/>`);
        svg.push(`<text text-anchor="middle" y="-20" font-size="11" fill="#fff">${escapeXML(nm)}</text>`);
      }
      svg.push(`</g>`);
    });

    svg.push(`</svg>`);
    const out = svg.join('');
    const blob = new Blob([out], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'quake_overlay.svg'; a.click();
    URL.revokeObjectURL(url);
    function escapeXML(s) { return (s || '').replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&apos;' }[m])); }
  }

  /* ------------------------------------------------------------
   * Keyboard Shortcuts
   * ---------------------------------------------------------- */
  document.addEventListener('keydown', (e) => {
    const tag = (e.target || {}).tagName || '';
    if (/INPUT|SELECT|TEXTAREA/.test(tag)) return;
    if (e.code === 'Space') { e.preventDefault(); (running ? runPause : runResume).click(); return; }
    if (e.key === 's' || e.key === 'S') { runStop.click(); return; }
    if (e.key === 'f' || e.key === 'F') { fitToAll(); return; }
    if (e.key === '[') { jumpBy(-5); return; }
    if (e.key === ']') { jumpBy(+5); return; }
    if (e.key === '1') { perfModeSel.value = 'off'; setPerfMode(false); return; }
    if (e.key === '2') { perfModeSel.value = 'on'; setPerfMode(true); return; }
    if (e.key === 't' || e.key === 'T') {
      tsuRingVis.value = (tsuRingVis.value === 'on') ? 'off' : 'on';
      tsuRingsOn = (tsuRingVis.value === 'on'); updateRingVisibility();
      return;
    }
  });

  /* ------------------------------------------------------------
   * End
   * ---------------------------------------------------------- */

 /* ------------------------------------------------------------
   * Fault drawing / animation
   * ---------------------------------------------------------- */
  function kmBetween(a, b){ return hav(a.lat, a.lng, b.lat, b.lng) / 1000; }

  function resetFault(){
    faultDrawing = false;
    faultLineLatLngs = [];
    if (faultPolyline) { map.removeLayer(faultPolyline); faultPolyline = null; }
    if (faultRunner) { map.removeLayer(faultRunner); faultRunner = null; }
    faultAnim = null;
  }

  function addFaultPoint(latlng){
    if (!faultPolyline){
      faultPolyline = L.polyline([latlng], {
        color: 'rgba(255,180,60,0.9)',
        weight: 3,
        dashArray: '6 6'
      }).addTo(map);
    } else {
      const pts = faultPolyline.getLatLngs();
      pts.push(latlng);
      faultPolyline.setLatLngs(pts);
    }
    faultLineLatLngs.push(latlng);
  }

  function startFaultDraw(){
    resetFault();
    faultDrawing = true;
    addLog('SYS','断層描画を開始');
    hud.textContent = '断層描画: 地図をクリックして線分を追加（終了ボタンで確定）';
  }

  function finishFaultDraw(){
    if (!faultPolyline || faultLineLatLngs.length < 2){
      addLog('SYS','線分が不足しています');
      faultDrawing = false;
      return;
    }
    faultDrawing = false;
    addLog('SYS','断層描画を確定');
  }

  function polyTotalKm(pts){
    let s = 0;
    for (let i=1;i<pts.length;i++) s += kmBetween(pts[i-1], pts[i]);
    return s;
  }

  function subPolylineByDistKm(pts, dKm){
    if (dKm <= 0) return [pts[0]];
    let acc = 0;
    const out = [pts[0]];
    for (let i=1;i<pts.length;i++){
      const seg = kmBetween(pts[i-1], pts[i]);
      if (acc + seg >= dKm){
        const r = (dKm - acc) / seg;
        const lat = pts[i-1].lat + (pts[i].lat - pts[i-1].lat) * r;
        const lng = pts[i-1].lng + (pts[i].lng - pts[i-1].lng) * r;
        out.push(L.latLng(lat, lng));
        return out;
      } else {
        out.push(pts[i]);
        acc += seg;
      }
    }
    return out;
  }

  function startFaultAnim(){
    if (!faultPolyline || faultLineLatLngs.length < 2){
      addLog('SYS','まず「描画」で線を作成してください');
      return;
    }
    const pts = faultLineLatLngs.slice();
    const total = polyTotalKm(pts);
    if (total <= 0) return;

    const speedKmS = Math.max(0.1, Math.min(5, parseFloat(faultSpeed?.value || '1.5')));
    faultAnim = {
      running: true,
      startMs: performance.now(),
      lastMs: performance.now(),
      speed: speedKmS,
      totalKm: total,
      pts,
      distKm: 0
    };

    if (!faultRunner){
      faultRunner = L.polyline([pts[0]], {
        color: 'rgba(255,100,60,1)',
        weight: 4
      }).addTo(map);
    }
    addLog('SYS', `断層アニメ開始（${speedKmS}km/s）`);
  }

  function stopFaultAnim(){
    if (faultAnim?.running){
      faultAnim.running = false;
      addLog('SYS','断層アニメ停止');
    }
  }

  function updateFaultAnimation(){
    if (!faultAnim || !faultAnim.running) return;
    const now = performance.now();
    const dt = (now - faultAnim.lastMs) / 1000;
    faultAnim.lastMs = now;

    faultAnim.distKm += dt * faultAnim.speed;
    if (faultAnim.distKm >= faultAnim.totalKm){
      faultAnim.distKm = faultAnim.totalKm;
      faultAnim.running = false;
      addLog('SYS','断層アニメ完了');
    }

    const partial = subPolylineByDistKm(faultAnim.pts, faultAnim.distKm);
    if (faultRunner) faultRunner.setLatLngs(partial);
  }

  // Fault UI bindings
  faultStart?.addEventListener('click', () => {
    faultMode.value = 'draw';
    startFaultDraw();
  });
  faultFinish?.addEventListener('click', () => {
    if (faultMode.value === 'draw'){
      finishFaultDraw();
      // そのまま待機（必要なら animate を選ぶ）
    } else if (faultMode.value === 'animate'){
      stopFaultAnim();
    }
  });
  faultClear?.addEventListener('click', () => {
    resetFault();
    addLog('SYS','断層クリア');
  });
  faultMode?.addEventListener('change', () => {
    if (faultMode.value === 'draw'){
      startFaultDraw();
    } else if (faultMode.value === 'animate'){
      finishFaultDraw();
      startFaultAnim();
    } else {
      resetFault();
      hud.textContent = baseHudText();
    }
  });

  /* ------------------------------------------------------------
   * Presets / Replay
   * ---------------------------------------------------------- */
  function applyScenario(key){
    // 既存をクリアして代表的な震源＋推奨深さをセット
    if (running) stopSim();
    epicenters.forEach(e => { if (e.marker) map.removeLayer(e.marker); });
    epicenters = []; refreshEpicList();

    const presets = {
      nankai: { lat: 33.1, lng: 136.7, M: 8.2, depth: 20 },
      sagami: { lat: 34.9, lng: 139.3, M: 7.6, depth: 30 },
      japantrench: { lat: 38.5, lng: 143.0, M: 8.5, depth: 25 }
    };
    const p = presets[key];
    if (!p) return;

    inMag.value = p.M; inDepth.value = p.depth;
    addEpicAt(p.lat, p.lng);
    fitToAll();
  }
  applyPreset?.addEventListener('click', () => {
    const key = presetScenario?.value || 'none';
    if (key === 'none'){ showOverlay('プリセット','シナリオを選択してください。'); return; }
    applyScenario(key);
  });
  clearAll?.addEventListener('click', () => {
    if (running) stopSim();
    // epic
    epicenters.forEach(e => {
      if (e.pCircle) map.removeLayer(e.pCircle);
      if (e.sCircle) map.removeLayer(e.sCircle);
      if (e.tCircle) map.removeLayer(e.tCircle);
      map.removeLayer(e.marker);
    });
    epicenters = []; refreshEpicList();
    // stations
    stations.forEach(s => {
      if (s.marker) map.removeLayer(s.marker);
      if (s.nameMarker) map.removeLayer(s.nameMarker);
      if (s.countdownMarker) map.removeLayer(s.countdownMarker);
    });
    stations = []; refreshStList();
    heatLayer.clearLayers();
    H_CACHE.clear();
    timeline.innerHTML = '全てクリアしました。';
    updateCanvasAutoToggle();
  });

  const REPLAY_PRESETS = {
    '20110311': {
      title: '2011-03-11 東北地方太平洋沖',
      epicenters: [{lat: 38.103, lng: 142.861, M: 9.0, depth: 24}],
      stationsMajor: ['札幌','仙台','東京','横浜','千葉','さいたま','名古屋','京都','大阪','神戸','広島','福岡','那覇']
    },
    '20160416': {
      title: '2016-04-16 熊本',
      epicenters: [{lat: 32.75, lng: 130.76, M: 7.0, depth: 11}],
      stationsMajor: ['福岡','北九州','熊本','大分','広島','大阪','神戸','名古屋','東京']
    },
    '20180906': {
      title: '2018-09-06 胆振東部',
      epicenters: [{lat: 42.69, lng: 142.0, M: 6.7, depth: 37}],
      stationsMajor: ['札幌','仙台','東京','千葉','さいたま','名古屋','大阪','広島','福岡']
    }
  };

  function loadReplay(sel){
    const info = REPLAY_PRESETS[sel];
    if (!info){ showOverlay('リプレイ','プリセットを選択してください。'); return; }
    if (running) stopSim();

    // epic reset
    epicenters.forEach(e => { if (e.marker) map.removeLayer(e.marker); });
    epicenters = []; refreshEpicList();

    // keep stations but ensure majors exist
    const need = new Set(info.stationsMajor || []);
    const have = new Set(stations.filter(s => s.isMajor).map(s => s.name));
    need.forEach(n => {
      if (!have.has(n)){
        // ざっくりジオコード不要：主要都市は preload 済み。無ければ追加しない。
        // （ユーザーの既存主要都市で足りるはず）
      }
    });

    info.epicenters.forEach(ei => {
      inMag.value = ei.M; inDepth.value = ei.depth;
      addEpicAt(ei.lat, ei.lng);
    });

    computePredictions();
    fitToAll();
    showOverlay('読み込み', `${info.title} をロードしました。再生を押してください。`);
  }

  replayLoad?.addEventListener('click', () => {
    const key = replaySel?.value || 'none';
    if (key === 'none'){ showOverlay('読み込み','プリセットを選んでください。'); return; }
    if (key === 'custom'){
      replayFile?.click();
      return;
    }
    loadReplay(key);
  });

  replayPlay?.addEventListener('click', () => {
    if (!running) runStart?.click();
  });

  replayFile?.addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      restoreState(obj);
      showOverlay('カスタム','JSONを読み込みました。再生を押してください。');
    } catch(e){
      showOverlay('失敗', 'JSONの読み込みに失敗しました。');
    } finally {
      replayFile.value = '';
    }
  });

  /* ------------------------------------------------------------
   * Screenshot (best-effort)
   * ---------------------------------------------------------- */
  async function captureAndDownload(){
    // html2canvas があれば使う（外部読み込み前提 / タイルは CORS 必要）
    const target = document.querySelector('#mapWrap') || document.body;
    if (window.html2canvas){
      try{
        const canvas = await window.html2canvas(target, {useCORS: true, backgroundColor: null, scale: DPR});
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url; a.download = `QuakeSimX_${Date.now()}.png`; a.click();
        return;
      } catch(e){
        // fallthrough
      }
    }
    // フォールバック：状態JSONを添えて案内
    const data = JSON.stringify(serializeState());
    try{
      await navigator.clipboard.writeText(data);
      showOverlay('スクリーンショット',
        '外部ライブラリ（html2canvas等）未読込のため、画像キャプチャはブラウザの機能で取得してください。状態JSONをクリップボードにコピーしました。');
    } catch{
      showOverlay('スクリーンショット',
        '外部ライブラリ（html2canvas等）未読込のため、画像キャプチャはブラウザの機能で取得してください。');
    }
  }
  btnShot?.addEventListener('click', captureAndDownload);

  /* ------------------------------------------------------------
   * Keyboard shortcuts
   * ---------------------------------------------------------- */
  window.addEventListener('keydown', (e) => {
    // 入力系（テキスト/数値/セレクト）にフォーカス時は無視
    const tag = (document.activeElement?.tagName || '').toLowerCase();
    if (['input','textarea','select'].includes(tag)) return;

    if (e.code === 'Space'){ e.preventDefault(); (running ? runPause : runResume).click(); }
    else if (e.key.toLowerCase() === 's'){ runStop.click(); }
    else if (e.key.toLowerCase() === 'f'){ fitToAll(); }
    else if (e.key === '['){ jumpBy(-5); }
    else if (e.key === ']'){ jumpBy(+5); }
    else if (e.key === '1'){ perfModeSel.value = 'off'; setPerfMode(false); }
    else if (e.key === '2'){ perfModeSel.value = 'on'; setPerfMode(true); }
    else if (e.key.toLowerCase() === 't'){
      tsuRingVis.value = (tsuRingVis.value === 'on' ? 'off' : 'on');
      tsuRingsOn = (tsuRingVis.value === 'on');
      updateRingVisibility();
    }
  });

  /* ------------------------------------------------------------
   * Misc small hooks
   * ---------------------------------------------------------- */
  // タイル種変更時に CORS の有無でスクショ挙動が変わるため注意喚起
  tileSel?.addEventListener('change', () => {
    if (!window.html2canvas) return;
    // 軽いガイダンス
    if (tileSel.value === 'toner'){
      addLog('SYS','StamenタイルはCORSによりスクショが失敗する場合があります');
    }
  });

  // 主要 UI の初期案内
  window.addEventListener('load', () => {
    // 軽量モード初期値反映
    setPerfMode(perfModeSel?.value === 'on');
    updateHud();
  });

(function(){
  const $ = s => document.querySelector(s);
  const wrap = $('#qsxEpiWrap'), input = $('#qsxEpiInput'), addBtn = $('#qsxEpiAdd'),
        clearBtn = $('#qsxEpiClear'), sug = $('#qsxEpiSuggest'), sugList = sug.querySelector('ul');

  // --- セーフ初期化（QuakeRegions / 地域配列） ---
  function readyRegions(){
    if (!window.QuakeRegions) return null;
    try { QuakeRegions.buildFixedRegions && QuakeRegions.buildFixedRegions(); } catch(e){}
    const regs = (QuakeRegions.regions||[]).slice();
    // _centroid が無ければ計算
    for (const r of regs) {
      if (!r._centroid && r._poly) {
        let la=0, lo=0; for(const p of r._poly){ la+=p[0]; lo+=p[1]; }
        r._centroid = [la/r._poly.length, lo/r._poly.length];
      }
    }
    return regs;
  }
  let REGIONS = readyRegions() || [];

  // --- 正規化 & 検索 ---
  function norm(s){
    return (s||'').normalize('NFKC')
      .replace(/\s+/g,'')
      .replace(/[ヶヵ]/g,'ケ')
      .replace(/東京都?23区/g,'東京都23区');
  }
  function parseLatLng(s){
    const m = String(s).match(/^\s*([+-]?\d+(?:\.\d+)?)\s*[, \s]\s*([+-]?\d+(?:\.\d+)?)\s*$/);
    if(!m) return null;
    const lat = +m[1], lng = +m[2];
    if(Number.isFinite(lat) && Number.isFinite(lng)) return [lat,lng];
    return null;
  }
  function scoreMatch(q, name){
    const nq = norm(q), nn = norm(name);
    if (nn === nq) return 1000;
    if (nn.startsWith(nq)) return 800 - nn.length;
    if (nn.includes(nq)) return 600 - nn.length;
    if (nq.includes(nn)) return 500 - nn.length;
    // ざっくりレーベンシュタイン風の甘い近似
    const d = Math.abs(nn.length - nq.length);
    return 300 - d*5 - (nn.indexOf(nq[0])>=0?10:50);
  }
  function searchRegions(q, limit=12){
    if (!q) return [];
    const arr = REGIONS.map(r => [scoreMatch(q, r.name), r])
      .filter(([sc]) => sc > 250)
      .sort((a,b)=> b[0]-a[0])
      .slice(0, limit)
      .map(x=>x[1]);
    return arr;
  }

  // --- サジェスト描画 ---
  let activeIdx = -1;
  function renderSuggest(items){
    if (!items.length){ sug.style.display='none'; sugList.innerHTML=''; activeIdx=-1; return; }
    sugList.innerHTML = items.map((r,i)=>{
      const tag = r.basin ? `<span class="qsx-pill">${r.basin}</span>` : `<span class="qsx-pill">内陸</span>`;
      return `<li data-idx="${i}"><span>${r.name}</span>${tag}</li>`;
    }).join('');
    sug.style.display='block';
    activeIdx = -1;
  }
  function currentItems(){
    return [...sugList.querySelectorAll('li')].map(li=>{
      const i = +li.getAttribute('data-idx');
      return { li, region: lastResults[i] };
    });
  }

  // --- 震源追加 ---
  function panTo(lat,lng){
    try{ if(window.map && map.setView){ map.setView([lat,lng], Math.max(map.getZoom?.()||0, 7)); } }catch(e){}
  }
  function addEpic(lat,lng, label){
    if (typeof window.addEpicAt === 'function'){
      window.addEpicAt(lat, lng);
    } else {
      document.dispatchEvent(new CustomEvent('qsx:add-epic', { detail:{ lat, lng, name:label } }));
    }
    panTo(lat,lng);
  }
  function addEpicAtRegion(r){
    const c = r._centroid; if (!c){ toast('地域ポリゴン未初期化'); return; }
    addEpic(+c[0], +c[1], r.name);
  }

  // 簡易トースト
  let toastTid=null;
  function toast(msg){
    let el = document.getElementById('qsxToast');
    if(!el){
      el = document.createElement('div'); el.id='qsxToast';
      Object.assign(el.style,{
        position:'absolute', left:'50%', top:'86px', transform:'translateX(-50%)',
        zIndex:99999, background:'var(--epi-panel)', color:'var(--epi-text)',
        padding:'10px 14px', borderRadius:'10px', border:'1px solid var(--epi-border)',
        boxShadow:'var(--epi-shadow)', pointerEvents:'none'
      });
      document.body.appendChild(el);
    }
    el.textContent = msg; el.style.opacity='1';
    clearTimeout(toastTid); toastTid=setTimeout(()=> el.style.opacity='0', 1400);
  }

  // メイン処理
  let lastResults = [];
  function onInput(){
    const v = input.value.trim();
    // 緯度経度ならサジェスト閉じ
    if (parseLatLng(v)){ renderSuggest([]); return; }
    lastResults = searchRegions(v, 14);
    renderSuggest(lastResults);
  }
  function onAdd(){
    const v = input.value.trim();
    const xy = parseLatLng(v);
    if (xy){ addEpic(xy[0], xy[1], v); return; }
    const list = lastResults.length ? lastResults : searchRegions(v, 1);
    if (!list.length){ toast('見つかりません'); return; }
    addEpicAtRegion(list[0]);
  }
  function onClear(){
    input.value=''; renderSuggest([]); input.focus();
  }

  // イベント
  input.addEventListener('input', onInput);
  input.addEventListener('keydown', e=>{
    const items = [...sugList.querySelectorAll('li')];
    if (!items.length) { if(e.key==='Enter') onAdd(); return; }
    if (e.key === 'ArrowDown'){ activeIdx = Math.min(activeIdx+1, items.length-1); }
    else if (e.key === 'ArrowUp'){ activeIdx = Math.max(activeIdx-1, 0); }
    else if (e.key === 'Enter'){
      if (activeIdx >= 0){ items[activeIdx].click(); return; }
      onAdd(); return;
    } else if (e.key === 'Escape'){ renderSuggest([]); return; }
    items.forEach((li,i)=> li.classList.toggle('active', i===activeIdx));
  });
  addBtn.addEventListener('click', onAdd);
  clearBtn.addEventListener('click', onClear);
  sug.addEventListener('mousedown', e=>{
    const li = e.target.closest('li'); if (!li) return;
    const idx = +li.getAttribute('data-idx');
    const r = lastResults[idx]; if (!r) return;
    addEpicAtRegion(r);
    renderSuggest([]); input.blur();
  });

  // API: 外部からも呼べるように
  window.qsxAddEpicByName = function(query){
    input.value = query||''; onInput(); onAdd();
  };

  // フェイルセーフ：初期化が早すぎた場合は再取り込み
  document.addEventListener('readystatechange', () => {
    if (REGIONS.length === 0 && window.QuakeRegions){
      const r = readyRegions(); if (r && r.length){ REGIONS = r; }
    }
  });

  // デバッグヒント（必要なら一度だけ見える）
  if (!window.QuakeRegions) {
    console.warn('[QSX] QuakeRegions が見つかりません。先にエンジン(Part1/2+Part2/2)を読み込んでください。');
  }
 });

/* ============================================================
 * EEW（超低遅延）モード — 最小依存・堅牢実装
 * - WebSocket: 低遅延受信（推奨）
 * - HTTP: 簡易ポーリング/ロングポーリング
 * - Demo: 疑似EEW（初報→更新→最終）を生成
 * 依存: addEpicAt(), epicenters[], nameEpicentralRegion(), inferEventType(),
 *       computePredictions()(任意), speakJP()(任意), addLog()(任意)
 * ============================================================ */
(function initEEW(){
  // ---- DOM refs
  const modeSel = document.getElementById('modeSel');
  const modeBadge = document.getElementById('modeBadge');

  const selTr   = document.getElementById('eewTransport');
  const inUrl   = document.getElementById('eewUrl');
  const inInt   = document.getElementById('eewInterval');
  const inAuto  = document.getElementById('eewAutostart');
  const inHold  = document.getElementById('eewHold');
  const inAlpha = document.getElementById('eewAlpha');
  const inMax   = document.getElementById('eewMax');

  const btnCon  = document.getElementById('eewConnect');
  const btnDis  = document.getElementById('eewDisconnect');
  const btnD1   = document.getElementById('eewDemo1');
  const btnDSt  = document.getElementById('eewDemoStorm');

  if (!selTr || !btnCon) return; // HTML未追加なら何もしない

  // ---- State
  const ST = {
    on:false,
    tr:'ws',
    url:'',
    intMs:2000,
    alpha:0.35,
    holdSec:45,
    autostart:true,
    ws:null,
    timer:null,
    seen:new Set(),                 // 重複防止（id+serial）
    events:new Map(),               // id -> { id, origin, epi, lastSerial, final, cancel, timerRemove }
    recomputePending:false,
    lastRecompute:0
  };

  function isNumber(x){ return typeof x==='number' && isFinite(x); }
  function now(){ return performance.now(); }
  function log(tag,msg){ try{ addLog?.(tag || 'EEW', msg); }catch(_){} }
  function toBool(v){ return v===true || v==='true' || v===1 || v==='1'; }
  function getAlpha(){ const a=parseFloat(inAlpha?.value||'0.35'); return Math.max(0.05, Math.min(0.95, isFinite(a)?a:0.35)); }
  function getMax(){ const m=parseInt(inMax?.value||'6',10); return Math.max(1, Math.min(20, isFinite(m)?m:6)); }
  function setBadge(on){
    if(!modeBadge) return;
    const base = (modeSel?.value||'').toUpperCase();
    modeBadge.textContent = `Mode: ${base}${on?' | EEW':''}`;
  }
  function setButtons(){
    btnCon.disabled = ST.on;
    btnDis.disabled = !ST.on;
  }
  function startIfNeeded(){
    if (!ST.autostart) return;
    if (!window.running){
      if (typeof runStart?.click==='function'){ runStart.click(); }
      else {
        // 最低限のフォールバック
        window.running = true; window.t0 = performance.now(); window.tOffset = 0;
      }
    }
  }
  function throttleRecompute(){
    const nowT = now();
    if (nowT - ST.lastRecompute > 180){
      ST.lastRecompute = nowT;
      try{ if (typeof computePredictions==='function') computePredictions(); }catch(_){}
      return;
    }
    if (!ST.recomputePending){
      ST.recomputePending = true;
      setTimeout(()=>{
        ST.recomputePending = false;
        ST.lastRecompute = now();
        try{ if (typeof computePredictions==='function') computePredictions(); }catch(_){}
      }, 180);
    }
  }

  // ---- パーサ（柔軟にフィールド名を解釈）
  function unifyOne(raw){
    if (!raw || typeof raw!=='object') return null;

    // 配列ラップされた場合は先に解く
    if (Array.isArray(raw)) return raw.map(unifyOne).filter(Boolean);

    // 候補名の取り出し
    const get = (obj, keys, dflt=null) => {
      for (const k of keys) {
        if (obj[k]!==undefined && obj[k]!==null) return obj[k];
      }
      return dflt;
    };

    const id     = String(get(raw, ['eewId','id','event_id','eventId','code','qid','uuid'], 'eew:'+Date.now()));
    const serial = parseInt(get(raw, ['serial','report','report_num','reportNo','serialNo','no'], 1), 10) || 1;
    const lat    = +get(raw, ['lat','latitude','y'], NaN);
    const lng    = +get(raw, ['lng','lon','longitude','x'], NaN);
    const depKm  = +get(raw, ['dep','depth','depth_km','depthKm'], 30);
    const mag    = +get(raw, ['mag','M','magnitude'], 5.0);

    // 発震時刻
    let tms = get(raw, ['originTime','ot','time','ts','timestamp'], null);
    if (typeof tms === 'string') {
      const t = Date.parse(tms);
      if (isFinite(t)) tms = t;
    }
    if (!isNumber(tms)) tms = Date.now();

    // ステータス
    let status = get(raw, ['status','phase','alert_status','type'], 'Update');
    const isFinal = toBool(get(raw, ['final','is_final','isFinal'], false)) || String(status||'').toLowerCase()==='final';
    const isCancel= toBool(get(raw, ['cancel','is_cancel','isCancel'], false)) || String(status||'').toLowerCase()==='cancel';
    if (isFinal)  status='Final';
    if (isCancel) status='Cancel';

    // 任意: 震央地名・確度など
    const region = get(raw, ['region','place','area','epicenter'], null);
    const conf   = get(raw, ['confidence','quality','rank'], null);

    if (!isFinite(lat) || !isFinite(lng)) return null;

    return { id, serial, lat, lng, depthKm: depKm, mag, originTime: tms, status, region, conf };
  }

  function unify(raw){
    if (Array.isArray(raw)) return raw.map(unifyOne).filter(Boolean);
    const u = unifyOne(raw);
    return u ? [u] : [];
  }

  // ---- 取り込み（初報→更新→最終/取消）
  function ingest(u){
    const key = u.id+':'+u.serial;
    if (ST.seen.has(key)) return; // 同一通番は捨てる
    ST.seen.add(key);

    let rec = ST.events.get(u.id);

    // 1) 初報（未登録）
    if (!rec){
      // 超過時は古い案件を整理
      if (ST.events.size >= getMax()){
        const oldestId = [...ST.events.values()]
          .sort((a,b)=>(a.origin||0)-(b.origin||0))[0]?.id;
        if (oldestId){
          try{
            const old = ST.events.get(oldestId);
            if (old?.epi?.marker) old.epi.marker.remove?.();
          }catch(_){}
          ST.events.delete(oldestId);
        }
      }

      // 震源を作成
      if (window.inMag)   inMag.value   = clampMag(u.mag);
      if (window.inDepth) inDepth.value = clampDepth(u.depthKm);
      addEpicAt(u.lat, u.lng);

      const epi = epicenters[epicenters.length-1];
      if (epi){
        epi.eventType = inferEventType?.({lat:u.lat,lng:u.lng,depth:u.depthKm}) || epi.eventType;
        epi.region    = (u.region || nameEpicentralRegion?.(u.lat,u.lng) || epi.region);
        epi.origin    = u.originTime;
        epi._isEEW    = true;
        epi._confidence = u.conf || null;

        // tooltip拡張
        try {
          epi.marker?.bindTooltip(
            `EEW 初報\nM${u.mag.toFixed(1)} / ${u.depthKm.toFixed(0)}km\n${epi.region || ''}`,
            { direction:'top', offset:[0,-16] }
          );
        }catch(_){}
      }

      ST.events.set(u.id, {
        id:u.id, origin:u.originTime, epi, lastSerial:u.serial, final:false, cancel:false, timerRemove:null
      });

      log('EEW', `初報 id=${u.id} M${u.mag.toFixed(1)} 深さ${u.depthKm.toFixed(0)}km ${epi?.region||''}`);
      try{ speakJP?.(`緊急地震速報。マグニチュード ${u.mag.toFixed(1)}、深さ ${u.depthKm.toFixed(0)} キロ、${epi?.region||'震源不明'}`); }catch(_){}
      startIfNeeded();
      throttleRecompute();
      return;
    }

    // 2) 更新 or 最終/取消
    const epi = rec.epi;
    if (!epi) return;

    // スムージングでジッタ抑制
    const a = getAlpha();
    if (isFinite(u.lat) && isFinite(u.lng)){
      epi.lat = a*u.lat + (1-a)*epi.lat;
      epi.lng = a*u.lng + (1-a)*epi.lng;
      try{ epi.marker?.setLatLng([epi.lat, epi.lng]); }catch(_){}
      epi._moved = true;
    }
    if (isFinite(u.depthKm)) epi.depth = a*u.depthKm + (1-a)*epi.depth;
    if (isFinite(u.mag))     epi.M     = a*u.mag     + (1-a)*epi.M;

    // 地名/確度の更新
    if (u.region){
      epi.region = u.region;
    }else{
      try{ epi.region = nameEpicentralRegion?.(epi.lat, epi.lng) || epi.region; }catch(_){}
    }
    epi._confidence = (u.conf ?? epi._confidence);

    // tooltip更新
    try{
      const line2 = epi.region || '';
      const line3 = (u.status==='Final' ? '最終' : (u.status==='Cancel'?'取消':'更新')) +
                    (epi._confidence ? ` / conf:${epi._confidence}` : '');
      epi.marker?.closeTooltip();
      epi.marker?.bindTooltip(
        `EEW ${line3}\nM${epi.M.toFixed(1)} / ${epi.depth.toFixed(0)}km\n${line2}`,
        { direction:'top', offset:[0,-16] }
      );
    }catch(_){}

    rec.lastSerial = Math.max(rec.lastSerial|0, u.serial|0);

    // ステータス処理
    if (u.status === 'Cancel'){
      rec.cancel = true;
      log('EEW', `取消 id=${rec.id}（保持${ST.holdSec}s）`);
      scheduleRemove(rec);
    }else if (u.status === 'Final'){
      rec.final = true;
      log('EEW', `最終 id=${rec.id}（保持${ST.holdSec}s）`);
      scheduleRemove(rec);
    }else{
      log('EEW', `更新 id=${rec.id} #${u.serial} M${epi.M.toFixed(1)} 深さ${epi.depth.toFixed(0)}km`);
    }

    throttleRecompute();
  }

  function scheduleRemove(rec){
    clearRemove(rec);
    const hold = Math.max(0, parseInt(inHold?.value||'45',10)|0);
    rec.timerRemove = setTimeout(()=>{
      try{
        if (rec.epi?.marker) rec.epi.marker.remove?.();
        // 波面/リング等の付帯オブジェクトも必要に応じ削除（ここでは簡略）
      }catch(_){}
      ST.events.delete(rec.id);
      throttleRecompute();
    }, hold*1000);
  }
  function clearRemove(rec){
    if (rec?.timerRemove){ clearTimeout(rec.timerRemove); rec.timerRemove=null; }
  }

  // ---- Transport: WS / POLL / DEMO
  function connect(){
    ST.tr = selTr.value || 'ws';
    ST.url = (inUrl?.value||'').trim();
    ST.intMs = Math.max(500, parseInt(inInt?.value||'2000',10)|0);
    ST.alpha = getAlpha();
    ST.holdSec = Math.max(0, parseInt(inHold?.value||'45',10)|0);
    ST.autostart = (inAuto?.value||'on')==='on';

    if (ST.tr!=='demo' && !ST.url){
      showOverlay?.('URL未指定','EEWフィードURLを入力してください。');
      return;
    }

    ST.on = true; setButtons(); setBadge(true);

    if (ST.tr === 'ws'){
      startWS();
    }else if (ST.tr === 'poll'){
      startPoll();
    }else{
      startDemo();
    }
    log('EEW', `開始: ${ST.tr}${ST.url?` ${ST.url}`:''}`);
  }

  function disconnect(){
    ST.on = false;
    stopWS(); stopPoll(); stopDemo();
    setButtons(); setBadge(false);
    log('EEW','停止');
  }

  // --- WS ---
  function startWS(){
    stopWS();
    try{
      ST.ws = new WebSocket(ST.url);
      ST.ws.onopen  = ()=> log('EEW','WS接続');
      ST.ws.onclose = ()=> log('EEW','WS切断');
      ST.ws.onerror = e => log('EEW','WSエラー');
      ST.ws.onmessage = (ev)=>{
        try{
          const data = JSON.parse(ev.data);
          const arr = unify(data);
          for (const u of arr) ingest(u);
        }catch(_){
          // 1行1JSONで来る場合の保険
          try{
            const u = unifyOne(JSON.parse(ev.data));
            if (u) ingest(u);
          }catch(__){}
　　　　
　// 例: { type:'stationIntensity', ts: 1719999999999, stations:[
//        { code:'11123', name:'東京', shindo:'4' },
//        { name:'横浜市中区', shindo:'5弱' },
//        { lat:35.68, lng:139.76, shindo:'3' }
//      ] }
try {
  const msg = JSON.parse(ev.data);
  if (msg && (msg.type === 'stationIntensity' || msg.type === 'intensity' || msg.kind === 'obs')) {
    if (Array.isArray(msg.stations)) {
      let applied = 0;
      for (const p of msg.stations) {
        // p: {code?, name?, lat?, lng?, shindo, ts?}
        if (p && p.shindo) {
          if (applyRealtimeIntensity(p)) applied++;
        }
      }
      if (applied > 0) canvasDirty = true;
    }
  }
} catch(e) { /* noop */ }

        }
      };
    }catch(err){
      log('EEW', 'WS接続失敗: '+String(err).slice(0,90));
    }
  }
  function stopWS(){
    try{ ST.ws?.close?.(); }catch(_){}
    ST.ws = null;
  }

// ====== 受信→既存ステーション更新（追加しない版） ======
const OBS_MATCH_MAX_KM = 25; // これより遠い観測は無視（任意で調整）

function findNearestStation(lat, lng, maxKm = OBS_MATCH_MAX_KM){
  let best = null, bestKm = Infinity;
  for (const s of stations){
    if (!s.visible) continue;
    const d = hav(lat, lng, s.lat, s.lng) / 1000;
    if (d < bestKm){ best = s; bestKm = d; }
  }
  return (best && bestKm <= maxKm) ? { st: best, km: bestKm } : null;
}

function normalizeJMALabelOrIdx(v){
  // v: 文字列('5弱','4','0'など) or 数値(0..8相当) どちらでもOKにする
  const label2idx = { '0':0,'1':1,'2':2,'3':3,'4':4,'5弱':5,'5強':6,'6弱':7,'6強':8,'7':9 };
  if (typeof v === 'number' && isFinite(v)){
    const idx = Math.max(0, Math.min(9, Math.round(v)));
    const labels = ['0','1','2','3','4','5弱','5強','6弱','6強','7'];
    return { label: labels[idx], idx };
  }
  const s = String(v ?? '').trim();
  if (s in label2idx) return { label: s, idx: label2idx[s] };
  // 不明なら 0 扱い
  return { label: '0', idx: 0 };
}

function applyObsToNearestStation(obs){
  // obs: {lat, lng, intensity, pga?, name?}
  if (!obs || !isFinite(obs.lat) || !isFinite(obs.lng)) return;

  const hit = findNearestStation(obs.lat, obs.lng, OBS_MATCH_MAX_KM);
  if (!hit){ addLog('S', `観測を棄却（${OBS_MATCH_MAX_KM}km超）`); return; }

  const { st, km } = hit;
  const j = normalizeJMALabelOrIdx(obs.intensity);
  const color = colorForIdx(j.idx);  // 既存パレットを利用

  // CanvasでもDOMでも見えるよう両対応で更新
  st._lastBadge = j.label;           // Canvas描画で使う
  st._obsColor  = color;             // Canvas描画で使う

  // DOMアイコンも更新（軽量モードOFFの時）
  if (!canvasEnabled && st.marker){
    const html = `
      <div class="station-wrap">
        <div class="station-dot" style="background:${color}">${j.label}</div>
        ${st.name ? `<div class="station-label">${st.name}</div>` : ``}
      </div>
    `;
    st.marker.setIcon(L.divIcon({ html, className:'', iconSize:[40,40] }));
  }

  canvasDirty = true;

  const p = obs.pga != null ? ` / PGA:${(+obs.pga).toFixed(3)}g` : '';
  const nm = st.name || '(無名)';
  addLog('S', `観測 ${nm} 震度${j.label}（~${km.toFixed(1)}km）${p}`);
}


  // --- POLL ---
  async function pollOnce(){
    if (!ST.on || ST.tr!=='poll') return;
    try{
      const res = await fetch(ST.url, { cache:'no-store' });
      const json = await res.json();
      const arr = unify(json);
      // 同一idで古いserialが混じることがあるので serial昇順で
      arr.sort((a,b)=>(a.id===b.id) ? ((a.serial|0)-(b.serial|0)) : 0);
      for (const u of arr) ingest(u);
    }catch(err){
      log('EEW','poll失敗: '+String(err).slice(0,90));
    }
  }
  function startPoll(){
    stopPoll();
    pollOnce();
    ST.timer = setInterval(pollOnce, ST.intMs);
  }
  function stopPoll(){
    if (ST.timer){ clearInterval(ST.timer); ST.timer=null; }
  }

  // --- DEMO ---
  function startDemo(){
    stopDemo();
    // 何もしない（ボタンで単発 or ストーム）
  }
  function stopDemo(){ /* no-op */ }

  // デモ：単一案件（初報→更新→最終）
  function demoOnce(){
    const id = 'demo:'+Math.floor(Math.random()*1e9);
    const base = {
      id, serial:1, lat: 35.35 + (Math.random()-0.5)*0.6, lng: 139.20+(Math.random()-0.5)*0.6,
      depthKm: 40+Math.random()*30, mag: 5.3+Math.random()*0.7, originTime: Date.now(), status:'Update', region:'関東地方'
    };
    ingest(base);
    setTimeout(()=> ingest({...base, serial:2, lat:base.lat+0.08, lng:base.lng-0.06, depthKm: base.depthKm, mag: base.mag+0.3, status:'Update'}), 900);
    setTimeout(()=> ingest({...base, serial:3, lat:base.lat+0.10, lng:base.lng-0.02, depthKm: base.depthKm+5, mag: base.mag+0.5, status:'Final'}), 1800);
  }

  // デモ：ストーム（3案件を時間差で）
  function demoStorm(){
    demoOnce();
    setTimeout(demoOnce, 1200);
    setTimeout(demoOnce, 2400);
  }

  // ---- UI events
  btnCon.addEventListener('click', connect);
  btnDis.addEventListener('click', disconnect);
  btnD1?.addEventListener('click', demoOnce);
  btnDSt?.addEventListener('click', demoStorm);

  // モード表示
  modeSel?.addEventListener('change', ()=>{
    if ((modeSel.value||'')==='EEW') setBadge(!!ST.on);
    else setBadge(false);
  });

  // ページ離脱時のクリーンアップ
  window.addEventListener('beforeunload', ()=>{ try{ ST.ws?.close(); }catch(_){ } });

})();

/* =======================================================================
 * EEW Ultra-Low-Latency glue v1.2  —  リアルタイム受信→画面反映（丸ごと追加）
 * できること：
 *  1) 受信データをアラートログに整形表示（推定最大震度/上位観測点）
 *  2) 到達タイムラインにEEW（P/S）の到達見込みを表示
 *  3) マップにP波・S波リングをリアルタイム描画（originTime基準）
 * 依存：map, L, stations, epicenters, addEpicAt, arrivals, estimatePGA, pgaToJMA,
 *       colorForIdx, addLog(tag,msg), timeline, ringVisセレクタ, vp, vs
 * ======================================================================= */

(function(){
  // ------------------------------
  // 内部ステート
  // ------------------------------
  const EEW = {
    events: new Map(), // id -> {id,serial,lat,lng,depth,mag,originUnix,status,epi}
    animReq: 0
  };

  // リング見た目
  const PSTYLE = { color:'#5ab0ff', weight:2, opacity:0.9, fillOpacity:0 };
  const SSTYLE = { color:'#ff6b6b', weight:2, opacity:0.9, fillOpacity:0 };

  // 受信ペイロードを緩く正規化
  function norm(raw){
    const d = (typeof raw === 'string') ? JSON.parse(raw) : (raw || {});
    // 配列が来たら最後（最新）を使う
    const r = Array.isArray(d) ? d[d.length-1] : d;

    const id     = r.id || r.eewId || r.eewid || r.eventId || r.eventid || r.serial || r.report || 'eew-'+Date.now();
    const serial = r.serial || r.report || r.seq || r.count || 0;
    const lat    = +((r.lat ?? r.latitude ?? r.lat_deg ?? r.y) || 0);
    const lng    = +((r.lon ?? r.lng ?? r.longitude ?? r.long_deg ?? r.x) || 0);
    const dep    = +((r.depth ?? r.dep ?? r.depth_km) ?? 30);
    const mag    = +((r.mag ?? r.M ?? r.magnitude) ?? 6.0);
    // origin time: ISO or epoch(ms|s)
    let ot = r.originTime || r.time || r.origintime || r.ot || r.timestamp;
    let originUnix = null;
    if(typeof ot === 'number'){
      originUnix = (ot > 2e10 ? ot/1000 : (ot > 1e10 ? ot/1000 : ot)); // ms→s に補正
    }else if(typeof ot === 'string'){
      const t = Date.parse(ot);
      if (!isNaN(t)) originUnix = t/1000;
    }
    if (!originUnix) originUnix = Date.now()/1000;

    // status（cancel/final 等を緩く）
    const s = (r.status || r.cancel || r.final || r.stage || '').toString().toLowerCase();
    let status = 'update';
    if (['cancel','canceled','cancelled','stop'].includes(s)) status = 'cancel';
    if (['final','end','ended','complete'].includes(s)) status = 'final';

    return { id, serial:+serial, lat, lng, depth:dep, mag, originUnix, raw:r, status };
  }

  // EEWイベントを upsert（なければ震源マーカーも作る）
  function upsertEEW(e){
    let rec = EEW.events.get(e.id);
    if (!rec){
      // 震源マーカー作成（UIロック中でもOK）
      addEpicAt(e.lat, e.lng);
      const epi = epicenters[epicenters.length-1];
      epi.M = e.mag; epi.depth = e.depth;
      epi.marker?.closeTooltip();
      epi.marker?.bindTooltip(`M${epi.M.toFixed(1)} / ${epi.depth.toFixed(1)}km`, {direction:'top', offset:[0,-16]});
      // リング生成
      epi.pCircle = L.circle([e.lat, e.lng], {radius:10, ...PSTYLE}).addTo(map);
      epi.sCircle = L.circle([e.lat, e.lng], {radius:10, ...SSTYLE}).addTo(map);
      rec = { ...e, epi };
      EEW.events.set(e.id, rec);
    }else{
      // 更新：位置やMwが変わることがある
      Object.assign(rec, e);
      const { epi } = rec;
      if (epi){
        if (epi.lat !== e.lat || epi.lng !== e.lng){
          epi.lat = e.lat; epi.lng = e.lng; epi._moved = true;
          epi.marker?.setLatLng([e.lat, e.lng]);
          epi.pCircle?.setLatLng([e.lat, e.lng]);
          epi.sCircle?.setLatLng([e.lat, e.lng]);
        }
        epi.M = e.mag; epi.depth = e.depth;
        epi.marker?.closeTooltip();
        epi.marker?.bindTooltip(`M${epi.M.toFixed(1)} / ${epi.depth.toFixed(1)}km`, {direction:'top', offset:[0,-16]});
      }
    }
    return rec;
  }

  // ステーション毎に P/S 到達・PGA・震度を再計算
  function refreshPred(rec){
    const epi = rec.epi;
    if (!epi) return { maxIdx:0, top:[] };
    let maxIdx = 0;
    const rows = [];

    for (const s of stations){
      if (s.visible === false) continue;
      const arr = arrivals(epi, s); // {tP,tS,Rkm,Hkm}（秒 / km）
      // EEWは originUnix からの経過秒で現在時刻を決める
      const elapsed = Math.max(0, Date.now()/1000 - rec.originUnix);

      const PGA = estimatePGA(epi.M, arr.Rkm, epi.depth, epi.lat, epi.lng, s.lat, s.lng); // g
      const J = pgaToJMA(PGA);
      maxIdx = Math.max(maxIdx, J.idx);

      s.pred = {
        arrP: rec.originUnix + arr.tP,
        arrS: rec.originUnix + arr.tS,
        pga: PGA, jma: J, color: colorForIdx(J.idx)
      };

      // バッジ（S到達済は震度、未到達は空バッジにして Canvas 側でカウントダウン）
      s._lastBadge = (elapsed >= arr.tS) ? J.sh : '';
      // ログ/タイムライン用に収集
      rows.push({
        name: s.name || `(${s.lat.toFixed(2)},${s.lng.toFixed(2)})`,
        arrP: s.pred.arrP, arrS: s.pred.arrS, jma: J, sRef: s
      });

      // マーカー色（非Canvas時）
      if (!canvasEnabled && s.marker){
        s.marker.getElement()?.style && (s.marker.getElement().style.background = s._lastBadge ? s.pred.color : '#57c7ff');
      }
    }

    // タイムライン更新（S到達時刻の昇順）
    rows.sort((a,b)=>a.arrS-b.arrS);
    renderTimeline(rec, rows);

    // 上位5を返す（ログ表示）
    const top = rows
      .slice(0, Math.min(5, rows.length))
      .map(r => `${r.name}: ${r.jma.sh || '0'}`);
    return { maxIdx, top };
  }

  // タイムライン描画
  function renderTimeline(rec, rows){
    const now = Date.now()/1000;
    const lines = rows.slice(0, 20).map(r=>{
      const leftP = r.arrP - now;
      const leftS = r.arrS - now;
      const tP = leftP<=0 ? 'P到達' : `P ${leftP.toFixed(1)}s`;
      const tS = leftS<=0 ? 'S到達' : `S ${leftS.toFixed(1)}s`;
      return `<div class="item small">
        <span class="tag p">P</span><span>${tP}</span>
        <span class="tag s" style="margin-left:6px">S</span><span>${tS}</span>
        <span style="margin-left:6px">→ <b>${r.jma.sh || '0'}</b></span>
        <span class="time mono" style="margin-left:auto">${r.name}</span>
      </div>`;
    });
    if (timeline){
      const head = `<div class="small" style="margin-bottom:6px">EEW ${rec.id} 予測（M${rec.mag.toFixed(1)}/深さ${rec.depth.toFixed(0)}km）</div>`;
      timeline.innerHTML = head + (lines.join('') || 'データなし');
    }
    // Canvas再描画
    if (typeof canvasDirty !== 'undefined') canvasDirty = true;
  }

  // リング半径更新アニメ
  function ensureAnim(){
    if (EEW.animReq) return;
    const loop = ()=>{
      EEW.animReq = requestAnimationFrame(loop);
      const showRings = (typeof ringVis !== 'undefined') ? (ringVis.value === 'on') : true;
      const now = Date.now()/1000;
      for (const rec of EEW.events.values()){
        const epi = rec.epi; if(!epi) continue;
        const t = Math.max(0, now - rec.originUnix); // s
        if (epi.pCircle){
          epi.pCircle.setStyle({opacity: showRings?0.9:0, fillOpacity:0});
          epi.pCircle.setRadius(Math.max(10, t * (typeof vp==='number'?vp:6) * 1000)); // km/s → m
        }
        if (epi.sCircle){
          epi.sCircle.setStyle({opacity: showRings?0.9:0, fillOpacity:0});
          epi.sCircle.setRadius(Math.max(10, t * (typeof vs==='number'?vs:3.5) * 1000));
        }
      }
    };
    EEW.animReq = requestAnimationFrame(loop);
  }

  // 受信→反映のメイン
  function handleEEWMessage(payload){
    try{
      const e = norm(payload);
      const rec = upsertEEW(e);

      // 予測更新
      const { maxIdx, top } = refreshPred(rec);

      // ログ出力
      const epiName = (typeof nameEpicentralRegion==='function')
        ? nameEpicentralRegion(rec.epi.lat, rec.epi.lng)
        : `${rec.epi.lat.toFixed(2)}, ${rec.epi.lng.toFixed(2)}`;
      addLog('EEW', `受信 id=${rec.id} #${rec.serial} 震源:${epiName}  M${rec.mag.toFixed(1)} 深さ${rec.depth.toFixed(0)}km  最大予測:${['0','1','2','3','4','5弱','5強','6弱','6強','7'][maxIdx]||''}`);
      if (top.length) addLog('EEW', '上位観測点: ' + top.join(' / '));

      // リング開始
      ensureAnim();

      // キャンセル／最終
      if (e.status === 'cancel'){
        addLog('EEW', `キャンセル: id=${rec.id}`);
        // リングを薄くして数秒後に除去
        fadeOut(rec);
      }else if (e.status === 'final'){
        addLog('EEW', `最終報: id=${rec.id}`);
      }
    }catch(err){
      addLog('EEW', 'parse失敗: ' + (err?.message || err));
      console.error(err);
    }
  }

  function fadeOut(rec){
    const { epi } = rec; if (!epi) return;
    let a = 0.9;
    const timer = setInterval(()=>{
      a -= 0.12;
      if (epi.pCircle) epi.pCircle.setStyle({opacity:Math.max(0,a)});
      if (epi.sCircle) epi.sCircle.setStyle({opacity:Math.max(0,a)});
      if (a<=0){
        clearInterval(timer);
        if (epi.pCircle){ map.removeLayer(epi.pCircle); epi.pCircle=null; }
        if (epi.sCircle){ map.removeLayer(epi.sCircle); epi.sCircle=null; }
      }
    }, 120);
  }

  // ringVisの手動切替にも追従
  if (typeof ringVis !== 'undefined'){
    ringVis.addEventListener('change', ()=>{
      // 即時反映（次フレームで反映されるが、見た目レスポンス用）
      const on = ringVis.value === 'on';
      for (const rec of EEW.events.values()){
        if (rec.epi?.pCircle) rec.epi.pCircle.setStyle({opacity: on?0.9:0});
        if (rec.epi?.sCircle) rec.epi.sCircle.setStyle({opacity: on?0.9:0});
      }
    });
  }

  // 外部から呼べるフック（WS側でこれを呼ぶだけでOK）
  window.handleEEWMessage = handleEEWMessage;
  window.EEW_onMessage   = handleEEWMessage;

  // dispatch イベントでも拾える
  window.addEventListener('EEW:message', (ev)=> handleEEWMessage(ev.detail));

  // 参考：コンソールから手動テスト
  // window.EEW_onMessage({id:'test',lat:35.5,lon:140.0,depth:40,mag:6.6,originTime:Date.now()});
})();

/* ============================================================
 * SFX (WebAudio Earcons) — IIFE内版（Audio/TTS直後に貼付）
 * 既存の ensureAudio(), audioCtx, masterGain, userActivated,
 * isMuted(), volIn, stations/epicenters, カスタムイベントを利用
 * ============================================================ */
{
  let sfxInited = false;
  let sfxGain = null;
  let rumbleSrc = null, rumbleGain = null;
  const prevState = new Map(); // station.id -> {p,s,badge}

  function sfxEnsure(){
    ensureAudio();                     // 既存の audioCtx/masterGain を初期化
    if (sfxInited || !audioCtx) return;
    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 0.9;
    (masterGain ? sfxGain.connect(masterGain) : sfxGain.connect(audioCtx.destination));
    sfxInited = true;
  }
  function vol(){
    const v = parseFloat((volIn?.value)||'0.35');
    return Math.max(0, Math.min(1, v*0.9));
  }
  function canPlay(){ return userActivated && !isMuted?.(); }

  function tone({freq=440, dur=0.18, type='sine', gain=0.5, attack=0.01, release=0.08, startT}){
    if (!sfxInited || !canPlay()) return;
    const t0 = startT ?? audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(gain*vol(), t0+attack);
    g.gain.linearRampToValueAtTime(0, t0+attack+dur+release);
    osc.connect(g).connect(sfxGain);
    osc.start(t0);
    osc.stop(t0+attack+dur+release+0.02);
  }
  function blip(freqs=[880,1320], step=0.09){
    const base = audioCtx.currentTime;
    freqs.forEach((f,i)=>tone({freq:f, dur:0.07, type:'sine', gain:0.35, startT:base+i*step}));
  }

  // 地鳴り（Brown Noise）
  function startRumble(level=0.3){
    if (!sfxInited || !canPlay() || rumbleSrc) return;
    const N = 2*audioCtx.sampleRate;
    const buf = audioCtx.createBuffer(1, N, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    let last=0;
    for(let i=0;i<N;i++){
      const w = Math.random()*2-1;
      data[i] = (last + 0.02*w)/1.02; last=data[i]; data[i]*=0.8;
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buf; src.loop = true;

    const lp = audioCtx.createBiquadFilter();
    lp.type='lowpass'; lp.frequency.value = 120; lp.Q.value = 0.5;

    rumbleGain = audioCtx.createGain();
    rumbleGain.gain.value = Math.min(0.6, Math.max(0.05, level*vol()));

    src.connect(lp).connect(rumbleGain).connect(sfxGain);
    src.start();
    rumbleSrc = src;
  }
  function stopRumble(){
    try{ rumbleSrc?.stop(); }catch{}
    rumbleSrc=null; rumbleGain=null;
  }
  function setRumble(level=0.3){
    if (rumbleGain) rumbleGain.gain.setTargetAtTime(
      Math.min(0.6, Math.max(0.02, level*vol())),
      audioCtx.currentTime, 0.08
    );
  }

  function sfxPlay(tag){
    sfxEnsure();
    if (!sfxInited || !canPlay()) return;
    switch(tag){
      case 'connect':     blip([900,1200,1500],0.07); break;
      case 'disconnect':  blip([520,390],0.11); break;
      case 'error':       blip([200,160,120],0.08); break;
      case 'eew':         blip([1100,1300,1100],0.085); break;
      case 'start':       blip([700,980],0.09); startRumble(0.10); break;
      case 'stop':        blip([520],0.0); stopRumble(); break;
      case 'p-arrive':    blip([1400,1800],0.06); break;
      case 's-arrive':    blip([800,600,1000],0.09); setRumble(0.25); break;
      case 'strong': {
        const t=audioCtx.currentTime;
        tone({freq:520, dur:0.18, type:'square', gain:0.35, startT:t});
        tone({freq:780, dur:0.18, type:'square', gain:0.30, startT:t+0.12});
        setRumble(0.4);
        break;
      }
      case 'tsunami':     blip([300,450,300],0.12); break;
    }
  }

  // 観測点の到達/震度バッジ変化を監視
  let monTimer=null;
  function monitor(){
    if (!Array.isArray(stations)) return;
    for(const s of stations){
      if (!s || s.visible===false) continue;
      const prev = prevState.get(s.id)||{p:false,s:false,badge:''};
      if (s.pA && !prev.p) sfxPlay('p-arrive');
      if (s.sA && !prev.s) sfxPlay('s-arrive');
      const badge = (s._lastBadge||'').trim();
      if (badge && badge!==prev.badge){
        if (['5弱','5強','6弱','6強','7'].includes(badge)) sfxPlay('strong');
      }
      prevState.set(s.id,{p:!!s.pA,s:!!s.sA,badge});
    }
    // Mに応じて地鳴りスケール
    if (Array.isArray(epicenters) && epicenters.length){
      const M = Math.max(...epicenters.map(e=>e.M||0));
      const k = Math.max(0, Math.min(1, (M-4)/4)); // M4→0, M8→~1
      setRumble(0.15 + 0.35*k);
    }
  }
  function startMonitor(){ if (!monTimer){ sfxEnsure(); monTimer=setInterval(monitor,120);} }
  function stopMonitor(){ if (monTimer){ clearInterval(monTimer); monTimer=null; } prevState.clear(); }

  // 既存イベントにフック
  document.addEventListener('quakeSimStart', ()=>{ sfxPlay('start'); startMonitor(); });
  document.addEventListener('quakeSimStop',  ()=>{ sfxPlay('stop');  stopMonitor();  });

  // EEW WebSocket イベント（既存の名称に合わせて）
  document.addEventListener('EEW_WS_OPEN',  ()=>sfxPlay('connect'));
  document.addEventListener('EEW_WS_CLOSE', ()=>sfxPlay('disconnect'));
  document.addEventListener('EEW_WS_ERROR', ()=>sfxPlay('error'));
  document.addEventListener('EEW_MESSAGE',  ()=>sfxPlay('eew'));

  // 津波ONの初回だけ耳コーン
  let tsuNotified=false;
  setInterval(()=>{ try{
    if (!tsuNotified && window.tsunamiOn){ sfxPlay('tsunami'); tsuNotified=true; }
    if (!window.tsunamiOn) tsuNotified=false;
  }catch{} }, 5000);

  // マスター音量UIに追従（リアルタイム）
  volIn?.addEventListener('input', ()=>{ /* setRumble 内で参照するためそのまま */ });

  // デバッグ用ワンショット（必要ならコンソールから）:
  // window.__SFX = { play: sfxPlay };
}

/* ===== EEW/観測震度 テスト注入（UIとダミー受信） ======================== */
(() => {
  if (!window.addEventListener) return;

  // Topバーにテストボタンを追加
  function addTopTestButtons() {
    const holder = document.querySelector('.top-actions');
    if (!holder || document.getElementById('btnEEWTest')) return;

    const b1 = document.createElement('button');
    b1.id = 'btnEEWTest';
    b1.className = 'ghost';
    b1.type = 'button';
    b1.textContent = 'EEWテスト受信';
    b1.title = '震源・P/Sリング・ログ・TTS/ビープを一括テスト';
    b1.addEventListener('click', simulateEEWSequence);

    const b2 = document.createElement('button');
    b2.id = 'btnObsTest';
    b2.className = 'ghost';
    b2.type = 'button';
    b2.textContent = '観測震度テスト';
    b2.title = '観測点に色付き震度を反映するテスト';
    b2.addEventListener('click', simulateObservedIntensities);

    holder.appendChild(b1);
    holder.appendChild(b2);
  }

  // -------- ユーティリティ（色/ラベル/音） --------
  const JMA_ORDER = ['0','1','2','3','4','5弱','5強','6弱','6強','7'];
  function labelToIdx(l){
    const i = JMA_ORDER.indexOf(String(l).trim());
    return i < 0 ? 0 : Math.min(8, i);
  }
  function colorByLabel(l){ return (typeof colorForIdx==='function') ? colorForIdx(labelToIdx(l)) : '#57c7ff'; }

  function addLogLine(tag, msg){ try { addLog(tag, msg); } catch { console.log(`[${tag}] ${msg}`); } }

  function playBeepOnce(freq=880, ms=220){
    try {
      ensureAudio();
      const ctx = window.audioCtx;
      const g = ctx.createGain();
      const o = ctx.createOscillator();
      o.type = 'sine';
      o.frequency.value = freq;
      g.gain.setValueAtTime(0.001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime((typeof getTtsVolume==='function'? getTtsVolume():0.3), ctx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + ms/1000);
      o.connect(g); g.connect(window.masterGain || ctx.destination);
      o.start(); o.stop(ctx.currentTime + ms/1000 + 0.05);
    } catch(e) { /* no-op */ }
  }

  function sayJP(text){
    try { speakJP(text); } catch { /* TTS未初期化時は無視 */ }
  }

  // --------- ① EEW一括テスト（震源→リング→ログ/TTS/ビープ） ----------
  async function simulateEEWSequence(){
    // 任意の沖合：福島県沖あたり
    const lat = 37.50, lng = 141.70, M = 6.6, depth = 60;

    // 画面に震源を出す（既存APIを最大限利用）
    try {
      if (window.inMag)   inMag.value   = M;
      if (window.inDepth) inDepth.value = depth;
      addEpicAt(lat, lng);
    } catch(e){
      console.warn('addEpicAt 失敗: ', e);
    }

    // 予測計算 & ズーム調整
    try { computePredictions?.(); } catch {}
    try { fitAllBtn?.click(); } catch {}

    // P/Sリングが回るシミュ開始（UI連携）
    try { runStart?.click(); } catch {}

    // ログ＋音声
    addLogLine('EEW', `テスト: M${M} 深さ${depth}km @ ${lat.toFixed(2)},${lng.toFixed(2)}`);
    playBeepOnce(980, 200); setTimeout(()=>playBeepOnce(980, 200), 260);
    sayJP(`緊急地震速報。震源は福島県沖、マグニチュード ${M.toFixed(1)}、深さ ${depth} キロと推定。`);

    // 2秒後に観測震度も擬似反映
    setTimeout(simulateObservedIntensities, 2000);
  }

  // --------- ② 観測震度の色付き反映テスト ----------
  function simulateObservedIntensities(){
    if (!Array.isArray(window.stations) || stations.length === 0) {
      addLogLine('I', '観測点がまだ無いので自動追加します');
      try { preloadStations?.(); } catch {}
    }

    // 代表都市にダミー震度を付与
    const samples = [
      {name:'仙台', label:'6弱'},
      {name:'福島', label:'5弱'},
      {name:'水戸', label:'4'},
      {name:'いわき', label:'4'},
      {name:'宇都宮', label:'4'},
      {name:'東京', label:'3'},
      {name:'千葉', label:'3'},
      {name:'さいたま', label:'3'},
      {name:'静岡', label:'7'}
    ];

    let applied = 0;
    samples.forEach(smp => {
      const st = stations.find(s => (s.name||'').includes(smp.name));
      if (!st) return;
      // 観測震度バッジ＆色
      st._lastBadge = smp.label
      st.pA = true; st.sA = true; // 色適用のため到達済み扱い
      st.pred = st.pred || {};
      st.pred.color = colorByLabel(smp.label);
      st.visible = true;
      applied++;
    });

    if (applied > 0) {
      addLogLine('I', `観測震度（テスト）を ${applied} 地点に反映しました`);
      try { refreshStList?.(); } catch {}
      try { (window.canvasDirty = true); } catch {}
      try { drawStationsCanvas?.(); } catch {}
      // 読み上げ
      sayJP(`観測震度テスト。仙台、福島で震度 5 弱。首都圏で震度 3 から 4。`);
    } else {
      addLogLine('I', '該当する観測点名が見つかりませんでした（都市名の表記揺れに注意）');
    }
  }

  // 起動時にテストボタンを生やす
  window.addEventListener('DOMContentLoaded', addTopTestButtons);
})();

/* ============================================================
 * Force Canvas Stations ON from startup（常時ONパッチ）
 * 貼り付け位置：enableCanvasStations() が定義された「あと」
 * ========================================================== */
(() => {
  // 必要なら false にすると元の自動制御へ戻せます
  let FORCE_CANVAS_ALWAYS = true;

  function forceCanvasOn() {
    try {
      if (typeof enableCanvasStations === 'function') {
        enableCanvasStations(true);   // Canvas描画をON
      }
      // DOMマーカーを消すAPIがある場合は併用（無ければ無視されます）
      if (typeof setStationDomVisibility === 'function') {
        setStationDomVisibility(false);
      }
      if (typeof canvasDirty !== 'undefined') canvasDirty = true;
      // UIにトグルがある場合は視覚的にもONにしておく（存在しなければ無視）
      const sel = document.querySelector('#canvasStationsSel,#canvasStationsToggle');
      if (sel) { sel.value = 'on'; sel.checked = true; }
    } catch (e) {
      console.warn('[forceCanvasOn] ', e);
    }
  }

  // 既存の自動切替を“ラップ”して、常時ONを優先
  try {
    const prev = window.updateCanvasAutoToggle;
    window.updateCanvasAutoToggle = function(...args) {
      if (FORCE_CANVAS_ALWAYS) {
        forceCanvasOn();
        return; // 自動OFFを無効化
      }
      if (typeof prev === 'function') return prev.apply(this, args);
    };
  } catch {}

  // 初回起動時（DOMContentLoaded後）に即ON
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', forceCanvasOn, { once: true });
  } else {
    // 既に読み込み済みでも即ON
    forceCanvasOn();
  }

  // 実行中に他の処理でOFFにされがちなタイミングでも再適用
  document.addEventListener('quakeSimStart', forceCanvasOn);
  document.addEventListener('quakeSimStop',  forceCanvasOn);
  window.addEventListener('resize',          forceCanvasOn);

  // もし「軽量モード」トグルがあるなら、切替時にも再適用（存在しない場合は無視）
  const perfToggle = document.querySelector('#perfLite,#perfMode,#perfToggle');
  if (perfToggle) {
    perfToggle.addEventListener('change', () => forceCanvasOn());
  }
})();

/* ---- Leaflet: map init / tiles / opacity ---- */
const tileProviders = {
  osm: {
    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    attr: '&copy; OpenStreetMap contributors'
  },
  bright: {
    url: 'https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
    attr: '&copy; OpenStreetMap & Carto'
  },
  toner: {
    url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png',
    attr: '&copy; Stamen, OpenStreetMap'
  }
};
let map = L.map('map', { zoomControl: true, preferCanvas: true }).setView([36.2, 138.2], 5);
let tileLayer;
function applyTile(kind) {
  const p = tileProviders[kind] ?? tileProviders.osm;
  if (tileLayer) tileLayer.remove();
  tileLayer = L.tileLayer(p.url, { attribution: p.attr, detectRetina: true, crossOrigin: true }).addTo(map);
  // 透明度スライダ反映
  const el = document.getElementById('tileOpacity');
  if (el) tileLayer.setOpacity(parseFloat(el.value || '1'));
}
applyTile(document.getElementById('tileSel')?.value || 'osm');
document.getElementById('tileSel')?.addEventListener('change', e => applyTile(e.target.value));
document.getElementById('tileOpacity')?.addEventListener('input', e => { if (tileLayer) tileLayer.setOpacity(parseFloat(e.target.value)); });

/* ---- Heatmap (on-demand) ---- */
let heatLayer, heatPluginLoaded = false;
async function ensureHeatPlugin() {
  if (heatPluginLoaded) return;
  await new Promise((res, rej) => {
    const s = document.createElement('script');
    s.src = 'https://unpkg.com/leaflet.heat/dist/leaflet-heat.js';
    s.onload = () => { heatPluginLoaded = true; res(); };
    s.onerror = rej;
    document.head.appendChild(s);
  });
}
async function setHeat(enabled) {
  if (enabled === 'on') {
    await ensureHeatPlugin();
    if (!heatLayer) heatLayer = L.heatLayer([], { radius: 24, blur: 16, maxZoom: 12 }).addTo(map);
  } else {
    if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; }
  }
}
document.getElementById('heatToggle')?.addEventListener('change', (e) => setHeat(e.target.value));
document.getElementById('heatOpacity')?.addEventListener('input', (e) => { if (heatLayer) heatLayer.setOptions({ opacity: parseFloat(e.target.value) }); });

/* ---- TTS init (after user gesture) ---- */
const tts = {
  synth: window.speechSynthesis,
  voice: null,
  ready: false,
  pickVoice() {
    const voices = this.synth.getVoices();
    this.voice = voices.find(v => /ja/i.test(v.lang)) || voices[0] || null;
    this.ready = true;
  },
  speak(text, rate=1.0, volume=0.35) {
    if (!this.ready || !text) return;
    const utter = new SpeechSynthesisUtterance(text);
    if (this.voice) utter.voice = this.voice;
    utter.rate = rate; utter.volume = volume;
    this.synth.speak(utter);
  }
};
window.addEventListener('voiceschanged', () => tts.pickVoice(), { once: true });
// 初回のユーザー操作で有効化
['btnStart','startFromSlide','runStart'].forEach(id=>{
  const b=document.getElementById(id);
  b?.addEventListener('click', ()=>{ if (!tts.ready) tts.pickVoice(); }, { once:true });
});

/* ---- EEW connection (ws/poll) ---- */
let eewWS=null, eewPollTimer=null;
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function parseEewMessage(raw){
  try{
    const data = typeof raw === 'string' ? JSON.parse(raw) : raw;
    const arr = Array.isArray(data) ? data : [data];
    return arr.map(d => ({
      id: d.id ?? d.eewId ?? d.serial ?? crypto.randomUUID(),
      lat: Number(d.lat ?? d.latitude),
      lon: Number(d.lon ?? d.lng ?? d.longitude),
      depth: Number(d.depth ?? d.dep),
      mag: Number(d.mag ?? d.M),
      time: d.time ?? d.originTime ?? Date.now(),
      status: d.status ?? (d.final ? 'Final' : 'Update')
    }));
  } catch(_){ return []; }
}
function connectEEW(){
  const mode = document.getElementById('eewTransport')?.value || 'ws';
  const urlStr = (document.getElementById('eewUrl')?.value || '').trim();
  const hold = parseInt(document.getElementById('eewHold')?.value||'45',10);
  const interval = clamp(parseInt(document.getElementById('eewInterval')?.value||'2000',10), 500, 60000);

  // URL バリデーション
  try{
    const u = new URL(urlStr);
    if (!/^wss?:|^https?:/.test(u.protocol)) throw new Error('bad protocol');
  }catch(_){
    showToast('EEW URL が不正です（ws(s)/http(s) のみ）。');
    return;
  }

  cleanupEEW();

  if (mode === 'ws'){
    eewWS = new WebSocket(urlStr);
    eewWS.addEventListener('message', (ev)=>{
      for (const evv of parseEewMessage(ev.data)) handleEewEvent(evv, hold);
    });
    eewWS.addEventListener('open', ()=>setEewButtons(true));
    eewWS.addEventListener('close', ()=>{ setEewButtons(false); eewWS=null; });
    eewWS.addEventListener('error', ()=>showToast('EEW WebSocket エラー'));
  } else if (mode === 'poll'){
    const tick = async ()=>{
      try{
        const r = await fetch(urlStr, { cache:'no-store' });
        const j = await r.json();
        for (const evv of parseEewMessage(j)) handleEewEvent(evv, hold);
      }catch(_){ /* silent */ }
    };
    eewPollTimer = setInterval(tick, interval);
    tick();
    setEewButtons(true);
  } else {
    // demo: 任意の擬似データを流す
    const demo = { id:'demo', lat:38.2, lon:142.0, depth:24, mag:6.8, time:Date.now(), status:'Update' };
    handleEewEvent(demo, hold);
  }
}
function cleanupEEW(){
  if (eewWS){ eewWS.close(); eewWS=null; }
  if (eewPollTimer){ clearInterval(eewPollTimer); eewPollTimer=null; }
}
function setEewButtons(connected){
  document.getElementById('eewConnect')?.toggleAttribute('disabled', connected);
  document.getElementById('eewDisconnect')?.toggleAttribute('disabled', !connected);
}
function handleEewEvent(ev, holdSeconds){
  // TODO: 地図への反映・アラート表示・タイムライン追加
  console.log('EEW', ev);
  // 一例：TTS 読み上げ（設定尊重）
  const mode = document.getElementById('ttsMode')?.value || 'off';
  if (mode !== 'off'){
    const rate = parseFloat(document.getElementById('ttsRate')?.value||'1');
    const vol  = parseFloat(document.getElementById('settingsVol')?.value||'0.35');
    tts.speak(`仮EEW、マグニチュード ${ev.mag}、深さ ${ev.depth} キロ。`, rate, vol);
  }
}
document.getElementById('eewConnect')?.addEventListener('click', connectEEW);
document.getElementById('eewDisconnect')?.addEventListener('click', ()=>{ cleanupEEW(); setEewButtons(false); });

/* ---- Modal: focus trap / Esc ---- */
function trapFocus(modal){
  const focusables = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  if (!focusables.length) return;
  const first = focusables[0], last = focusables[focusables.length - 1];
  function loop(e){
    if (e.key !== 'Tab') return;
    if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
  }
  modal.addEventListener('keydown', loop);
  modal._trapDisposer = ()=> modal.removeEventListener('keydown', loop);
}
function openModal(id, opener){
  const m = document.getElementById(id); if (!m) return;
  m.hidden = false; m.setAttribute('aria-hidden','false'); m.dataset.openerId = opener?.id || '';
  const body = m.querySelector('.modal-body'); body?.focus();
  trapFocus(m);
}
function closeModal(id){
  const m = document.getElementById(id); if (!m) return;
  m.hidden = true; m.setAttribute('aria-hidden','true');
  m._trapDisposer?.(); delete m._trapDisposer;
  const op = m.dataset.openerId && document.getElementById(m.dataset.openerId);
  op?.focus();
}
// 例: 設定モーダル
document.getElementById('btnSettings')?.addEventListener('click', (e)=>openModal('settingsModal', e.currentTarget));
document.getElementById('settingsClose')?.addEventListener('click', ()=>closeModal('settingsModal'));
document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && !document.getElementById('settingsModal')?.hidden) closeModal('settingsModal'); });
/* ---- util ---- */
function showToast(msg){
  const o = document.getElementById('overlay');
  document.getElementById('ovTitle').textContent = '通知';
  document.getElementById('ovMsg').textContent = msg;
  o?.setAttribute('aria-hidden','false');
  o?.style.setProperty('display','flex');
  document.getElementById('ovOk')?.onclick = document.getElementById('ovClose')?.onclick = ()=>{
    o.setAttribute('aria-hidden','true'); o.style.display='none';
  };
}

// ---- 起動時の軽量設定を強制（Canvas常時ON + 軽量モードON） ----
(function () {
  // 軽量モードをセレクトに反映 → 実処理 setPerfMode(true)
  function enforcePerfOn() {
    try {
      const sel = document.getElementById('perfMode');
      if (sel) sel.value = 'on';
      if (typeof setPerfMode === 'function') setPerfMode(true);
      if (typeof updateCanvasAutoToggle === 'function') updateCanvasAutoToggle();
      // 念押し：Canvas強制ON（既存の enableCanvasStations を直接呼ぶ）
      if (typeof enableCanvasStations === 'function') enableCanvasStations(true);
    } catch {}
  }
  // DOM 構築後＆load後の両方で実行（順序に依存しないよう二重保険）
  document.addEventListener('DOMContentLoaded', enforcePerfOn, { once: true });
  window.addEventListener('load', enforcePerfOn, { once: true });

  // UIで誤ってOFFにしても即復帰
  document.addEventListener('change', (e) => {
    if (e.target && (e.target.id === 'perfMode' || e.target.id === 'perfToggle')) {
      enforcePerfOn();
    }
  });
})();

// ---- 簡易サイトモデル：盆地・平野は増幅、山地・標準は1.0 ----
// ざっくり矩形/多角形で代表的な盆地・平野をカバー（必要に応じて拡張可）
(function () {
  // 代表ゾーン（必要に応じて自由に増減OK）
  const SITE_ZONES = [
    { name:'関東平野', amp:1.80, poly:[[36.4,139.1],[36.4,140.9],[35.1,140.9],[35.1,139.1]] },
    { name:'新潟平野', amp:1.60, poly:[[38.2,138.8],[38.2,139.7],[37.6,139.7],[37.6,138.8]] },
    { name:'仙台平野', amp:1.50, poly:[[38.5,140.7],[38.5,141.2],[38.1,141.2],[38.1,140.7]] },
    { name:'石狩平野', amp:1.50, poly:[[43.4,141.0],[43.4,141.7],[42.8,141.7],[42.8,141.0]] },
    { name:'十勝平野', amp:1.40, poly:[[43.2,143.0],[43.2,144.9],[42.6,144.9],[42.6,143.0]] },
    { name:'濃尾平野', amp:1.60, poly:[[35.5,136.7],[35.5,137.2],[35.0,137.2],[35.0,136.7]] },
    { name:'大阪平野', amp:1.70, poly:[[34.9,135.3],[34.9,135.7],[34.5,135.7],[34.5,135.3]] },
    { name:'京都盆地', amp:1.40, poly:[[35.1,135.6],[35.1,135.85],[34.9,135.85],[34.9,135.6]] },
    { name:'奈良盆地', amp:1.40, poly:[[34.7,135.7],[34.7,135.9],[34.5,135.9],[34.5,135.7]] },
    { name:'福岡平野', amp:1.30, poly:[[33.7,130.3],[33.7,130.5],[33.5,130.5],[33.5,130.3]] },
    { name:'筑紫平野', amp:1.40, poly:[[33.4,130.3],[33.4,130.7],[33.0,130.7],[33.0,130.3]] },
    { name:'那覇周辺軟弱層', amp:1.30, poly:[[26.3,127.6],[26.3,127.8],[26.1,127.8],[26.1,127.6]] },
  ];

  // 既存の pointInPolygon を流用（あなたのコードに既にあります）
  function sitePropsAt(lat, lng) {
    try {
      for (const z of SITE_ZONES) {
        if (typeof pointInPolygon === 'function' && pointInPolygon(lat, lng, z.poly)) {
          return { zone: z.name, amp: z.amp };
        }
      }
    } catch {}
    return { zone: null, amp: 1.00 }; // 標準
  }

  // 近接点でも“ほんの少し”差が出る微小ゆらぎ（決定的=座標由来で毎回同じ）
  function jitterAmp(lat, lng) {
    const s = Math.sin((lat * 12.9898 + lng * 78.233) * 43758.5453);
    const f = s - Math.floor(s);                 // 0..1
    return 0.85 + 0.30 * f;                      // 0.85x ～ 1.15x
  }

  // --- estimatePGA を安全にラップしてサイト補正を掛ける ---
  if (typeof estimatePGA === 'function') {
    const __orig_estimatePGA = estimatePGA;
    // 引数シグネチャは元関数のまま
    estimatePGA = function (M, Rkm, depthKm = null, epiLat = null, epiLng = null, stLat = null, stLng = null) {
      let pga = __orig_estimatePGA(M, Rkm, depthKm, epiLat, epiLng, stLat, stLng);
      if (isFinite(stLat) && isFinite(stLng)) {
        const site = sitePropsAt(stLat, stLng);
        pga *= site.amp * jitterAmp(stLat, stLng);
      }
      return pga;
    };
  }
})();

(() => {
  if (typeof enableCanvasStations === 'function') {
    // 既存の自動切替を上書きして常時ON
    window.updateCanvasAutoToggle = function() {
      enableCanvasStations(true);
    };
    // 念のため、初期化直後にも1回適用
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => enableCanvasStations(true), { once: true });
    } else {
      enableCanvasStations(true);
    }
  }
})();

(() => {
  if (typeof enableCanvasStations === 'function') {
    // 既存の自動切替を上書きして常時ON
    window.updateCanvasAutoToggle = function() {
      enableCanvasStations(true);
    };
    // 念のため、初期化直後にも1回適用
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => enableCanvasStations(true), { once: true });
    } else {
      enableCanvasStations(true);
    }
  }
})();

})(); // end IIFE

</script>
</body>
</html>
